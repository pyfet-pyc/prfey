# decompyle3 version 3.7.5
# Python bytecode 3.7 (3394)
# Decompiled from: Python 3.8.11 (default, Aug 17 2021, 15:56:41) 
# [GCC 10.2.1 20210110]
# Embedded file name: lib2to3\pgen2\parse.py
"""Parser engine for the grammar tables generated by pgen.

The grammar table must be loaded first.

See Parser/parser.c in the Python distribution for additional info on
how this parsing engine works.

"""
from . import token

class ParseError(Exception):
    __doc__ = 'Exception to signal the parser is stuck.'

    def __init__(self, msg, type, value, context):
        Exception.__init__(self, '%s: type=%r, value=%r, context=%r' % (
         msg, type, value, context))
        self.msg = msg
        self.type = type
        self.value = value
        self.context = context


class Parser(object):
    __doc__ = 'Parser engine.\n\n    The proper usage sequence is:\n\n    p = Parser(grammar, [converter])  # create instance\n    p.setup([start])                  # prepare for parsing\n    <for each input token>:\n        if p.addtoken(...):           # parse a token; may raise ParseError\n            break\n    root = p.rootnode                 # root of abstract syntax tree\n\n    A Parser instance may be reused by calling setup() repeatedly.\n\n    A Parser instance contains state pertaining to the current token\n    sequence, and should not be used concurrently by different threads\n    to parse separate token sequences.\n\n    See driver.py for how to get input tokens by tokenizing a file or\n    string.\n\n    Parsing is complete when addtoken() returns True; the root of the\n    abstract syntax tree can then be retrieved from the rootnode\n    instance variable.  When a syntax error occurs, addtoken() raises\n    the ParseError exception.  There is no error recovery; the parser\n    cannot be used after a syntax error was reported (but it can be\n    reinitialized by calling setup()).\n\n    '

    def __init__(self, grammar, convert=None):
        """Constructor.

        The grammar argument is a grammar.Grammar instance; see the
        grammar module for more information.

        The parser is not ready yet for parsing; you must call the
        setup() method to get it started.

        The optional convert argument is a function mapping concrete
        syntax tree nodes to abstract syntax tree nodes.  If not
        given, no conversion is done and the syntax tree produced is
        the concrete syntax tree.  If given, it must be a function of
        two arguments, the first being the grammar (a grammar.Grammar
        instance), and the second being the concrete syntax tree node
        to be converted.  The syntax tree is converted from the bottom
        up.

        A concrete syntax tree node is a (type, value, context, nodes)
        tuple, where type is the node type (a token or symbol number),
        value is None for symbols and a string for tokens, context is
        None or an opaque value used for error reporting (typically a
        (lineno, offset) pair), and nodes is a list of children for
        symbols, and None for tokens.

        An abstract syntax tree node may be anything; this is entirely
        up to the converter function.

        """
        self.grammar = grammar
        self.convert = convert or (lambda grammar, node: node)

    def setup(self, start=None):
        """Prepare for parsing.

        This *must* be called before starting to parse.

        The optional argument is an alternative start symbol; it
        defaults to the grammar's start symbol.

        You can use a Parser instance to parse any number of programs;
        each time you call setup() the parser is reset to an initial
        state determined by the (implicit or explicit) start symbol.

        """
        if start is None:
            start = self.grammar.start
        newnode = (
         start, None, None, [])
        stackentry = (self.grammar.dfas[start], 0, newnode)
        self.stack = [stackentry]
        self.rootnode = None
        self.used_names = set()

    def addtoken--- This code section failed: ---

 L. 116         0  LOAD_FAST                'self'
                2  LOAD_METHOD              classify
                4  LOAD_FAST                'type'
                6  LOAD_FAST                'value'
                8  LOAD_FAST                'context'
               10  CALL_METHOD_3         3  '3 positional arguments'
               12  STORE_FAST               'ilabel'

 L. 118     14_16  SETUP_LOOP          322  'to 322'
             18_0  COME_FROM           318  '318'
             18_1  COME_FROM           302  '302'

 L. 119        18  LOAD_FAST                'self'
               20  LOAD_ATTR                stack
               22  LOAD_CONST               -1
               24  BINARY_SUBSCR    
               26  UNPACK_SEQUENCE_3     3 
               28  STORE_FAST               'dfa'
               30  STORE_FAST               'state'
               32  STORE_FAST               'node'

 L. 120        34  LOAD_FAST                'dfa'
               36  UNPACK_SEQUENCE_2     2 
               38  STORE_FAST               'states'
               40  STORE_FAST               'first'

 L. 121        42  LOAD_FAST                'states'
               44  LOAD_FAST                'state'
               46  BINARY_SUBSCR    
               48  STORE_FAST               'arcs'

 L. 123     50_52  SETUP_LOOP          318  'to 318'
               54  LOAD_FAST                'arcs'
               56  GET_ITER         
             58_0  COME_FROM           254  '254'
             58_1  COME_FROM           226  '226'
             58_2  COME_FROM           198  '198'
               58  FOR_ITER            256  'to 256'
               60  UNPACK_SEQUENCE_2     2 
               62  STORE_FAST               'i'
               64  STORE_FAST               'newstate'

 L. 124        66  LOAD_FAST                'self'
               68  LOAD_ATTR                grammar
               70  LOAD_ATTR                labels
               72  LOAD_FAST                'i'
               74  BINARY_SUBSCR    
               76  UNPACK_SEQUENCE_2     2 
               78  STORE_FAST               't'
               80  STORE_FAST               'v'

 L. 125        82  LOAD_FAST                'ilabel'
               84  LOAD_FAST                'i'
               86  COMPARE_OP               ==
               88  POP_JUMP_IF_FALSE   192  'to 192'

 L. 127        90  LOAD_FAST                't'
               92  LOAD_CONST               256
               94  COMPARE_OP               <
               96  POP_JUMP_IF_TRUE    102  'to 102'
               98  LOAD_ASSERT              AssertionError
              100  RAISE_VARARGS_1       1  'exception instance'
            102_0  COME_FROM            96  '96'

 L. 129       102  LOAD_FAST                'self'
              104  LOAD_METHOD              shift
              106  LOAD_FAST                'type'
              108  LOAD_FAST                'value'
              110  LOAD_FAST                'newstate'
              112  LOAD_FAST                'context'
              114  CALL_METHOD_4         4  '4 positional arguments'
              116  POP_TOP          

 L. 131       118  LOAD_FAST                'newstate'
              120  STORE_FAST               'state'

 L. 132       122  SETUP_LOOP          188  'to 188'
            124_0  COME_FROM           184  '184'
              124  LOAD_FAST                'states'
              126  LOAD_FAST                'state'
              128  BINARY_SUBSCR    
              130  LOAD_CONST               0
              132  LOAD_FAST                'state'
              134  BUILD_TUPLE_2         2 
              136  BUILD_LIST_1          1 
              138  COMPARE_OP               ==
              140  POP_JUMP_IF_FALSE   186  'to 186'

 L. 133       142  LOAD_FAST                'self'
              144  LOAD_METHOD              pop
              146  CALL_METHOD_0         0  '0 positional arguments'
              148  POP_TOP          

 L. 134       150  LOAD_FAST                'self'
              152  LOAD_ATTR                stack
              154  POP_JUMP_IF_TRUE    160  'to 160'

 L. 136       156  LOAD_CONST               True
              158  RETURN_VALUE     
            160_0  COME_FROM           154  '154'

 L. 137       160  LOAD_FAST                'self'
              162  LOAD_ATTR                stack
              164  LOAD_CONST               -1
              166  BINARY_SUBSCR    
              168  UNPACK_SEQUENCE_3     3 
              170  STORE_FAST               'dfa'
              172  STORE_FAST               'state'
              174  STORE_FAST               'node'

 L. 138       176  LOAD_FAST                'dfa'
              178  UNPACK_SEQUENCE_2     2 
              180  STORE_FAST               'states'
              182  STORE_FAST               'first'
              184  JUMP_BACK           124  'to 124'
            186_0  COME_FROM           140  '140'
              186  POP_BLOCK        
            188_0  COME_FROM_LOOP      122  '122'

 L. 140       188  LOAD_CONST               False
              190  RETURN_VALUE     
            192_0  COME_FROM            88  '88'

 L. 141       192  LOAD_FAST                't'
              194  LOAD_CONST               256
              196  COMPARE_OP               >=
              198  POP_JUMP_IF_FALSE_BACK    58  'to 58'

 L. 143       200  LOAD_FAST                'self'
              202  LOAD_ATTR                grammar
              204  LOAD_ATTR                dfas
              206  LOAD_FAST                't'
              208  BINARY_SUBSCR    
              210  STORE_FAST               'itsdfa'

 L. 144       212  LOAD_FAST                'itsdfa'
              214  UNPACK_SEQUENCE_2     2 
              216  STORE_FAST               'itsstates'
              218  STORE_FAST               'itsfirst'

 L. 145       220  LOAD_FAST                'ilabel'
              222  LOAD_FAST                'itsfirst'
              224  COMPARE_OP               in
              226  POP_JUMP_IF_FALSE_BACK    58  'to 58'

 L. 147       228  LOAD_FAST                'self'
              230  LOAD_METHOD              push
              232  LOAD_FAST                't'
              234  LOAD_FAST                'self'
              236  LOAD_ATTR                grammar
              238  LOAD_ATTR                dfas
              240  LOAD_FAST                't'
              242  BINARY_SUBSCR    
              244  LOAD_FAST                'newstate'
              246  LOAD_FAST                'context'
              248  CALL_METHOD_4         4  '4 positional arguments'
              250  POP_TOP          

 L. 148       252  BREAK_LOOP       
              254  JUMP_BACK            58  'to 58'
              256  POP_BLOCK        

 L. 150       258  LOAD_CONST               0
              260  LOAD_FAST                'state'
              262  BUILD_TUPLE_2         2 
              264  LOAD_FAST                'arcs'
              266  COMPARE_OP               in
          268_270  POP_JUMP_IF_FALSE   304  'to 304'

 L. 152       272  LOAD_FAST                'self'
              274  LOAD_METHOD              pop
              276  CALL_METHOD_0         0  '0 positional arguments'
              278  POP_TOP          

 L. 153       280  LOAD_FAST                'self'
              282  LOAD_ATTR                stack
          284_286  POP_JUMP_IF_TRUE    318  'to 318'

 L. 155       288  LOAD_GLOBAL              ParseError
              290  LOAD_STR                 'too much input'

 L. 156       292  LOAD_FAST                'type'
              294  LOAD_FAST                'value'
              296  LOAD_FAST                'context'
              298  CALL_FUNCTION_4       4  '4 positional arguments'
              300  RAISE_VARARGS_1       1  'exception instance'
              302  JUMP_BACK            18  'to 18'
            304_0  COME_FROM           268  '268'

 L. 159       304  LOAD_GLOBAL              ParseError
              306  LOAD_STR                 'bad input'
              308  LOAD_FAST                'type'
              310  LOAD_FAST                'value'
              312  LOAD_FAST                'context'
              314  CALL_FUNCTION_4       4  '4 positional arguments'
              316  RAISE_VARARGS_1       1  'exception instance'
            318_0  COME_FROM           284  '284'
            318_1  COME_FROM_LOOP       50  '50'
              318  JUMP_BACK            18  'to 18'
              320  POP_BLOCK        
            322_0  COME_FROM_LOOP       14  '14'

Parse error at or near `COME_FROM' instruction at offset 318_0

    def classify(self, type, value, context):
        """Turn a token into a label.  (Internal)"""
        if type == token.NAME:
            self.used_names.add(value)
            ilabel = self.grammar.keywords.get(value)
            if ilabel is not None:
                return ilabel
        ilabel = self.grammar.tokens.get(type)
        if ilabel is None:
            raise ParseError'bad token'typevaluecontext
        return ilabel

    def shift(self, type, value, newstate, context):
        """Shift a token.  (Internal)"""
        dfa, state, node = self.stack[(-1)]
        newnode = (type, value, context, None)
        newnode = self.convert(self.grammar, newnode)
        if newnode is not None:
            node[(-1)].append(newnode)
        self.stack[-1] = (
         dfa, newstate, node)

    def push(self, type, newdfa, newstate, context):
        """Push a nonterminal.  (Internal)"""
        dfa, state, node = self.stack[(-1)]
        newnode = (type, None, context, [])
        self.stack[-1] = (dfa, newstate, node)
        self.stack.append((newdfa, 0, newnode))

    def pop(self):
        """Pop a nonterminal.  (Internal)"""
        popdfa, popstate, popnode = self.stack.pop
        newnode = self.convert(self.grammar, popnode)
        if newnode is not None:
            if self.stack:
                dfa, state, node = self.stack[(-1)]
                node[(-1)].append(newnode)
            else:
                self.rootnode = newnode
                self.rootnode.used_names = self.used_names