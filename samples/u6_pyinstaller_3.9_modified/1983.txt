
# file test/1983.pyc
# --- This code section failed: ---

 L.   1         0  LOAD_STR                 '\nThis is only meant to add docs to objects defined in C-extension modules.\nThe purpose is to allow easier editing of the docstrings without\nrequiring a re-compile.\n\nNOTE: Many of the methods of ndarray have corresponding functions.\n      If you update these docstrings, please keep also the ones in\n      core/fromnumeric.py, core/defmatrix.py up-to-date.\n\n'
                2  STORE_NAME               __doc__

 L.  12         4  LOAD_CONST               0
                6  LOAD_CONST               ('numerictypes',)
                8  IMPORT_NAME_ATTR         numpy.core
               10  IMPORT_FROM              numerictypes
               12  STORE_NAME               _numerictypes
               14  POP_TOP          

 L.  13        16  LOAD_CONST               0
               18  LOAD_CONST               ('dtype',)
               20  IMPORT_NAME_ATTR         numpy.core
               22  IMPORT_FROM              dtype
               24  STORE_NAME               dtype
               26  POP_TOP          

 L.  14        28  LOAD_CONST               0
               30  LOAD_CONST               ('add_newdoc',)
               32  IMPORT_NAME_ATTR         numpy.core.function_base
               34  IMPORT_FROM              add_newdoc
               36  STORE_NAME               add_newdoc
               38  POP_TOP          

 L.  24        40  LOAD_NAME                add_newdoc
               42  LOAD_STR                 'numpy.core'
               44  LOAD_STR                 'flatiter'

 L.  25        46  LOAD_STR                 "\n    Flat iterator object to iterate over arrays.\n\n    A `flatiter` iterator is returned by ``x.flat`` for any array `x`.\n    It allows iterating over the array as if it were a 1-D array,\n    either in a for-loop or by calling its `next` method.\n\n    Iteration is done in row-major, C-style order (the last\n    index varying the fastest). The iterator can also be indexed using\n    basic slicing or advanced indexing.\n\n    See Also\n    --------\n    ndarray.flat : Return a flat iterator over an array.\n    ndarray.flatten : Returns a flattened copy of an array.\n\n    Notes\n    -----\n    A `flatiter` iterator can not be constructed directly from Python code\n    by calling the `flatiter` constructor.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2, 3)\n    >>> fl = x.flat\n    >>> type(fl)\n    <class 'numpy.flatiter'>\n    >>> for item in fl:\n    ...     print(item)\n    ...\n    0\n    1\n    2\n    3\n    4\n    5\n\n    >>> fl[2:4]\n    array([2, 3])\n\n    "

 L.  24        48  CALL_FUNCTION_3       3  ''
               50  POP_TOP          

 L.  69        52  LOAD_NAME                add_newdoc
               54  LOAD_STR                 'numpy.core'
               56  LOAD_STR                 'flatiter'
               58  LOAD_CONST               ('base', '\n    A reference to the array that is iterated over.\n\n    Examples\n    --------\n    >>> x = np.arange(5)\n    >>> fl = x.flat\n    >>> fl.base is x\n    True\n\n    ')
               60  CALL_FUNCTION_3       3  ''
               62  POP_TOP          

 L.  84        64  LOAD_NAME                add_newdoc
               66  LOAD_STR                 'numpy.core'
               68  LOAD_STR                 'flatiter'
               70  LOAD_CONST               ('coords', '\n    An N-dimensional tuple of current coordinates.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2, 3)\n    >>> fl = x.flat\n    >>> fl.coords\n    (0, 0)\n    >>> next(fl)\n    0\n    >>> fl.coords\n    (0, 1)\n\n    ')
               72  CALL_FUNCTION_3       3  ''
               74  POP_TOP          

 L. 103        76  LOAD_NAME                add_newdoc
               78  LOAD_STR                 'numpy.core'
               80  LOAD_STR                 'flatiter'
               82  LOAD_CONST               ('index', '\n    Current flat index into the array.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2, 3)\n    >>> fl = x.flat\n    >>> fl.index\n    0\n    >>> next(fl)\n    0\n    >>> fl.index\n    1\n\n    ')
               84  CALL_FUNCTION_3       3  ''
               86  POP_TOP          

 L. 122        88  LOAD_NAME                add_newdoc
               90  LOAD_STR                 'numpy.core'
               92  LOAD_STR                 'flatiter'
               94  LOAD_CONST               ('__array__', '__array__(type=None) Get array from iterator\n\n    ')
               96  CALL_FUNCTION_3       3  ''
               98  POP_TOP          

 L. 128       100  LOAD_NAME                add_newdoc
              102  LOAD_STR                 'numpy.core'
              104  LOAD_STR                 'flatiter'
              106  LOAD_CONST               ('copy', '\n    copy()\n\n    Get a copy of the iterator as a 1-D array.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2, 3)\n    >>> x\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> fl = x.flat\n    >>> fl.copy()\n    array([0, 1, 2, 3, 4, 5])\n\n    ')
              108  CALL_FUNCTION_3       3  ''
              110  POP_TOP          

 L. 153       112  LOAD_NAME                add_newdoc
              114  LOAD_STR                 'numpy.core'
              116  LOAD_STR                 'nditer'

 L. 154       118  LOAD_STR                 '\n    nditer(op, flags=None, op_flags=None, op_dtypes=None, order=\'K\', casting=\'safe\', op_axes=None, itershape=None, buffersize=0)\n\n    Efficient multi-dimensional iterator object to iterate over arrays.\n    To get started using this object, see the\n    :ref:`introductory guide to array iteration <arrays.nditer>`.\n\n    Parameters\n    ----------\n    op : ndarray or sequence of array_like\n        The array(s) to iterate over.\n\n    flags : sequence of str, optional\n          Flags to control the behavior of the iterator.\n\n          * ``buffered`` enables buffering when required.\n          * ``c_index`` causes a C-order index to be tracked.\n          * ``f_index`` causes a Fortran-order index to be tracked.\n          * ``multi_index`` causes a multi-index, or a tuple of indices\n            with one per iteration dimension, to be tracked.\n          * ``common_dtype`` causes all the operands to be converted to\n            a common data type, with copying or buffering as necessary.\n          * ``copy_if_overlap`` causes the iterator to determine if read\n            operands have overlap with write operands, and make temporary\n            copies as necessary to avoid overlap. False positives (needless\n            copying) are possible in some cases.\n          * ``delay_bufalloc`` delays allocation of the buffers until\n            a reset() call is made. Allows ``allocate`` operands to\n            be initialized before their values are copied into the buffers.\n          * ``external_loop`` causes the ``values`` given to be\n            one-dimensional arrays with multiple values instead of\n            zero-dimensional arrays.\n          * ``grow_inner`` allows the ``value`` array sizes to be made\n            larger than the buffer size when both ``buffered`` and\n            ``external_loop`` is used.\n          * ``ranged`` allows the iterator to be restricted to a sub-range\n            of the iterindex values.\n          * ``refs_ok`` enables iteration of reference types, such as\n            object arrays.\n          * ``reduce_ok`` enables iteration of ``readwrite`` operands\n            which are broadcasted, also known as reduction operands.\n          * ``zerosize_ok`` allows `itersize` to be zero.\n    op_flags : list of list of str, optional\n          This is a list of flags for each operand. At minimum, one of\n          ``readonly``, ``readwrite``, or ``writeonly`` must be specified.\n\n          * ``readonly`` indicates the operand will only be read from.\n          * ``readwrite`` indicates the operand will be read from and written to.\n          * ``writeonly`` indicates the operand will only be written to.\n          * ``no_broadcast`` prevents the operand from being broadcasted.\n          * ``contig`` forces the operand data to be contiguous.\n          * ``aligned`` forces the operand data to be aligned.\n          * ``nbo`` forces the operand data to be in native byte order.\n          * ``copy`` allows a temporary read-only copy if required.\n          * ``updateifcopy`` allows a temporary read-write copy if required.\n          * ``allocate`` causes the array to be allocated if it is None\n            in the ``op`` parameter.\n          * ``no_subtype`` prevents an ``allocate`` operand from using a subtype.\n          * ``arraymask`` indicates that this operand is the mask to use\n            for selecting elements when writing to operands with the\n            \'writemasked\' flag set. The iterator does not enforce this,\n            but when writing from a buffer back to the array, it only\n            copies those elements indicated by this mask.\n          * ``writemasked`` indicates that only elements where the chosen\n            ``arraymask`` operand is True will be written to.\n          * ``overlap_assume_elementwise`` can be used to mark operands that are\n            accessed only in the iterator order, to allow less conservative\n            copying when ``copy_if_overlap`` is present.\n    op_dtypes : dtype or tuple of dtype(s), optional\n        The required data type(s) of the operands. If copying or buffering\n        is enabled, the data will be converted to/from their original types.\n    order : {\'C\', \'F\', \'A\', \'K\'}, optional\n        Controls the iteration order. \'C\' means C order, \'F\' means\n        Fortran order, \'A\' means \'F\' order if all the arrays are Fortran\n        contiguous, \'C\' order otherwise, and \'K\' means as close to the\n        order the array elements appear in memory as possible. This also\n        affects the element memory order of ``allocate`` operands, as they\n        are allocated to be compatible with iteration order.\n        Default is \'K\'.\n    casting : {\'no\', \'equiv\', \'safe\', \'same_kind\', \'unsafe\'}, optional\n        Controls what kind of data casting may occur when making a copy\n        or buffering.  Setting this to \'unsafe\' is not recommended,\n        as it can adversely affect accumulations.\n\n        * \'no\' means the data types should not be cast at all.\n        * \'equiv\' means only byte-order changes are allowed.\n        * \'safe\' means only casts which can preserve values are allowed.\n        * \'same_kind\' means only safe casts or casts within a kind,\n          like float64 to float32, are allowed.\n        * \'unsafe\' means any data conversions may be done.\n    op_axes : list of list of ints, optional\n        If provided, is a list of ints or None for each operands.\n        The list of axes for an operand is a mapping from the dimensions\n        of the iterator to the dimensions of the operand. A value of\n        -1 can be placed for entries, causing that dimension to be\n        treated as `newaxis`.\n    itershape : tuple of ints, optional\n        The desired shape of the iterator. This allows ``allocate`` operands\n        with a dimension mapped by op_axes not corresponding to a dimension\n        of a different operand to get a value not equal to 1 for that\n        dimension.\n    buffersize : int, optional\n        When buffering is enabled, controls the size of the temporary\n        buffers. Set to 0 for the default value.\n\n    Attributes\n    ----------\n    dtypes : tuple of dtype(s)\n        The data types of the values provided in `value`. This may be\n        different from the operand data types if buffering is enabled.\n        Valid only before the iterator is closed.\n    finished : bool\n        Whether the iteration over the operands is finished or not.\n    has_delayed_bufalloc : bool\n        If True, the iterator was created with the ``delay_bufalloc`` flag,\n        and no reset() function was called on it yet.\n    has_index : bool\n        If True, the iterator was created with either the ``c_index`` or\n        the ``f_index`` flag, and the property `index` can be used to\n        retrieve it.\n    has_multi_index : bool\n        If True, the iterator was created with the ``multi_index`` flag,\n        and the property `multi_index` can be used to retrieve it.\n    index\n        When the ``c_index`` or ``f_index`` flag was used, this property\n        provides access to the index. Raises a ValueError if accessed\n        and ``has_index`` is False.\n    iterationneedsapi : bool\n        Whether iteration requires access to the Python API, for example\n        if one of the operands is an object array.\n    iterindex : int\n        An index which matches the order of iteration.\n    itersize : int\n        Size of the iterator.\n    itviews\n        Structured view(s) of `operands` in memory, matching the reordered\n        and optimized iterator access pattern. Valid only before the iterator\n        is closed.\n    multi_index\n        When the ``multi_index`` flag was used, this property\n        provides access to the index. Raises a ValueError if accessed\n        accessed and ``has_multi_index`` is False.\n    ndim : int\n        The dimensions of the iterator.\n    nop : int\n        The number of iterator operands.\n    operands : tuple of operand(s)\n        The array(s) to be iterated over. Valid only before the iterator is\n        closed.\n    shape : tuple of ints\n        Shape tuple, the shape of the iterator.\n    value\n        Value of ``operands`` at current iteration. Normally, this is a\n        tuple of array scalars, but if the flag ``external_loop`` is used,\n        it is a tuple of one dimensional arrays.\n\n    Notes\n    -----\n    `nditer` supersedes `flatiter`.  The iterator implementation behind\n    `nditer` is also exposed by the NumPy C API.\n\n    The Python exposure supplies two iteration interfaces, one which follows\n    the Python iterator protocol, and another which mirrors the C-style\n    do-while pattern.  The native Python approach is better in most cases, but\n    if you need the coordinates or index of an iterator, use the C-style pattern.\n\n    Examples\n    --------\n    Here is how we might write an ``iter_add`` function, using the\n    Python iterator protocol:\n\n    >>> def iter_add_py(x, y, out=None):\n    ...     addop = np.add\n    ...     it = np.nditer([x, y, out], [],\n    ...                 [[\'readonly\'], [\'readonly\'], [\'writeonly\',\'allocate\']])\n    ...     with it:\n    ...         for (a, b, c) in it:\n    ...             addop(a, b, out=c)\n    ...     return it.operands[2]\n\n    Here is the same function, but following the C-style pattern:\n\n    >>> def iter_add(x, y, out=None):\n    ...    addop = np.add\n    ...    it = np.nditer([x, y, out], [],\n    ...                [[\'readonly\'], [\'readonly\'], [\'writeonly\',\'allocate\']])\n    ...    with it:\n    ...        while not it.finished:\n    ...            addop(it[0], it[1], out=it[2])\n    ...            it.iternext()\n    ...        return it.operands[2]\n\n    Here is an example outer product function:\n\n    >>> def outer_it(x, y, out=None):\n    ...     mulop = np.multiply\n    ...     it = np.nditer([x, y, out], [\'external_loop\'],\n    ...             [[\'readonly\'], [\'readonly\'], [\'writeonly\', \'allocate\']],\n    ...             op_axes=[list(range(x.ndim)) + [-1] * y.ndim,\n    ...                      [-1] * x.ndim + list(range(y.ndim)),\n    ...                      None])\n    ...     with it:\n    ...         for (a, b, c) in it:\n    ...             mulop(a, b, out=c)\n    ...         return it.operands[2]\n\n    >>> a = np.arange(2)+1\n    >>> b = np.arange(3)+1\n    >>> outer_it(a,b)\n    array([[1, 2, 3],\n           [2, 4, 6]])\n\n    Here is an example function which operates like a "lambda" ufunc:\n\n    >>> def luf(lamdaexpr, *args, **kwargs):\n    ...    \'\'\'luf(lambdaexpr, op1, ..., opn, out=None, order=\'K\', casting=\'safe\', buffersize=0)\'\'\'\n    ...    nargs = len(args)\n    ...    op = (kwargs.get(\'out\',None),) + args\n    ...    it = np.nditer(op, [\'buffered\',\'external_loop\'],\n    ...            [[\'writeonly\',\'allocate\',\'no_broadcast\']] +\n    ...                            [[\'readonly\',\'nbo\',\'aligned\']]*nargs,\n    ...            order=kwargs.get(\'order\',\'K\'),\n    ...            casting=kwargs.get(\'casting\',\'safe\'),\n    ...            buffersize=kwargs.get(\'buffersize\',0))\n    ...    while not it.finished:\n    ...        it[0] = lamdaexpr(*it[1:])\n    ...        it.iternext()\n    ...        return it.operands[0]\n\n    >>> a = np.arange(5)\n    >>> b = np.ones(5)\n    >>> luf(lambda i,j:i*i + j/2, a, b)\n    array([  0.5,   1.5,   4.5,   9.5,  16.5])\n\n    If operand flags `"writeonly"` or `"readwrite"` are used the\n    operands may be views into the original data with the\n    `WRITEBACKIFCOPY` flag. In this case `nditer` must be used as a\n    context manager or the `nditer.close` method must be called before\n    using the result. The temporary data will be written back to the\n    original data when the `__exit__` function is called but not before:\n\n    >>> a = np.arange(6, dtype=\'i4\')[::-2]\n    >>> with np.nditer(a, [],\n    ...        [[\'writeonly\', \'updateifcopy\']],\n    ...        casting=\'unsafe\',\n    ...        op_dtypes=[np.dtype(\'f4\')]) as i:\n    ...    x = i.operands[0]\n    ...    x[:] = [-1, -2, -3]\n    ...    # a still unchanged here\n    >>> a, x\n    (array([-1, -2, -3], dtype=int32), array([-1., -2., -3.], dtype=float32))\n\n    It is important to note that once the iterator is exited, dangling\n    references (like `x` in the example) may or may not share data with\n    the original data `a`. If writeback semantics were active, i.e. if\n    `x.base.flags.writebackifcopy` is `True`, then exiting the iterator\n    will sever the connection between `x` and `a`, writing to `x` will\n    no longer write to `a`. If writeback semantics are not active, then\n    `x.data` will still point at some part of `a.data`, and writing to\n    one will affect the other.\n\n    Context management and the `close` method appeared in version 1.15.0.\n\n    '

 L. 153       120  CALL_FUNCTION_3       3  ''
              122  POP_TOP          

 L. 421       124  LOAD_NAME                add_newdoc
              126  LOAD_STR                 'numpy.core'
              128  LOAD_STR                 'nditer'
              130  LOAD_CONST               ('copy', '\n    copy()\n\n    Get a copy of the iterator in its current state.\n\n    Examples\n    --------\n    >>> x = np.arange(10)\n    >>> y = x + 1\n    >>> it = np.nditer([x, y])\n    >>> next(it)\n    (array(0), array(1))\n    >>> it2 = it.copy()\n    >>> next(it2)\n    (array(1), array(2))\n\n    ')
              132  CALL_FUNCTION_3       3  ''
              134  POP_TOP          

 L. 440       136  LOAD_NAME                add_newdoc
              138  LOAD_STR                 'numpy.core'
              140  LOAD_STR                 'nditer'
              142  LOAD_CONST               ('operands', '\n    operands[`Slice`]\n\n    The array(s) to be iterated over. Valid only before the iterator is closed.\n    ')
              144  CALL_FUNCTION_3       3  ''
              146  POP_TOP          

 L. 447       148  LOAD_NAME                add_newdoc
              150  LOAD_STR                 'numpy.core'
              152  LOAD_STR                 'nditer'
              154  LOAD_CONST               ('debug_print', '\n    debug_print()\n\n    Print the current state of the `nditer` instance and debug info to stdout.\n\n    ')
              156  CALL_FUNCTION_3       3  ''
              158  POP_TOP          

 L. 455       160  LOAD_NAME                add_newdoc
              162  LOAD_STR                 'numpy.core'
              164  LOAD_STR                 'nditer'
              166  LOAD_CONST               ('enable_external_loop', '\n    enable_external_loop()\n\n    When the "external_loop" was not used during construction, but\n    is desired, this modifies the iterator to behave as if the flag\n    was specified.\n\n    ')
              168  CALL_FUNCTION_3       3  ''
              170  POP_TOP          

 L. 465       172  LOAD_NAME                add_newdoc
              174  LOAD_STR                 'numpy.core'
              176  LOAD_STR                 'nditer'
              178  LOAD_CONST               ('iternext', '\n    iternext()\n\n    Check whether iterations are left, and perform a single internal iteration\n    without returning the result.  Used in the C-style pattern do-while\n    pattern.  For an example, see `nditer`.\n\n    Returns\n    -------\n    iternext : bool\n        Whether or not there are iterations left.\n\n    ')
              180  CALL_FUNCTION_3       3  ''
              182  POP_TOP          

 L. 480       184  LOAD_NAME                add_newdoc
              186  LOAD_STR                 'numpy.core'
              188  LOAD_STR                 'nditer'
              190  LOAD_CONST               ('remove_axis', '\n    remove_axis(i)\n\n    Removes axis `i` from the iterator. Requires that the flag "multi_index"\n    be enabled.\n\n    ')
              192  CALL_FUNCTION_3       3  ''
              194  POP_TOP          

 L. 489       196  LOAD_NAME                add_newdoc
              198  LOAD_STR                 'numpy.core'
              200  LOAD_STR                 'nditer'
              202  LOAD_CONST               ('remove_multi_index', '\n    remove_multi_index()\n\n    When the "multi_index" flag was specified, this removes it, allowing\n    the internal iteration structure to be optimized further.\n\n    ')
              204  CALL_FUNCTION_3       3  ''
              206  POP_TOP          

 L. 498       208  LOAD_NAME                add_newdoc
              210  LOAD_STR                 'numpy.core'
              212  LOAD_STR                 'nditer'
              214  LOAD_CONST               ('reset', '\n    reset()\n\n    Reset the iterator to its initial state.\n\n    ')
              216  CALL_FUNCTION_3       3  ''
              218  POP_TOP          

 L. 506       220  LOAD_NAME                add_newdoc
              222  LOAD_STR                 'numpy.core'
              224  LOAD_STR                 'nested_iters'

 L. 507       226  LOAD_STR                 '\n    Create nditers for use in nested loops\n\n    Create a tuple of `nditer` objects which iterate in nested loops over\n    different axes of the op argument. The first iterator is used in the\n    outermost loop, the last in the innermost loop. Advancing one will change\n    the subsequent iterators to point at its new element.\n\n    Parameters\n    ----------\n    op : ndarray or sequence of array_like\n        The array(s) to iterate over.\n\n    axes : list of list of int\n        Each item is used as an "op_axes" argument to an nditer\n\n    flags, op_flags, op_dtypes, order, casting, buffersize (optional)\n        See `nditer` parameters of the same name\n\n    Returns\n    -------\n    iters : tuple of nditer\n        An nditer for each item in `axes`, outermost first\n\n    See Also\n    --------\n    nditer\n\n    Examples\n    --------\n\n    Basic usage. Note how y is the "flattened" version of\n    [a[:, 0, :], a[:, 1, 0], a[:, 2, :]] since we specified\n    the first iter\'s axes as [1]\n\n    >>> a = np.arange(12).reshape(2, 3, 2)\n    >>> i, j = np.nested_iters(a, [[1], [0, 2]], flags=["multi_index"])\n    >>> for x in i:\n    ...      print(i.multi_index)\n    ...      for y in j:\n    ...          print(\'\', j.multi_index, y)\n    (0,)\n     (0, 0) 0\n     (0, 1) 1\n     (1, 0) 6\n     (1, 1) 7\n    (1,)\n     (0, 0) 2\n     (0, 1) 3\n     (1, 0) 8\n     (1, 1) 9\n    (2,)\n     (0, 0) 4\n     (0, 1) 5\n     (1, 0) 10\n     (1, 1) 11\n\n    '

 L. 506       228  CALL_FUNCTION_3       3  ''
              230  POP_TOP          

 L. 566       232  LOAD_NAME                add_newdoc
              234  LOAD_STR                 'numpy.core'
              236  LOAD_STR                 'nditer'
              238  LOAD_CONST               ('close', '\n    close()\n\n    Resolve all writeback semantics in writeable operands.\n\n    .. versionadded:: 1.15.0\n\n    See Also\n    --------\n\n    :ref:`nditer-context-manager`\n\n    ')
              240  CALL_FUNCTION_3       3  ''
              242  POP_TOP          

 L. 588       244  LOAD_NAME                add_newdoc
              246  LOAD_STR                 'numpy.core'
              248  LOAD_STR                 'broadcast'

 L. 589       250  LOAD_STR                 '\n    Produce an object that mimics broadcasting.\n\n    Parameters\n    ----------\n    in1, in2, ... : array_like\n        Input parameters.\n\n    Returns\n    -------\n    b : broadcast object\n        Broadcast the input parameters against one another, and\n        return an object that encapsulates the result.\n        Amongst others, it has ``shape`` and ``nd`` properties, and\n        may be used as an iterator.\n\n    See Also\n    --------\n    broadcast_arrays\n    broadcast_to\n\n    Examples\n    --------\n\n    Manually adding two vectors, using broadcasting:\n\n    >>> x = np.array([[1], [2], [3]])\n    >>> y = np.array([4, 5, 6])\n    >>> b = np.broadcast(x, y)\n\n    >>> out = np.empty(b.shape)\n    >>> out.flat = [u+v for (u,v) in b]\n    >>> out\n    array([[5.,  6.,  7.],\n           [6.,  7.,  8.],\n           [7.,  8.,  9.]])\n\n    Compare against built-in broadcasting:\n\n    >>> x + y\n    array([[5, 6, 7],\n           [6, 7, 8],\n           [7, 8, 9]])\n\n    '

 L. 588       252  CALL_FUNCTION_3       3  ''
              254  POP_TOP          

 L. 637       256  LOAD_NAME                add_newdoc
              258  LOAD_STR                 'numpy.core'
              260  LOAD_STR                 'broadcast'
              262  LOAD_CONST               ('index', '\n    current index in broadcasted result\n\n    Examples\n    --------\n    >>> x = np.array([[1], [2], [3]])\n    >>> y = np.array([4, 5, 6])\n    >>> b = np.broadcast(x, y)\n    >>> b.index\n    0\n    >>> next(b), next(b), next(b)\n    ((1, 4), (1, 5), (1, 6))\n    >>> b.index\n    3\n\n    ')
              264  CALL_FUNCTION_3       3  ''
              266  POP_TOP          

 L. 655       268  LOAD_NAME                add_newdoc
              270  LOAD_STR                 'numpy.core'
              272  LOAD_STR                 'broadcast'
              274  LOAD_CONST               ('iters', '\n    tuple of iterators along ``self``\'s "components."\n\n    Returns a tuple of `numpy.flatiter` objects, one for each "component"\n    of ``self``.\n\n    See Also\n    --------\n    numpy.flatiter\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 3])\n    >>> y = np.array([[4], [5], [6]])\n    >>> b = np.broadcast(x, y)\n    >>> row, col = b.iters\n    >>> next(row), next(col)\n    (1, 4)\n\n    ')
              276  CALL_FUNCTION_3       3  ''
              278  POP_TOP          

 L. 677       280  LOAD_NAME                add_newdoc
              282  LOAD_STR                 'numpy.core'
              284  LOAD_STR                 'broadcast'
              286  LOAD_CONST               ('ndim', '\n    Number of dimensions of broadcasted result. Alias for `nd`.\n\n    .. versionadded:: 1.12.0\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 3])\n    >>> y = np.array([[4], [5], [6]])\n    >>> b = np.broadcast(x, y)\n    >>> b.ndim\n    2\n\n    ')
              288  CALL_FUNCTION_3       3  ''
              290  POP_TOP          

 L. 693       292  LOAD_NAME                add_newdoc
              294  LOAD_STR                 'numpy.core'
              296  LOAD_STR                 'broadcast'
              298  LOAD_CONST               ('nd', '\n    Number of dimensions of broadcasted result. For code intended for NumPy\n    1.12.0 and later the more consistent `ndim` is preferred.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 3])\n    >>> y = np.array([[4], [5], [6]])\n    >>> b = np.broadcast(x, y)\n    >>> b.nd\n    2\n\n    ')
              300  CALL_FUNCTION_3       3  ''
              302  POP_TOP          

 L. 708       304  LOAD_NAME                add_newdoc
              306  LOAD_STR                 'numpy.core'
              308  LOAD_STR                 'broadcast'
              310  LOAD_CONST               ('numiter', '\n    Number of iterators possessed by the broadcasted result.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 3])\n    >>> y = np.array([[4], [5], [6]])\n    >>> b = np.broadcast(x, y)\n    >>> b.numiter\n    2\n\n    ')
              312  CALL_FUNCTION_3       3  ''
              314  POP_TOP          

 L. 722       316  LOAD_NAME                add_newdoc
              318  LOAD_STR                 'numpy.core'
              320  LOAD_STR                 'broadcast'
              322  LOAD_CONST               ('shape', '\n    Shape of broadcasted result.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 3])\n    >>> y = np.array([[4], [5], [6]])\n    >>> b = np.broadcast(x, y)\n    >>> b.shape\n    (3, 3)\n\n    ')
              324  CALL_FUNCTION_3       3  ''
              326  POP_TOP          

 L. 736       328  LOAD_NAME                add_newdoc
              330  LOAD_STR                 'numpy.core'
              332  LOAD_STR                 'broadcast'
              334  LOAD_CONST               ('size', '\n    Total size of broadcasted result.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 3])\n    >>> y = np.array([[4], [5], [6]])\n    >>> b = np.broadcast(x, y)\n    >>> b.size\n    9\n\n    ')
              336  CALL_FUNCTION_3       3  ''
              338  POP_TOP          

 L. 750       340  LOAD_NAME                add_newdoc
              342  LOAD_STR                 'numpy.core'
              344  LOAD_STR                 'broadcast'
              346  LOAD_CONST               ('reset', "\n    reset()\n\n    Reset the broadcasted result's iterator(s).\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    None\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 3])\n    >>> y = np.array([[4], [5], [6]])\n    >>> b = np.broadcast(x, y)\n    >>> b.index\n    0\n    >>> next(b), next(b), next(b)\n    ((1, 4), (2, 4), (3, 4))\n    >>> b.index\n    3\n    >>> b.reset()\n    >>> b.index\n    0\n\n    ")
              348  CALL_FUNCTION_3       3  ''
              350  POP_TOP          

 L. 787       352  LOAD_NAME                add_newdoc
              354  LOAD_STR                 'numpy.core.multiarray'
              356  LOAD_STR                 'array'

 L. 788       358  LOAD_STR                 "\n    array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0)\n\n    Create an array.\n\n    Parameters\n    ----------\n    object : array_like\n        An array, any object exposing the array interface, an object whose\n        __array__ method returns an array, or any (nested) sequence.\n    dtype : data-type, optional\n        The desired data-type for the array.  If not given, then the type will\n        be determined as the minimum type required to hold the objects in the\n        sequence.\n    copy : bool, optional\n        If true (default), then the object is copied.  Otherwise, a copy will\n        only be made if __array__ returns a copy, if obj is a nested sequence,\n        or if a copy is needed to satisfy any of the other requirements\n        (`dtype`, `order`, etc.).\n    order : {'K', 'A', 'C', 'F'}, optional\n        Specify the memory layout of the array. If object is not an array, the\n        newly created array will be in C order (row major) unless 'F' is\n        specified, in which case it will be in Fortran order (column major).\n        If object is an array the following holds.\n\n        ===== ========= ===================================================\n        order  no copy                     copy=True\n        ===== ========= ===================================================\n        'K'   unchanged F & C order preserved, otherwise most similar order\n        'A'   unchanged F order if input is F and not C, otherwise C order\n        'C'   C order   C order\n        'F'   F order   F order\n        ===== ========= ===================================================\n\n        When ``copy=False`` and a copy is made for other reasons, the result is\n        the same as if ``copy=True``, with some exceptions for `A`, see the\n        Notes section. The default order is 'K'.\n    subok : bool, optional\n        If True, then sub-classes will be passed-through, otherwise\n        the returned array will be forced to be a base-class array (default).\n    ndmin : int, optional\n        Specifies the minimum number of dimensions that the resulting\n        array should have.  Ones will be pre-pended to the shape as\n        needed to meet this requirement.\n\n    Returns\n    -------\n    out : ndarray\n        An array object satisfying the specified requirements.\n\n    See Also\n    --------\n    empty_like : Return an empty array with shape and type of input.\n    ones_like : Return an array of ones with shape and type of input.\n    zeros_like : Return an array of zeros with shape and type of input.\n    full_like : Return a new array with shape of input filled with value.\n    empty : Return a new uninitialized array.\n    ones : Return a new array setting values to one.\n    zeros : Return a new array setting values to zero.\n    full : Return a new array of given shape filled with value.\n\n\n    Notes\n    -----\n    When order is 'A' and `object` is an array in neither 'C' nor 'F' order,\n    and a copy is forced by a change in dtype, then the order of the result is\n    not necessarily 'C' as expected. This is likely a bug.\n\n    Examples\n    --------\n    >>> np.array([1, 2, 3])\n    array([1, 2, 3])\n\n    Upcasting:\n\n    >>> np.array([1, 2, 3.0])\n    array([ 1.,  2.,  3.])\n\n    More than one dimension:\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1, 2],\n           [3, 4]])\n\n    Minimum dimensions 2:\n\n    >>> np.array([1, 2, 3], ndmin=2)\n    array([[1, 2, 3]])\n\n    Type provided:\n\n    >>> np.array([1, 2, 3], dtype=complex)\n    array([ 1.+0.j,  2.+0.j,  3.+0.j])\n\n    Data-type consisting of more than one element:\n\n    >>> x = np.array([(1,2),(3,4)],dtype=[('a','<i4'),('b','<i4')])\n    >>> x['a']\n    array([1, 3])\n\n    Creating an array from sub-classes:\n\n    >>> np.array(np.mat('1 2; 3 4'))\n    array([[1, 2],\n           [3, 4]])\n\n    >>> np.array(np.mat('1 2; 3 4'), subok=True)\n    matrix([[1, 2],\n            [3, 4]])\n\n    "

 L. 787       360  CALL_FUNCTION_3       3  ''
              362  POP_TOP          

 L. 900       364  LOAD_NAME                add_newdoc
              366  LOAD_STR                 'numpy.core.multiarray'
              368  LOAD_STR                 'empty'

 L. 901       370  LOAD_STR                 "\n    empty(shape, dtype=float, order='C')\n\n    Return a new array of given shape and type, without initializing entries.\n\n    Parameters\n    ----------\n    shape : int or tuple of int\n        Shape of the empty array, e.g., ``(2, 3)`` or ``2``.\n    dtype : data-type, optional\n        Desired output data-type for the array, e.g, `numpy.int8`. Default is\n        `numpy.float64`.\n    order : {'C', 'F'}, optional, default: 'C'\n        Whether to store multi-dimensional data in row-major\n        (C-style) or column-major (Fortran-style) order in\n        memory.\n\n    Returns\n    -------\n    out : ndarray\n        Array of uninitialized (arbitrary) data of the given shape, dtype, and\n        order.  Object arrays will be initialized to None.\n\n    See Also\n    --------\n    empty_like : Return an empty array with shape and type of input.\n    ones : Return a new array setting values to one.\n    zeros : Return a new array setting values to zero.\n    full : Return a new array of given shape filled with value.\n\n\n    Notes\n    -----\n    `empty`, unlike `zeros`, does not set the array values to zero,\n    and may therefore be marginally faster.  On the other hand, it requires\n    the user to manually set all the values in the array, and should be\n    used with caution.\n\n    Examples\n    --------\n    >>> np.empty([2, 2])\n    array([[ -9.74499359e+001,   6.69583040e-309],\n           [  2.13182611e-314,   3.06959433e-309]])         #uninitialized\n\n    >>> np.empty([2, 2], dtype=int)\n    array([[-1073741821, -1067949133],\n           [  496041986,    19249760]])                     #uninitialized\n\n    "

 L. 900       372  CALL_FUNCTION_3       3  ''
              374  POP_TOP          

 L. 951       376  LOAD_NAME                add_newdoc
              378  LOAD_STR                 'numpy.core.multiarray'
              380  LOAD_STR                 'scalar'

 L. 952       382  LOAD_STR                 '\n    scalar(dtype, obj)\n\n    Return a new scalar array of the given type initialized with obj.\n\n    This function is meant mainly for pickle support. `dtype` must be a\n    valid data-type descriptor. If `dtype` corresponds to an object\n    descriptor, then `obj` can be any object, otherwise `obj` must be a\n    string. If `obj` is not given, it will be interpreted as None for object\n    type and as zeros for all other types.\n\n    '

 L. 951       384  CALL_FUNCTION_3       3  ''
              386  POP_TOP          

 L. 965       388  LOAD_NAME                add_newdoc
              390  LOAD_STR                 'numpy.core.multiarray'
              392  LOAD_STR                 'zeros'

 L. 966       394  LOAD_STR                 "\n    zeros(shape, dtype=float, order='C')\n\n    Return a new array of given shape and type, filled with zeros.\n\n    Parameters\n    ----------\n    shape : int or tuple of ints\n        Shape of the new array, e.g., ``(2, 3)`` or ``2``.\n    dtype : data-type, optional\n        The desired data-type for the array, e.g., `numpy.int8`.  Default is\n        `numpy.float64`.\n    order : {'C', 'F'}, optional, default: 'C'\n        Whether to store multi-dimensional data in row-major\n        (C-style) or column-major (Fortran-style) order in\n        memory.\n\n    Returns\n    -------\n    out : ndarray\n        Array of zeros with the given shape, dtype, and order.\n\n    See Also\n    --------\n    zeros_like : Return an array of zeros with shape and type of input.\n    empty : Return a new uninitialized array.\n    ones : Return a new array setting values to one.\n    full : Return a new array of given shape filled with value.\n\n    Examples\n    --------\n    >>> np.zeros(5)\n    array([ 0.,  0.,  0.,  0.,  0.])\n\n    >>> np.zeros((5,), dtype=int)\n    array([0, 0, 0, 0, 0])\n\n    >>> np.zeros((2, 1))\n    array([[ 0.],\n           [ 0.]])\n\n    >>> s = (2,2)\n    >>> np.zeros(s)\n    array([[ 0.,  0.],\n           [ 0.,  0.]])\n\n    >>> np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype\n    array([(0, 0), (0, 0)],\n          dtype=[('x', '<i4'), ('y', '<i4')])\n\n    "

 L. 965       396  CALL_FUNCTION_3       3  ''
              398  POP_TOP          

 L.1018       400  LOAD_NAME                add_newdoc
              402  LOAD_STR                 'numpy.core.multiarray'
              404  LOAD_STR                 'set_typeDict'

 L.1019       406  LOAD_STR                 'set_typeDict(dict)\n\n    Set the internal dictionary that can look up an array type using a\n    registered code.\n\n    '

 L.1018       408  CALL_FUNCTION_3       3  ''
              410  POP_TOP          

 L.1026       412  LOAD_NAME                add_newdoc
              414  LOAD_STR                 'numpy.core.multiarray'
              416  LOAD_STR                 'fromstring'

 L.1027       418  LOAD_STR                 "\n    fromstring(string, dtype=float, count=-1, sep='')\n\n    A new 1-D array initialized from text data in a string.\n\n    Parameters\n    ----------\n    string : str\n        A string containing the data.\n    dtype : data-type, optional\n        The data type of the array; default: float.  For binary input data,\n        the data must be in exactly this format. Most builtin numeric types are\n        supported and extension types may be supported.\n\n        .. versionadded:: 1.18.0\n            Complex dtypes.\n\n    count : int, optional\n        Read this number of `dtype` elements from the data.  If this is\n        negative (the default), the count will be determined from the\n        length of the data.\n    sep : str, optional\n        The string separating numbers in the data; extra whitespace between\n        elements is also ignored.\n\n        .. deprecated:: 1.14\n            Passing ``sep=''``, the default, is deprecated since it will\n            trigger the deprecated binary mode of this function. This mode\n            interprets `string` as binary bytes, rather than ASCII text with\n            decimal numbers, an operation which is better spelt\n            ``frombuffer(string, dtype, count)``. If `string` contains unicode\n            text, the binary mode of `fromstring` will first encode it into\n            bytes using either utf-8 (python 3) or the default encoding\n            (python 2), neither of which produce sane results.\n\n    Returns\n    -------\n    arr : ndarray\n        The constructed array.\n\n    Raises\n    ------\n    ValueError\n        If the string is not the correct size to satisfy the requested\n        `dtype` and `count`.\n\n    See Also\n    --------\n    frombuffer, fromfile, fromiter\n\n    Examples\n    --------\n    >>> np.fromstring('1 2', dtype=int, sep=' ')\n    array([1, 2])\n    >>> np.fromstring('1, 2', dtype=int, sep=',')\n    array([1, 2])\n\n    "

 L.1026       420  CALL_FUNCTION_3       3  ''
              422  POP_TOP          

 L.1086       424  LOAD_NAME                add_newdoc
              426  LOAD_STR                 'numpy.core.multiarray'
              428  LOAD_STR                 'compare_chararrays'

 L.1087       430  LOAD_STR                 '\n    compare_chararrays(a, b, cmp_op, rstrip)\n\n    Performs element-wise comparison of two string arrays using the\n    comparison operator specified by `cmp_op`.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Arrays to be compared.\n    cmp_op : {"<", "<=", "==", ">=", ">", "!="}\n        Type of comparison.\n    rstrip : Boolean\n        If True, the spaces at the end of Strings are removed before the comparison.\n\n    Returns\n    -------\n    out : ndarray\n        The output array of type Boolean with the same shape as a and b.\n\n    Raises\n    ------\n    ValueError\n        If `cmp_op` is not valid.\n    TypeError\n        If at least one of `a` or `b` is a non-string array\n\n    Examples\n    --------\n    >>> a = np.array(["a", "b", "cde"])\n    >>> b = np.array(["a", "a", "dec"])\n    >>> np.compare_chararrays(a, b, ">", True)\n    array([False,  True, False])\n\n    '

 L.1086       432  CALL_FUNCTION_3       3  ''
              434  POP_TOP          

 L.1123       436  LOAD_NAME                add_newdoc
              438  LOAD_STR                 'numpy.core.multiarray'
              440  LOAD_STR                 'fromiter'

 L.1124       442  LOAD_STR                 '\n    fromiter(iterable, dtype, count=-1)\n\n    Create a new 1-dimensional array from an iterable object.\n\n    Parameters\n    ----------\n    iterable : iterable object\n        An iterable object providing data for the array.\n    dtype : data-type\n        The data-type of the returned array.\n    count : int, optional\n        The number of items to read from *iterable*.  The default is -1,\n        which means all data is read.\n\n    Returns\n    -------\n    out : ndarray\n        The output array.\n\n    Notes\n    -----\n    Specify `count` to improve performance.  It allows ``fromiter`` to\n    pre-allocate the output array, instead of resizing it on demand.\n\n    Examples\n    --------\n    >>> iterable = (x*x for x in range(5))\n    >>> np.fromiter(iterable, float)\n    array([  0.,   1.,   4.,   9.,  16.])\n\n    '

 L.1123       444  CALL_FUNCTION_3       3  ''
              446  POP_TOP          

 L.1157       448  LOAD_NAME                add_newdoc
              450  LOAD_STR                 'numpy.core.multiarray'
              452  LOAD_STR                 'fromfile'

 L.1158       454  LOAD_STR                 '\n    fromfile(file, dtype=float, count=-1, sep=\'\', offset=0)\n\n    Construct an array from data in a text or binary file.\n\n    A highly efficient way of reading binary data with a known data-type,\n    as well as parsing simply formatted text files.  Data written using the\n    `tofile` method can be read using this function.\n\n    Parameters\n    ----------\n    file : file or str or Path\n        Open file object or filename.\n\n        .. versionchanged:: 1.17.0\n            `pathlib.Path` objects are now accepted.\n\n    dtype : data-type\n        Data type of the returned array.\n        For binary files, it is used to determine the size and byte-order\n        of the items in the file.\n        Most builtin numeric types are supported and extension types may be supported.\n\n        .. versionadded:: 1.18.0\n            Complex dtypes.\n\n    count : int\n        Number of items to read. ``-1`` means all items (i.e., the complete\n        file).\n    sep : str\n        Separator between items if file is a text file.\n        Empty ("") separator means the file should be treated as binary.\n        Spaces (" ") in the separator match zero or more whitespace characters.\n        A separator consisting only of spaces must match at least one\n        whitespace.\n    offset : int\n        The offset (in bytes) from the file\'s current position. Defaults to 0.\n        Only permitted for binary files.\n\n        .. versionadded:: 1.17.0\n\n    See also\n    --------\n    load, save\n    ndarray.tofile\n    loadtxt : More flexible way of loading data from a text file.\n\n    Notes\n    -----\n    Do not rely on the combination of `tofile` and `fromfile` for\n    data storage, as the binary files generated are not platform\n    independent.  In particular, no byte-order or data-type information is\n    saved.  Data can be stored in the platform independent ``.npy`` format\n    using `save` and `load` instead.\n\n    Examples\n    --------\n    Construct an ndarray:\n\n    >>> dt = np.dtype([(\'time\', [(\'min\', np.int64), (\'sec\', np.int64)]),\n    ...                (\'temp\', float)])\n    >>> x = np.zeros((1,), dtype=dt)\n    >>> x[\'time\'][\'min\'] = 10; x[\'temp\'] = 98.25\n    >>> x\n    array([((10, 0), 98.25)],\n          dtype=[(\'time\', [(\'min\', \'<i8\'), (\'sec\', \'<i8\')]), (\'temp\', \'<f8\')])\n\n    Save the raw data to disk:\n\n    >>> import tempfile\n    >>> fname = tempfile.mkstemp()[1]\n    >>> x.tofile(fname)\n\n    Read the raw data from disk:\n\n    >>> np.fromfile(fname, dtype=dt)\n    array([((10, 0), 98.25)],\n          dtype=[(\'time\', [(\'min\', \'<i8\'), (\'sec\', \'<i8\')]), (\'temp\', \'<f8\')])\n\n    The recommended way to store and load data:\n\n    >>> np.save(fname, x)\n    >>> np.load(fname + \'.npy\')\n    array([((10, 0), 98.25)],\n          dtype=[(\'time\', [(\'min\', \'<i8\'), (\'sec\', \'<i8\')]), (\'temp\', \'<f8\')])\n\n    '

 L.1157       456  CALL_FUNCTION_3       3  ''
              458  POP_TOP          

 L.1246       460  LOAD_NAME                add_newdoc
              462  LOAD_STR                 'numpy.core.multiarray'
              464  LOAD_STR                 'frombuffer'

 L.1247       466  LOAD_STR                 "\n    frombuffer(buffer, dtype=float, count=-1, offset=0)\n\n    Interpret a buffer as a 1-dimensional array.\n\n    Parameters\n    ----------\n    buffer : buffer_like\n        An object that exposes the buffer interface.\n    dtype : data-type, optional\n        Data-type of the returned array; default: float.\n    count : int, optional\n        Number of items to read. ``-1`` means all data in the buffer.\n    offset : int, optional\n        Start reading the buffer from this offset (in bytes); default: 0.\n\n    Notes\n    -----\n    If the buffer has data that is not in machine byte-order, this should\n    be specified as part of the data-type, e.g.::\n\n      >>> dt = np.dtype(int)\n      >>> dt = dt.newbyteorder('>')\n      >>> np.frombuffer(buf, dtype=dt) # doctest: +SKIP\n\n    The data of the resulting array will not be byteswapped, but will be\n    interpreted correctly.\n\n    Examples\n    --------\n    >>> s = b'hello world'\n    >>> np.frombuffer(s, dtype='S1', count=5, offset=6)\n    array([b'w', b'o', b'r', b'l', b'd'], dtype='|S1')\n\n    >>> np.frombuffer(b'\\x01\\x02', dtype=np.uint8)\n    array([1, 2], dtype=uint8)\n    >>> np.frombuffer(b'\\x01\\x02\\x03\\x04\\x05', dtype=np.uint8, count=3)\n    array([1, 2, 3], dtype=uint8)\n\n    "

 L.1246       468  CALL_FUNCTION_3       3  ''
              470  POP_TOP          

 L.1288       472  LOAD_NAME                add_newdoc
              474  LOAD_STR                 'numpy.core'
              476  LOAD_STR                 'fastCopyAndTranspose'

 L.1289       478  LOAD_STR                 '_fastCopyAndTranspose(a)'

 L.1288       480  CALL_FUNCTION_3       3  ''
              482  POP_TOP          

 L.1291       484  LOAD_NAME                add_newdoc
              486  LOAD_STR                 'numpy.core.multiarray'
              488  LOAD_STR                 'correlate'

 L.1292       490  LOAD_STR                 'cross_correlate(a,v, mode=0)'

 L.1291       492  CALL_FUNCTION_3       3  ''
              494  POP_TOP          

 L.1294       496  LOAD_NAME                add_newdoc
              498  LOAD_STR                 'numpy.core.multiarray'
              500  LOAD_STR                 'arange'

 L.1295       502  LOAD_STR                 '\n    arange([start,] stop[, step,], dtype=None)\n\n    Return evenly spaced values within a given interval.\n\n    Values are generated within the half-open interval ``[start, stop)``\n    (in other words, the interval including `start` but excluding `stop`).\n    For integer arguments the function is equivalent to the Python built-in\n    `range` function, but returns an ndarray rather than a list.\n\n    When using a non-integer step, such as 0.1, the results will often not\n    be consistent.  It is better to use `numpy.linspace` for these cases.\n\n    Parameters\n    ----------\n    start : number, optional\n        Start of interval.  The interval includes this value.  The default\n        start value is 0.\n    stop : number\n        End of interval.  The interval does not include this value, except\n        in some cases where `step` is not an integer and floating point\n        round-off affects the length of `out`.\n    step : number, optional\n        Spacing between values.  For any output `out`, this is the distance\n        between two adjacent values, ``out[i+1] - out[i]``.  The default\n        step size is 1.  If `step` is specified as a position argument,\n        `start` must also be given.\n    dtype : dtype\n        The type of the output array.  If `dtype` is not given, infer the data\n        type from the other input arguments.\n\n    Returns\n    -------\n    arange : ndarray\n        Array of evenly spaced values.\n\n        For floating point arguments, the length of the result is\n        ``ceil((stop - start)/step)``.  Because of floating point overflow,\n        this rule may result in the last element of `out` being greater\n        than `stop`.\n\n    See Also\n    --------\n    numpy.linspace : Evenly spaced numbers with careful handling of endpoints.\n    numpy.ogrid: Arrays of evenly spaced numbers in N-dimensions.\n    numpy.mgrid: Grid-shaped arrays of evenly spaced numbers in N-dimensions.\n\n    Examples\n    --------\n    >>> np.arange(3)\n    array([0, 1, 2])\n    >>> np.arange(3.0)\n    array([ 0.,  1.,  2.])\n    >>> np.arange(3,7)\n    array([3, 4, 5, 6])\n    >>> np.arange(3,7,2)\n    array([3, 5])\n\n    '

 L.1294       504  CALL_FUNCTION_3       3  ''
              506  POP_TOP          

 L.1355       508  LOAD_NAME                add_newdoc
              510  LOAD_STR                 'numpy.core.multiarray'
              512  LOAD_STR                 '_get_ndarray_c_version'

 L.1356       514  LOAD_STR                 '_get_ndarray_c_version()\n\n    Return the compile time NPY_VERSION (formerly called NDARRAY_VERSION) number.\n\n    '

 L.1355       516  CALL_FUNCTION_3       3  ''
              518  POP_TOP          

 L.1362       520  LOAD_NAME                add_newdoc
              522  LOAD_STR                 'numpy.core.multiarray'
              524  LOAD_STR                 '_reconstruct'

 L.1363       526  LOAD_STR                 '_reconstruct(subtype, shape, dtype)\n\n    Construct an empty array. Used by Pickles.\n\n    '

 L.1362       528  CALL_FUNCTION_3       3  ''
              530  POP_TOP          

 L.1370       532  LOAD_NAME                add_newdoc
              534  LOAD_STR                 'numpy.core.multiarray'
              536  LOAD_STR                 'set_string_function'

 L.1371       538  LOAD_STR                 '\n    set_string_function(f, repr=1)\n\n    Internal method to set a function to be used when pretty printing arrays.\n\n    '

 L.1370       540  CALL_FUNCTION_3       3  ''
              542  POP_TOP          

 L.1378       544  LOAD_NAME                add_newdoc
              546  LOAD_STR                 'numpy.core.multiarray'
              548  LOAD_STR                 'set_numeric_ops'

 L.1379       550  LOAD_STR                 '\n    set_numeric_ops(op1=func1, op2=func2, ...)\n\n    Set numerical operators for array objects.\n\n    .. deprecated:: 1.16\n\n        For the general case, use :c:func:`PyUFunc_ReplaceLoopBySignature`.\n        For ndarray subclasses, define the ``__array_ufunc__`` method and\n        override the relevant ufunc.\n\n    Parameters\n    ----------\n    op1, op2, ... : callable\n        Each ``op = func`` pair describes an operator to be replaced.\n        For example, ``add = lambda x, y: np.add(x, y) % 5`` would replace\n        addition by modulus 5 addition.\n\n    Returns\n    -------\n    saved_ops : list of callables\n        A list of all operators, stored before making replacements.\n\n    Notes\n    -----\n    .. WARNING::\n       Use with care!  Incorrect usage may lead to memory errors.\n\n    A function replacing an operator cannot make use of that operator.\n    For example, when replacing add, you may not use ``+``.  Instead,\n    directly call ufuncs.\n\n    Examples\n    --------\n    >>> def add_mod5(x, y):\n    ...     return np.add(x, y) % 5\n    ...\n    >>> old_funcs = np.set_numeric_ops(add=add_mod5)\n\n    >>> x = np.arange(12).reshape((3, 4))\n    >>> x + x\n    array([[0, 2, 4, 1],\n           [3, 0, 2, 4],\n           [1, 3, 0, 2]])\n\n    >>> ignore = np.set_numeric_ops(**old_funcs) # restore operators\n\n    '

 L.1378       552  CALL_FUNCTION_3       3  ''
              554  POP_TOP          

 L.1428       556  LOAD_NAME                add_newdoc
              558  LOAD_STR                 'numpy.core.multiarray'
              560  LOAD_STR                 'promote_types'

 L.1429       562  LOAD_STR                 "\n    promote_types(type1, type2)\n\n    Returns the data type with the smallest size and smallest scalar\n    kind to which both ``type1`` and ``type2`` may be safely cast.\n    The returned data type is always in native byte order.\n\n    This function is symmetric, but rarely associative.\n\n    Parameters\n    ----------\n    type1 : dtype or dtype specifier\n        First data type.\n    type2 : dtype or dtype specifier\n        Second data type.\n\n    Returns\n    -------\n    out : dtype\n        The promoted data type.\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    Starting in NumPy 1.9, promote_types function now returns a valid string\n    length when given an integer or float dtype as one argument and a string\n    dtype as another argument. Previously it always returned the input string\n    dtype, even if it wasn't long enough to store the max integer/float value\n    converted to a string.\n\n    See Also\n    --------\n    result_type, dtype, can_cast\n\n    Examples\n    --------\n    >>> np.promote_types('f4', 'f8')\n    dtype('float64')\n\n    >>> np.promote_types('i8', 'f4')\n    dtype('float64')\n\n    >>> np.promote_types('>i8', '<c8')\n    dtype('complex128')\n\n    >>> np.promote_types('i4', 'S8')\n    dtype('S11')\n\n    An example of a non-associative case:\n\n    >>> p = np.promote_types\n    >>> p('S', p('i1', 'u1'))\n    dtype('S6')\n    >>> p(p('S', 'i1'), 'u1')\n    dtype('S4')\n\n    "

 L.1428       564  CALL_FUNCTION_3       3  ''
              566  POP_TOP          

 L.1488       568  LOAD_NAME                add_newdoc
              570  LOAD_STR                 'numpy.core.multiarray'
              572  LOAD_STR                 'c_einsum'

 L.1489       574  LOAD_STR                 "\n    c_einsum(subscripts, *operands, out=None, dtype=None, order='K',\n           casting='safe')\n\n    *This documentation shadows that of the native python implementation of the `einsum` function,\n    except all references and examples related to the `optimize` argument (v 0.12.0) have been removed.*\n\n    Evaluates the Einstein summation convention on the operands.\n\n    Using the Einstein summation convention, many common multi-dimensional,\n    linear algebraic array operations can be represented in a simple fashion.\n    In *implicit* mode `einsum` computes these values.\n\n    In *explicit* mode, `einsum` provides further flexibility to compute\n    other array operations that might not be considered classical Einstein\n    summation operations, by disabling, or forcing summation over specified\n    subscript labels.\n\n    See the notes and examples for clarification.\n\n    Parameters\n    ----------\n    subscripts : str\n        Specifies the subscripts for summation as comma separated list of\n        subscript labels. An implicit (classical Einstein summation)\n        calculation is performed unless the explicit indicator '->' is\n        included as well as subscript labels of the precise output form.\n    operands : list of array_like\n        These are the arrays for the operation.\n    out : ndarray, optional\n        If provided, the calculation is done into this array.\n    dtype : {data-type, None}, optional\n        If provided, forces the calculation to use the data type specified.\n        Note that you may have to also give a more liberal `casting`\n        parameter to allow the conversions. Default is None.\n    order : {'C', 'F', 'A', 'K'}, optional\n        Controls the memory layout of the output. 'C' means it should\n        be C contiguous. 'F' means it should be Fortran contiguous,\n        'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise.\n        'K' means it should be as close to the layout as the inputs as\n        is possible, including arbitrarily permuted axes.\n        Default is 'K'.\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur.  Setting this to\n        'unsafe' is not recommended, as it can adversely affect accumulations.\n\n          * 'no' means the data types should not be cast at all.\n          * 'equiv' means only byte-order changes are allowed.\n          * 'safe' means only casts which can preserve values are allowed.\n          * 'same_kind' means only safe casts or casts within a kind,\n            like float64 to float32, are allowed.\n          * 'unsafe' means any data conversions may be done.\n\n        Default is 'safe'.\n    optimize : {False, True, 'greedy', 'optimal'}, optional\n        Controls if intermediate optimization should occur. No optimization\n        will occur if False and True will default to the 'greedy' algorithm.\n        Also accepts an explicit contraction list from the ``np.einsum_path``\n        function. See ``np.einsum_path`` for more details. Defaults to False.\n\n    Returns\n    -------\n    output : ndarray\n        The calculation based on the Einstein summation convention.\n\n    See Also\n    --------\n    einsum_path, dot, inner, outer, tensordot, linalg.multi_dot\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    The Einstein summation convention can be used to compute\n    many multi-dimensional, linear algebraic array operations. `einsum`\n    provides a succinct way of representing these.\n\n    A non-exhaustive list of these operations,\n    which can be computed by `einsum`, is shown below along with examples:\n\n    * Trace of an array, :py:func:`numpy.trace`.\n    * Return a diagonal, :py:func:`numpy.diag`.\n    * Array axis summations, :py:func:`numpy.sum`.\n    * Transpositions and permutations, :py:func:`numpy.transpose`.\n    * Matrix multiplication and dot product, :py:func:`numpy.matmul` :py:func:`numpy.dot`.\n    * Vector inner and outer products, :py:func:`numpy.inner` :py:func:`numpy.outer`.\n    * Broadcasting, element-wise and scalar multiplication, :py:func:`numpy.multiply`.\n    * Tensor contractions, :py:func:`numpy.tensordot`.\n    * Chained array operations, in efficient calculation order, :py:func:`numpy.einsum_path`.\n\n    The subscripts string is a comma-separated list of subscript labels,\n    where each label refers to a dimension of the corresponding operand.\n    Whenever a label is repeated it is summed, so ``np.einsum('i,i', a, b)``\n    is equivalent to :py:func:`np.inner(a,b) <numpy.inner>`. If a label\n    appears only once, it is not summed, so ``np.einsum('i', a)`` produces a\n    view of ``a`` with no changes. A further example ``np.einsum('ij,jk', a, b)``\n    describes traditional matrix multiplication and is equivalent to\n    :py:func:`np.matmul(a,b) <numpy.matmul>`. Repeated subscript labels in one\n    operand take the diagonal. For example, ``np.einsum('ii', a)`` is equivalent\n    to :py:func:`np.trace(a) <numpy.trace>`.\n\n    In *implicit mode*, the chosen subscripts are important\n    since the axes of the output are reordered alphabetically.  This\n    means that ``np.einsum('ij', a)`` doesn't affect a 2D array, while\n    ``np.einsum('ji', a)`` takes its transpose. Additionally,\n    ``np.einsum('ij,jk', a, b)`` returns a matrix multiplication, while,\n    ``np.einsum('ij,jh', a, b)`` returns the transpose of the\n    multiplication since subscript 'h' precedes subscript 'i'.\n\n    In *explicit mode* the output can be directly controlled by\n    specifying output subscript labels.  This requires the\n    identifier '->' as well as the list of output subscript labels.\n    This feature increases the flexibility of the function since\n    summing can be disabled or forced when required. The call\n    ``np.einsum('i->', a)`` is like :py:func:`np.sum(a, axis=-1) <numpy.sum>`,\n    and ``np.einsum('ii->i', a)`` is like :py:func:`np.diag(a) <numpy.diag>`.\n    The difference is that `einsum` does not allow broadcasting by default.\n    Additionally ``np.einsum('ij,jh->ih', a, b)`` directly specifies the\n    order of the output subscript labels and therefore returns matrix\n    multiplication, unlike the example above in implicit mode.\n\n    To enable and control broadcasting, use an ellipsis.  Default\n    NumPy-style broadcasting is done by adding an ellipsis\n    to the left of each term, like ``np.einsum('...ii->...i', a)``.\n    To take the trace along the first and last axes,\n    you can do ``np.einsum('i...i', a)``, or to do a matrix-matrix\n    product with the left-most indices instead of rightmost, one can do\n    ``np.einsum('ij...,jk...->ik...', a, b)``.\n\n    When there is only one operand, no axes are summed, and no output\n    parameter is provided, a view into the operand is returned instead\n    of a new array.  Thus, taking the diagonal as ``np.einsum('ii->i', a)``\n    produces a view (changed in version 1.10.0).\n\n    `einsum` also provides an alternative way to provide the subscripts\n    and operands as ``einsum(op0, sublist0, op1, sublist1, ..., [sublistout])``.\n    If the output shape is not provided in this format `einsum` will be\n    calculated in implicit mode, otherwise it will be performed explicitly.\n    The examples below have corresponding `einsum` calls with the two\n    parameter methods.\n\n    .. versionadded:: 1.10.0\n\n    Views returned from einsum are now writeable whenever the input array\n    is writeable. For example, ``np.einsum('ijk...->kji...', a)`` will now\n    have the same effect as :py:func:`np.swapaxes(a, 0, 2) <numpy.swapaxes>`\n    and ``np.einsum('ii->i', a)`` will return a writeable view of the diagonal\n    of a 2D array.\n\n    Examples\n    --------\n    >>> a = np.arange(25).reshape(5,5)\n    >>> b = np.arange(5)\n    >>> c = np.arange(6).reshape(2,3)\n\n    Trace of a matrix:\n\n    >>> np.einsum('ii', a)\n    60\n    >>> np.einsum(a, [0,0])\n    60\n    >>> np.trace(a)\n    60\n\n    Extract the diagonal (requires explicit form):\n\n    >>> np.einsum('ii->i', a)\n    array([ 0,  6, 12, 18, 24])\n    >>> np.einsum(a, [0,0], [0])\n    array([ 0,  6, 12, 18, 24])\n    >>> np.diag(a)\n    array([ 0,  6, 12, 18, 24])\n\n    Sum over an axis (requires explicit form):\n\n    >>> np.einsum('ij->i', a)\n    array([ 10,  35,  60,  85, 110])\n    >>> np.einsum(a, [0,1], [0])\n    array([ 10,  35,  60,  85, 110])\n    >>> np.sum(a, axis=1)\n    array([ 10,  35,  60,  85, 110])\n\n    For higher dimensional arrays summing a single axis can be done with ellipsis:\n\n    >>> np.einsum('...j->...', a)\n    array([ 10,  35,  60,  85, 110])\n    >>> np.einsum(a, [Ellipsis,1], [Ellipsis])\n    array([ 10,  35,  60,  85, 110])\n\n    Compute a matrix transpose, or reorder any number of axes:\n\n    >>> np.einsum('ji', c)\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n    >>> np.einsum('ij->ji', c)\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n    >>> np.einsum(c, [1,0])\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n    >>> np.transpose(c)\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n\n    Vector inner products:\n\n    >>> np.einsum('i,i', b, b)\n    30\n    >>> np.einsum(b, [0], b, [0])\n    30\n    >>> np.inner(b,b)\n    30\n\n    Matrix vector multiplication:\n\n    >>> np.einsum('ij,j', a, b)\n    array([ 30,  80, 130, 180, 230])\n    >>> np.einsum(a, [0,1], b, [1])\n    array([ 30,  80, 130, 180, 230])\n    >>> np.dot(a, b)\n    array([ 30,  80, 130, 180, 230])\n    >>> np.einsum('...j,j', a, b)\n    array([ 30,  80, 130, 180, 230])\n\n    Broadcasting and scalar multiplication:\n\n    >>> np.einsum('..., ...', 3, c)\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n    >>> np.einsum(',ij', 3, c)\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n    >>> np.einsum(3, [Ellipsis], c, [Ellipsis])\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n    >>> np.multiply(3, c)\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n\n    Vector outer product:\n\n    >>> np.einsum('i,j', np.arange(2)+1, b)\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n    >>> np.einsum(np.arange(2)+1, [0], b, [1])\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n    >>> np.outer(np.arange(2)+1, b)\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n\n    Tensor contraction:\n\n    >>> a = np.arange(60.).reshape(3,4,5)\n    >>> b = np.arange(24.).reshape(4,3,2)\n    >>> np.einsum('ijk,jil->kl', a, b)\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    >>> np.einsum(a, [0,1,2], b, [1,0,3], [2,3])\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    >>> np.tensordot(a,b, axes=([1,0],[0,1]))\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n\n    Writeable returned arrays (since version 1.10.0):\n\n    >>> a = np.zeros((3, 3))\n    >>> np.einsum('ii->i', a)[:] = 1\n    >>> a\n    array([[ 1.,  0.,  0.],\n           [ 0.,  1.,  0.],\n           [ 0.,  0.,  1.]])\n\n    Example of ellipsis use:\n\n    >>> a = np.arange(6).reshape((3,2))\n    >>> b = np.arange(12).reshape((4,3))\n    >>> np.einsum('ki,jk->ij', a, b)\n    array([[10, 28, 46, 64],\n           [13, 40, 67, 94]])\n    >>> np.einsum('ki,...k->i...', a, b)\n    array([[10, 28, 46, 64],\n           [13, 40, 67, 94]])\n    >>> np.einsum('k...,jk', a, b)\n    array([[10, 28, 46, 64],\n           [13, 40, 67, 94]])\n\n    "

 L.1488       576  CALL_FUNCTION_3       3  ''
              578  POP_TOP          

 L.1807       580  LOAD_NAME                add_newdoc
              582  LOAD_STR                 'numpy.core.multiarray'
              584  LOAD_STR                 'ndarray'

 L.1808       586  LOAD_STR                 '\n    ndarray(shape, dtype=float, buffer=None, offset=0,\n            strides=None, order=None)\n\n    An array object represents a multidimensional, homogeneous array\n    of fixed-size items.  An associated data-type object describes the\n    format of each element in the array (its byte-order, how many bytes it\n    occupies in memory, whether it is an integer, a floating point number,\n    or something else, etc.)\n\n    Arrays should be constructed using `array`, `zeros` or `empty` (refer\n    to the See Also section below).  The parameters given here refer to\n    a low-level method (`ndarray(...)`) for instantiating an array.\n\n    For more information, refer to the `numpy` module and examine the\n    methods and attributes of an array.\n\n    Parameters\n    ----------\n    (for the __new__ method; see Notes below)\n\n    shape : tuple of ints\n        Shape of created array.\n    dtype : data-type, optional\n        Any object that can be interpreted as a numpy data type.\n    buffer : object exposing buffer interface, optional\n        Used to fill the array with data.\n    offset : int, optional\n        Offset of array data in buffer.\n    strides : tuple of ints, optional\n        Strides of data in memory.\n    order : {\'C\', \'F\'}, optional\n        Row-major (C-style) or column-major (Fortran-style) order.\n\n    Attributes\n    ----------\n    T : ndarray\n        Transpose of the array.\n    data : buffer\n        The array\'s elements, in memory.\n    dtype : dtype object\n        Describes the format of the elements in the array.\n    flags : dict\n        Dictionary containing information related to memory use, e.g.,\n        \'C_CONTIGUOUS\', \'OWNDATA\', \'WRITEABLE\', etc.\n    flat : numpy.flatiter object\n        Flattened version of the array as an iterator.  The iterator\n        allows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for\n        assignment examples; TODO).\n    imag : ndarray\n        Imaginary part of the array.\n    real : ndarray\n        Real part of the array.\n    size : int\n        Number of elements in the array.\n    itemsize : int\n        The memory use of each array element in bytes.\n    nbytes : int\n        The total number of bytes required to store the array data,\n        i.e., ``itemsize * size``.\n    ndim : int\n        The array\'s number of dimensions.\n    shape : tuple of ints\n        Shape of the array.\n    strides : tuple of ints\n        The step-size required to move from one element to the next in\n        memory. For example, a contiguous ``(3, 4)`` array of type\n        ``int16`` in C-order has strides ``(8, 2)``.  This implies that\n        to move from element to element in memory requires jumps of 2 bytes.\n        To move from row-to-row, one needs to jump 8 bytes at a time\n        (``2 * 4``).\n    ctypes : ctypes object\n        Class containing properties of the array needed for interaction\n        with ctypes.\n    base : ndarray\n        If the array is a view into another array, that array is its `base`\n        (unless that array is also a view).  The `base` array is where the\n        array data is actually stored.\n\n    See Also\n    --------\n    array : Construct an array.\n    zeros : Create an array, each element of which is zero.\n    empty : Create an array, but leave its allocated memory unchanged (i.e.,\n            it contains "garbage").\n    dtype : Create a data-type.\n\n    Notes\n    -----\n    There are two modes of creating an array using ``__new__``:\n\n    1. If `buffer` is None, then only `shape`, `dtype`, and `order`\n       are used.\n    2. If `buffer` is an object exposing the buffer interface, then\n       all keywords are interpreted.\n\n    No ``__init__`` method is needed because the array is fully initialized\n    after the ``__new__`` method.\n\n    Examples\n    --------\n    These examples illustrate the low-level `ndarray` constructor.  Refer\n    to the `See Also` section above for easier ways of constructing an\n    ndarray.\n\n    First mode, `buffer` is None:\n\n    >>> np.ndarray(shape=(2,2), dtype=float, order=\'F\')\n    array([[0.0e+000, 0.0e+000], # random\n           [     nan, 2.5e-323]])\n\n    Second mode:\n\n    >>> np.ndarray((2,), buffer=np.array([1,2,3]),\n    ...            offset=np.int_().itemsize,\n    ...            dtype=int) # offset = 1*itemsize, i.e. skip first element\n    array([2, 3])\n\n    '

 L.1807       588  CALL_FUNCTION_3       3  ''
              590  POP_TOP          

 L.1936       592  LOAD_NAME                add_newdoc
              594  LOAD_STR                 'numpy.core.multiarray'
              596  LOAD_STR                 'ndarray'
              598  LOAD_CONST               ('__array_interface__', 'Array protocol: Python side.')
              600  CALL_FUNCTION_3       3  ''
              602  POP_TOP          

 L.1940       604  LOAD_NAME                add_newdoc
              606  LOAD_STR                 'numpy.core.multiarray'
              608  LOAD_STR                 'ndarray'
              610  LOAD_CONST               ('__array_finalize__', 'None.')
              612  CALL_FUNCTION_3       3  ''
              614  POP_TOP          

 L.1944       616  LOAD_NAME                add_newdoc
              618  LOAD_STR                 'numpy.core.multiarray'
              620  LOAD_STR                 'ndarray'
              622  LOAD_CONST               ('__array_priority__', 'Array priority.')
              624  CALL_FUNCTION_3       3  ''
              626  POP_TOP          

 L.1948       628  LOAD_NAME                add_newdoc
              630  LOAD_STR                 'numpy.core.multiarray'
              632  LOAD_STR                 'ndarray'
              634  LOAD_CONST               ('__array_struct__', 'Array protocol: C-struct side.')
              636  CALL_FUNCTION_3       3  ''
              638  POP_TOP          

 L.1952       640  LOAD_NAME                add_newdoc
              642  LOAD_STR                 'numpy.core.multiarray'
              644  LOAD_STR                 'ndarray'
              646  LOAD_CONST               ('base', '\n    Base object if memory is from some other object.\n\n    Examples\n    --------\n    The base of an array that owns its memory is None:\n\n    >>> x = np.array([1,2,3,4])\n    >>> x.base is None\n    True\n\n    Slicing creates a view, whose memory is shared with x:\n\n    >>> y = x[2:]\n    >>> y.base is x\n    True\n\n    ')
              648  CALL_FUNCTION_3       3  ''
              650  POP_TOP          

 L.1973       652  LOAD_NAME                add_newdoc
              654  LOAD_STR                 'numpy.core.multiarray'
              656  LOAD_STR                 'ndarray'
              658  LOAD_CONST               ('ctypes', '\n    An object to simplify the interaction of the array with the ctypes\n    module.\n\n    This attribute creates an object that makes it easier to use arrays\n    when calling shared libraries with the ctypes module. The returned\n    object has, among others, data, shape, and strides attributes (see\n    Notes below) which themselves return ctypes objects that can be used\n    as arguments to a shared library.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    c : Python object\n        Possessing attributes data, shape, strides, etc.\n\n    See Also\n    --------\n    numpy.ctypeslib\n\n    Notes\n    -----\n    Below are the public attributes of this object which were documented\n    in "Guide to NumPy" (we have omitted undocumented public attributes,\n    as well as documented private attributes):\n\n    .. autoattribute:: numpy.core._internal._ctypes.data\n        :noindex:\n\n    .. autoattribute:: numpy.core._internal._ctypes.shape\n        :noindex:\n\n    .. autoattribute:: numpy.core._internal._ctypes.strides\n        :noindex:\n\n    .. automethod:: numpy.core._internal._ctypes.data_as\n        :noindex:\n\n    .. automethod:: numpy.core._internal._ctypes.shape_as\n        :noindex:\n\n    .. automethod:: numpy.core._internal._ctypes.strides_as\n        :noindex:\n\n    If the ctypes module is not available, then the ctypes attribute\n    of array objects still returns something useful, but ctypes objects\n    are not returned and errors may be raised instead. In particular,\n    the object will still have the ``as_parameter`` attribute which will\n    return an integer equal to the data attribute.\n\n    Examples\n    --------\n    >>> import ctypes\n    >>> x = np.array([[0, 1], [2, 3]], dtype=np.int32)\n    >>> x\n    array([[0, 1],\n           [2, 3]], dtype=int32)\n    >>> x.ctypes.data\n    31962608 # may vary\n    >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_uint32))\n    <__main__.LP_c_uint object at 0x7ff2fc1fc200> # may vary\n    >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_uint32)).contents\n    c_uint(0)\n    >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_uint64)).contents\n    c_ulong(4294967296)\n    >>> x.ctypes.shape\n    <numpy.core._internal.c_long_Array_2 object at 0x7ff2fc1fce60> # may vary\n    >>> x.ctypes.strides\n    <numpy.core._internal.c_long_Array_2 object at 0x7ff2fc1ff320> # may vary\n\n    ')
              660  CALL_FUNCTION_3       3  ''
              662  POP_TOP          

 L.2050       664  LOAD_NAME                add_newdoc
              666  LOAD_STR                 'numpy.core.multiarray'
              668  LOAD_STR                 'ndarray'
              670  LOAD_CONST               ('data', "Python buffer object pointing to the start of the array's data.")
              672  CALL_FUNCTION_3       3  ''
              674  POP_TOP          

 L.2054       676  LOAD_NAME                add_newdoc
              678  LOAD_STR                 'numpy.core.multiarray'
              680  LOAD_STR                 'ndarray'
              682  LOAD_CONST               ('dtype', "\n    Data-type of the array's elements.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    d : numpy dtype object\n\n    See Also\n    --------\n    numpy.dtype\n\n    Examples\n    --------\n    >>> x\n    array([[0, 1],\n           [2, 3]])\n    >>> x.dtype\n    dtype('int32')\n    >>> type(x.dtype)\n    <type 'numpy.dtype'>\n\n    ")
              684  CALL_FUNCTION_3       3  ''
              686  POP_TOP          

 L.2083       688  LOAD_NAME                add_newdoc
              690  LOAD_STR                 'numpy.core.multiarray'
              692  LOAD_STR                 'ndarray'
              694  LOAD_CONST               ('imag', "\n    The imaginary part of the array.\n\n    Examples\n    --------\n    >>> x = np.sqrt([1+0j, 0+1j])\n    >>> x.imag\n    array([ 0.        ,  0.70710678])\n    >>> x.imag.dtype\n    dtype('float64')\n\n    ")
              696  CALL_FUNCTION_3       3  ''
              698  POP_TOP          

 L.2098       700  LOAD_NAME                add_newdoc
              702  LOAD_STR                 'numpy.core.multiarray'
              704  LOAD_STR                 'ndarray'
              706  LOAD_CONST               ('itemsize', '\n    Length of one array element in bytes.\n\n    Examples\n    --------\n    >>> x = np.array([1,2,3], dtype=np.float64)\n    >>> x.itemsize\n    8\n    >>> x = np.array([1,2,3], dtype=np.complex128)\n    >>> x.itemsize\n    16\n\n    ')
              708  CALL_FUNCTION_3       3  ''
              710  POP_TOP          

 L.2114       712  LOAD_NAME                add_newdoc
              714  LOAD_STR                 'numpy.core.multiarray'
              716  LOAD_STR                 'ndarray'
              718  LOAD_CONST               ('flags', "\n    Information about the memory layout of the array.\n\n    Attributes\n    ----------\n    C_CONTIGUOUS (C)\n        The data is in a single, C-style contiguous segment.\n    F_CONTIGUOUS (F)\n        The data is in a single, Fortran-style contiguous segment.\n    OWNDATA (O)\n        The array owns the memory it uses or borrows it from another object.\n    WRITEABLE (W)\n        The data area can be written to.  Setting this to False locks\n        the data, making it read-only.  A view (slice, etc.) inherits WRITEABLE\n        from its base array at creation time, but a view of a writeable\n        array may be subsequently locked while the base array remains writeable.\n        (The opposite is not true, in that a view of a locked array may not\n        be made writeable.  However, currently, locking a base object does not\n        lock any views that already reference it, so under that circumstance it\n        is possible to alter the contents of a locked array via a previously\n        created writeable view onto it.)  Attempting to change a non-writeable\n        array raises a RuntimeError exception.\n    ALIGNED (A)\n        The data and all elements are aligned appropriately for the hardware.\n    WRITEBACKIFCOPY (X)\n        This array is a copy of some other array. The C-API function\n        PyArray_ResolveWritebackIfCopy must be called before deallocating\n        to the base array will be updated with the contents of this array.\n    UPDATEIFCOPY (U)\n        (Deprecated, use WRITEBACKIFCOPY) This array is a copy of some other array.\n        When this array is\n        deallocated, the base array will be updated with the contents of\n        this array.\n    FNC\n        F_CONTIGUOUS and not C_CONTIGUOUS.\n    FORC\n        F_CONTIGUOUS or C_CONTIGUOUS (one-segment test).\n    BEHAVED (B)\n        ALIGNED and WRITEABLE.\n    CARRAY (CA)\n        BEHAVED and C_CONTIGUOUS.\n    FARRAY (FA)\n        BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.\n\n    Notes\n    -----\n    The `flags` object can be accessed dictionary-like (as in ``a.flags['WRITEABLE']``),\n    or by using lowercased attribute names (as in ``a.flags.writeable``). Short flag\n    names are only supported in dictionary access.\n\n    Only the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be\n    changed by the user, via direct assignment to the attribute or dictionary\n    entry, or by calling `ndarray.setflags`.\n\n    The array flags cannot be set arbitrarily:\n\n    - UPDATEIFCOPY can only be set ``False``.\n    - WRITEBACKIFCOPY can only be set ``False``.\n    - ALIGNED can only be set ``True`` if the data is truly aligned.\n    - WRITEABLE can only be set ``True`` if the array owns its own memory\n      or the ultimate owner of the memory exposes a writeable buffer\n      interface or is a string.\n\n    Arrays can be both C-style and Fortran-style contiguous simultaneously.\n    This is clear for 1-dimensional arrays, but can also be true for higher\n    dimensional arrays.\n\n    Even for contiguous arrays a stride for a given dimension\n    ``arr.strides[dim]`` may be *arbitrary* if ``arr.shape[dim] == 1``\n    or the array has no elements.\n    It does *not* generally hold that ``self.strides[-1] == self.itemsize``\n    for C-style contiguous arrays or ``self.strides[0] == self.itemsize`` for\n    Fortran-style contiguous arrays is true.\n    ")
              720  CALL_FUNCTION_3       3  ''
              722  POP_TOP          

 L.2191       724  LOAD_NAME                add_newdoc
              726  LOAD_STR                 'numpy.core.multiarray'
              728  LOAD_STR                 'ndarray'
              730  LOAD_CONST               ('flat', "\n    A 1-D iterator over the array.\n\n    This is a `numpy.flatiter` instance, which acts similarly to, but is not\n    a subclass of, Python's built-in iterator object.\n\n    See Also\n    --------\n    flatten : Return a copy of the array collapsed into one dimension.\n\n    flatiter\n\n    Examples\n    --------\n    >>> x = np.arange(1, 7).reshape(2, 3)\n    >>> x\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> x.flat[3]\n    4\n    >>> x.T\n    array([[1, 4],\n           [2, 5],\n           [3, 6]])\n    >>> x.T.flat[3]\n    5\n    >>> type(x.flat)\n    <class 'numpy.flatiter'>\n\n    An assignment example:\n\n    >>> x.flat = 3; x\n    array([[3, 3, 3],\n           [3, 3, 3]])\n    >>> x.flat[[1,4]] = 1; x\n    array([[3, 1, 3],\n           [3, 1, 3]])\n\n    ")
              732  CALL_FUNCTION_3       3  ''
              734  POP_TOP          

 L.2233       736  LOAD_NAME                add_newdoc
              738  LOAD_STR                 'numpy.core.multiarray'
              740  LOAD_STR                 'ndarray'
              742  LOAD_CONST               ('nbytes', '\n    Total bytes consumed by the elements of the array.\n\n    Notes\n    -----\n    Does not include memory consumed by non-element attributes of the\n    array object.\n\n    Examples\n    --------\n    >>> x = np.zeros((3,5,2), dtype=np.complex128)\n    >>> x.nbytes\n    480\n    >>> np.prod(x.shape) * x.itemsize\n    480\n\n    ')
              744  CALL_FUNCTION_3       3  ''
              746  POP_TOP          

 L.2253       748  LOAD_NAME                add_newdoc
              750  LOAD_STR                 'numpy.core.multiarray'
              752  LOAD_STR                 'ndarray'
              754  LOAD_CONST               ('ndim', '\n    Number of array dimensions.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 3])\n    >>> x.ndim\n    1\n    >>> y = np.zeros((2, 3, 4))\n    >>> y.ndim\n    3\n\n    ')
              756  CALL_FUNCTION_3       3  ''
              758  POP_TOP          

 L.2269       760  LOAD_NAME                add_newdoc
              762  LOAD_STR                 'numpy.core.multiarray'
              764  LOAD_STR                 'ndarray'
              766  LOAD_CONST               ('real', "\n    The real part of the array.\n\n    Examples\n    --------\n    >>> x = np.sqrt([1+0j, 0+1j])\n    >>> x.real\n    array([ 1.        ,  0.70710678])\n    >>> x.real.dtype\n    dtype('float64')\n\n    See Also\n    --------\n    numpy.real : equivalent function\n\n    ")
              768  CALL_FUNCTION_3       3  ''
              770  POP_TOP          

 L.2288       772  LOAD_NAME                add_newdoc
              774  LOAD_STR                 'numpy.core.multiarray'
              776  LOAD_STR                 'ndarray'
              778  LOAD_CONST               ('shape', '\n    Tuple of array dimensions.\n\n    The shape property is usually used to get the current shape of an array,\n    but may also be used to reshape the array in-place by assigning a tuple of\n    array dimensions to it.  As with `numpy.reshape`, one of the new shape\n    dimensions can be -1, in which case its value is inferred from the size of\n    the array and the remaining dimensions. Reshaping an array in-place will\n    fail if a copy is required.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 3, 4])\n    >>> x.shape\n    (4,)\n    >>> y = np.zeros((2, 3, 4))\n    >>> y.shape\n    (2, 3, 4)\n    >>> y.shape = (3, 8)\n    >>> y\n    array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n           [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n           [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n    >>> y.shape = (3, 6)\n    Traceback (most recent call last):\n      File "<stdin>", line 1, in <module>\n    ValueError: total size of new array must be unchanged\n    >>> np.zeros((4,2))[::2].shape = (-1,)\n    Traceback (most recent call last):\n      File "<stdin>", line 1, in <module>\n    AttributeError: Incompatible shape for in-place modification. Use\n    `.reshape()` to make a copy with the desired shape.\n\n    See Also\n    --------\n    numpy.reshape : similar function\n    ndarray.reshape : similar method\n\n    ')
              780  CALL_FUNCTION_3       3  ''
              782  POP_TOP          

 L.2330       784  LOAD_NAME                add_newdoc
              786  LOAD_STR                 'numpy.core.multiarray'
              788  LOAD_STR                 'ndarray'
              790  LOAD_CONST               ('size', "\n    Number of elements in the array.\n\n    Equal to ``np.prod(a.shape)``, i.e., the product of the array's\n    dimensions.\n\n    Notes\n    -----\n    `a.size` returns a standard arbitrary precision Python integer. This\n    may not be the case with other methods of obtaining the same value\n    (like the suggested ``np.prod(a.shape)``, which returns an instance\n    of ``np.int_``), and may be relevant if the value is used further in\n    calculations that may overflow a fixed size integer type.\n\n    Examples\n    --------\n    >>> x = np.zeros((3, 5, 2), dtype=np.complex128)\n    >>> x.size\n    30\n    >>> np.prod(x.shape)\n    30\n\n    ")
              792  CALL_FUNCTION_3       3  ''
              794  POP_TOP          

 L.2356       796  LOAD_NAME                add_newdoc
              798  LOAD_STR                 'numpy.core.multiarray'
              800  LOAD_STR                 'ndarray'
              802  LOAD_CONST               ('strides', '\n    Tuple of bytes to step in each dimension when traversing an array.\n\n    The byte offset of element ``(i[0], i[1], ..., i[n])`` in an array `a`\n    is::\n\n        offset = sum(np.array(i) * a.strides)\n\n    A more detailed explanation of strides can be found in the\n    "ndarray.rst" file in the NumPy reference guide.\n\n    Notes\n    -----\n    Imagine an array of 32-bit integers (each 4 bytes)::\n\n      x = np.array([[0, 1, 2, 3, 4],\n                    [5, 6, 7, 8, 9]], dtype=np.int32)\n\n    This array is stored in memory as 40 bytes, one after the other\n    (known as a contiguous block of memory).  The strides of an array tell\n    us how many bytes we have to skip in memory to move to the next position\n    along a certain axis.  For example, we have to skip 4 bytes (1 value) to\n    move to the next column, but 20 bytes (5 values) to get to the same\n    position in the next row.  As such, the strides for the array `x` will be\n    ``(20, 4)``.\n\n    See Also\n    --------\n    numpy.lib.stride_tricks.as_strided\n\n    Examples\n    --------\n    >>> y = np.reshape(np.arange(2*3*4), (2,3,4))\n    >>> y\n    array([[[ 0,  1,  2,  3],\n            [ 4,  5,  6,  7],\n            [ 8,  9, 10, 11]],\n           [[12, 13, 14, 15],\n            [16, 17, 18, 19],\n            [20, 21, 22, 23]]])\n    >>> y.strides\n    (48, 16, 4)\n    >>> y[1,1,1]\n    17\n    >>> offset=sum(y.strides * np.array((1,1,1)))\n    >>> offset/y.itemsize\n    17\n\n    >>> x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n    >>> x.strides\n    (32, 4, 224, 1344)\n    >>> i = np.array([3,5,2,2])\n    >>> offset = sum(i * x.strides)\n    >>> x[3,5,2,2]\n    813\n    >>> offset / x.itemsize\n    813\n\n    ')
              804  CALL_FUNCTION_3       3  ''
              806  POP_TOP          

 L.2418       808  LOAD_NAME                add_newdoc
              810  LOAD_STR                 'numpy.core.multiarray'
              812  LOAD_STR                 'ndarray'
              814  LOAD_CONST               ('T', '\n    The transposed array.\n\n    Same as ``self.transpose()``.\n\n    Examples\n    --------\n    >>> x = np.array([[1.,2.],[3.,4.]])\n    >>> x\n    array([[ 1.,  2.],\n           [ 3.,  4.]])\n    >>> x.T\n    array([[ 1.,  3.],\n           [ 2.,  4.]])\n    >>> x = np.array([1.,2.,3.,4.])\n    >>> x\n    array([ 1.,  2.,  3.,  4.])\n    >>> x.T\n    array([ 1.,  2.,  3.,  4.])\n\n    See Also\n    --------\n    transpose\n\n    ')
              816  CALL_FUNCTION_3       3  ''
              818  POP_TOP          

 L.2453       820  LOAD_NAME                add_newdoc
              822  LOAD_STR                 'numpy.core.multiarray'
              824  LOAD_STR                 'ndarray'
              826  LOAD_CONST               ('__array__', ' a.__array__([dtype], /) -> reference if type unchanged, copy otherwise.\n\n    Returns either a new reference to self if dtype is not given or a new array\n    of provided data type if dtype is different from the current dtype of the\n    array.\n\n    ')
              828  CALL_FUNCTION_3       3  ''
              830  POP_TOP          

 L.2463       832  LOAD_NAME                add_newdoc
              834  LOAD_STR                 'numpy.core.multiarray'
              836  LOAD_STR                 'ndarray'
              838  LOAD_CONST               ('__array_prepare__', 'a.__array_prepare__(obj) -> Object of same type as ndarray object obj.\n\n    ')
              840  CALL_FUNCTION_3       3  ''
              842  POP_TOP          

 L.2469       844  LOAD_NAME                add_newdoc
              846  LOAD_STR                 'numpy.core.multiarray'
              848  LOAD_STR                 'ndarray'
              850  LOAD_CONST               ('__array_wrap__', 'a.__array_wrap__(obj) -> Object of same type as ndarray object a.\n\n    ')
              852  CALL_FUNCTION_3       3  ''
              854  POP_TOP          

 L.2475       856  LOAD_NAME                add_newdoc
              858  LOAD_STR                 'numpy.core.multiarray'
              860  LOAD_STR                 'ndarray'
              862  LOAD_CONST               ('__copy__', "a.__copy__()\n\n    Used if :func:`copy.copy` is called on an array. Returns a copy of the array.\n\n    Equivalent to ``a.copy(order='K')``.\n\n    ")
              864  CALL_FUNCTION_3       3  ''
              866  POP_TOP          

 L.2485       868  LOAD_NAME                add_newdoc
              870  LOAD_STR                 'numpy.core.multiarray'
              872  LOAD_STR                 'ndarray'
              874  LOAD_CONST               ('__deepcopy__', 'a.__deepcopy__(memo, /) -> Deep copy of array.\n\n    Used if :func:`copy.deepcopy` is called on an array.\n\n    ')
              876  CALL_FUNCTION_3       3  ''
              878  POP_TOP          

 L.2493       880  LOAD_NAME                add_newdoc
              882  LOAD_STR                 'numpy.core.multiarray'
              884  LOAD_STR                 'ndarray'
              886  LOAD_CONST               ('__reduce__', 'a.__reduce__()\n\n    For pickling.\n\n    ')
              888  CALL_FUNCTION_3       3  ''
              890  POP_TOP          

 L.2501       892  LOAD_NAME                add_newdoc
              894  LOAD_STR                 'numpy.core.multiarray'
              896  LOAD_STR                 'ndarray'
              898  LOAD_CONST               ('__setstate__', "a.__setstate__(state, /)\n\n    For unpickling.\n\n    The `state` argument must be a sequence that contains the following\n    elements:\n\n    Parameters\n    ----------\n    version : int\n        optional pickle version. If omitted defaults to 0.\n    shape : tuple\n    dtype : data-type\n    isFortran : bool\n    rawdata : string or list\n        a binary string with the data (or a list if 'a' is an object array)\n\n    ")
              900  CALL_FUNCTION_3       3  ''
              902  POP_TOP          

 L.2522       904  LOAD_NAME                add_newdoc
              906  LOAD_STR                 'numpy.core.multiarray'
              908  LOAD_STR                 'ndarray'
              910  LOAD_CONST               ('all', '\n    a.all(axis=None, out=None, keepdims=False)\n\n    Returns True if all elements evaluate to True.\n\n    Refer to `numpy.all` for full documentation.\n\n    See Also\n    --------\n    numpy.all : equivalent function\n\n    ')
              912  CALL_FUNCTION_3       3  ''
              914  POP_TOP          

 L.2537       916  LOAD_NAME                add_newdoc
              918  LOAD_STR                 'numpy.core.multiarray'
              920  LOAD_STR                 'ndarray'
              922  LOAD_CONST               ('any', '\n    a.any(axis=None, out=None, keepdims=False)\n\n    Returns True if any of the elements of `a` evaluate to True.\n\n    Refer to `numpy.any` for full documentation.\n\n    See Also\n    --------\n    numpy.any : equivalent function\n\n    ')
              924  CALL_FUNCTION_3       3  ''
              926  POP_TOP          

 L.2552       928  LOAD_NAME                add_newdoc
              930  LOAD_STR                 'numpy.core.multiarray'
              932  LOAD_STR                 'ndarray'
              934  LOAD_CONST               ('argmax', '\n    a.argmax(axis=None, out=None)\n\n    Return indices of the maximum values along the given axis.\n\n    Refer to `numpy.argmax` for full documentation.\n\n    See Also\n    --------\n    numpy.argmax : equivalent function\n\n    ')
              936  CALL_FUNCTION_3       3  ''
              938  POP_TOP          

 L.2567       940  LOAD_NAME                add_newdoc
              942  LOAD_STR                 'numpy.core.multiarray'
              944  LOAD_STR                 'ndarray'
              946  LOAD_CONST               ('argmin', '\n    a.argmin(axis=None, out=None)\n\n    Return indices of the minimum values along the given axis of `a`.\n\n    Refer to `numpy.argmin` for detailed documentation.\n\n    See Also\n    --------\n    numpy.argmin : equivalent function\n\n    ')
              948  CALL_FUNCTION_3       3  ''
              950  POP_TOP          

 L.2582       952  LOAD_NAME                add_newdoc
              954  LOAD_STR                 'numpy.core.multiarray'
              956  LOAD_STR                 'ndarray'
              958  LOAD_CONST               ('argsort', '\n    a.argsort(axis=-1, kind=None, order=None)\n\n    Returns the indices that would sort this array.\n\n    Refer to `numpy.argsort` for full documentation.\n\n    See Also\n    --------\n    numpy.argsort : equivalent function\n\n    ')
              960  CALL_FUNCTION_3       3  ''
              962  POP_TOP          

 L.2597       964  LOAD_NAME                add_newdoc
              966  LOAD_STR                 'numpy.core.multiarray'
              968  LOAD_STR                 'ndarray'
              970  LOAD_CONST               ('argpartition', "\n    a.argpartition(kth, axis=-1, kind='introselect', order=None)\n\n    Returns the indices that would partition this array.\n\n    Refer to `numpy.argpartition` for full documentation.\n\n    .. versionadded:: 1.8.0\n\n    See Also\n    --------\n    numpy.argpartition : equivalent function\n\n    ")
              972  CALL_FUNCTION_3       3  ''
              974  POP_TOP          

 L.2614       976  LOAD_NAME                add_newdoc
              978  LOAD_STR                 'numpy.core.multiarray'
              980  LOAD_STR                 'ndarray'
              982  LOAD_CONST               ('astype', '\n    a.astype(dtype, order=\'K\', casting=\'unsafe\', subok=True, copy=True)\n\n    Copy of the array, cast to a specified type.\n\n    Parameters\n    ----------\n    dtype : str or dtype\n        Typecode or data-type to which the array is cast.\n    order : {\'C\', \'F\', \'A\', \'K\'}, optional\n        Controls the memory layout order of the result.\n        \'C\' means C order, \'F\' means Fortran order, \'A\'\n        means \'F\' order if all the arrays are Fortran contiguous,\n        \'C\' order otherwise, and \'K\' means as close to the\n        order the array elements appear in memory as possible.\n        Default is \'K\'.\n    casting : {\'no\', \'equiv\', \'safe\', \'same_kind\', \'unsafe\'}, optional\n        Controls what kind of data casting may occur. Defaults to \'unsafe\'\n        for backwards compatibility.\n\n          * \'no\' means the data types should not be cast at all.\n          * \'equiv\' means only byte-order changes are allowed.\n          * \'safe\' means only casts which can preserve values are allowed.\n          * \'same_kind\' means only safe casts or casts within a kind,\n            like float64 to float32, are allowed.\n          * \'unsafe\' means any data conversions may be done.\n    subok : bool, optional\n        If True, then sub-classes will be passed-through (default), otherwise\n        the returned array will be forced to be a base-class array.\n    copy : bool, optional\n        By default, astype always returns a newly allocated array. If this\n        is set to false, and the `dtype`, `order`, and `subok`\n        requirements are satisfied, the input array is returned instead\n        of a copy.\n\n    Returns\n    -------\n    arr_t : ndarray\n        Unless `copy` is False and the other conditions for returning the input\n        array are satisfied (see description for `copy` input parameter), `arr_t`\n        is a new array of the same shape as the input array, with dtype, order\n        given by `dtype`, `order`.\n\n    Notes\n    -----\n    .. versionchanged:: 1.17.0\n       Casting between a simple data type and a structured one is possible only\n       for "unsafe" casting.  Casting to multiple fields is allowed, but\n       casting from multiple fields is not.\n\n    .. versionchanged:: 1.9.0\n       Casting from numeric to string types in \'safe\' casting mode requires\n       that the string dtype length is long enough to store the max\n       integer/float value converted.\n\n    Raises\n    ------\n    ComplexWarning\n        When casting from complex to float or int. To avoid this,\n        one should use ``a.real.astype(t)``.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 2.5])\n    >>> x\n    array([1. ,  2. ,  2.5])\n\n    >>> x.astype(int)\n    array([1, 2, 2])\n\n    ')
              984  CALL_FUNCTION_3       3  ''
              986  POP_TOP          

 L.2688       988  LOAD_NAME                add_newdoc
              990  LOAD_STR                 'numpy.core.multiarray'
              992  LOAD_STR                 'ndarray'
              994  LOAD_CONST               ('byteswap', "\n    a.byteswap(inplace=False)\n\n    Swap the bytes of the array elements\n\n    Toggle between low-endian and big-endian data representation by\n    returning a byteswapped array, optionally swapped in-place.\n    Arrays of byte-strings are not swapped. The real and imaginary\n    parts of a complex number are swapped individually.\n\n    Parameters\n    ----------\n    inplace : bool, optional\n        If ``True``, swap bytes in-place, default is ``False``.\n\n    Returns\n    -------\n    out : ndarray\n        The byteswapped array. If `inplace` is ``True``, this is\n        a view to self.\n\n    Examples\n    --------\n    >>> A = np.array([1, 256, 8755], dtype=np.int16)\n    >>> list(map(hex, A))\n    ['0x1', '0x100', '0x2233']\n    >>> A.byteswap(inplace=True)\n    array([  256,     1, 13090], dtype=int16)\n    >>> list(map(hex, A))\n    ['0x100', '0x1', '0x3322']\n\n    Arrays of byte-strings are not swapped\n\n    >>> A = np.array([b'ceg', b'fac'])\n    >>> A.byteswap()\n    array([b'ceg', b'fac'], dtype='|S3')\n\n    ``A.newbyteorder().byteswap()`` produces an array with the same values\n      but different representation in memory\n\n    >>> A = np.array([1, 2, 3])\n    >>> A.view(np.uint8)\n    array([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n           0, 0], dtype=uint8)\n    >>> A.newbyteorder().byteswap(inplace=True)\n    array([1, 2, 3])\n    >>> A.view(np.uint8)\n    array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n           0, 3], dtype=uint8)\n\n    ")
              996  CALL_FUNCTION_3       3  ''
              998  POP_TOP          

 L.2742      1000  LOAD_NAME                add_newdoc
             1002  LOAD_STR                 'numpy.core.multiarray'
             1004  LOAD_STR                 'ndarray'
             1006  LOAD_CONST               ('choose', "\n    a.choose(choices, out=None, mode='raise')\n\n    Use an index array to construct a new array from a set of choices.\n\n    Refer to `numpy.choose` for full documentation.\n\n    See Also\n    --------\n    numpy.choose : equivalent function\n\n    ")
             1008  CALL_FUNCTION_3       3  ''
             1010  POP_TOP          

 L.2757      1012  LOAD_NAME                add_newdoc
             1014  LOAD_STR                 'numpy.core.multiarray'
             1016  LOAD_STR                 'ndarray'
             1018  LOAD_CONST               ('clip', '\n    a.clip(min=None, max=None, out=None, **kwargs)\n\n    Return an array whose values are limited to ``[min, max]``.\n    One of max or min must be given.\n\n    Refer to `numpy.clip` for full documentation.\n\n    See Also\n    --------\n    numpy.clip : equivalent function\n\n    ')
             1020  CALL_FUNCTION_3       3  ''
             1022  POP_TOP          

 L.2773      1024  LOAD_NAME                add_newdoc
             1026  LOAD_STR                 'numpy.core.multiarray'
             1028  LOAD_STR                 'ndarray'
             1030  LOAD_CONST               ('compress', '\n    a.compress(condition, axis=None, out=None)\n\n    Return selected slices of this array along given axis.\n\n    Refer to `numpy.compress` for full documentation.\n\n    See Also\n    --------\n    numpy.compress : equivalent function\n\n    ')
             1032  CALL_FUNCTION_3       3  ''
             1034  POP_TOP          

 L.2788      1036  LOAD_NAME                add_newdoc
             1038  LOAD_STR                 'numpy.core.multiarray'
             1040  LOAD_STR                 'ndarray'
             1042  LOAD_CONST               ('conj', '\n    a.conj()\n\n    Complex-conjugate all elements.\n\n    Refer to `numpy.conjugate` for full documentation.\n\n    See Also\n    --------\n    numpy.conjugate : equivalent function\n\n    ')
             1044  CALL_FUNCTION_3       3  ''
             1046  POP_TOP          

 L.2803      1048  LOAD_NAME                add_newdoc
             1050  LOAD_STR                 'numpy.core.multiarray'
             1052  LOAD_STR                 'ndarray'
             1054  LOAD_CONST               ('conjugate', '\n    a.conjugate()\n\n    Return the complex conjugate, element-wise.\n\n    Refer to `numpy.conjugate` for full documentation.\n\n    See Also\n    --------\n    numpy.conjugate : equivalent function\n\n    ')
             1056  CALL_FUNCTION_3       3  ''
             1058  POP_TOP          

 L.2818      1060  LOAD_NAME                add_newdoc
             1062  LOAD_STR                 'numpy.core.multiarray'
             1064  LOAD_STR                 'ndarray'
             1066  LOAD_CONST               ('copy', "\n    a.copy(order='C')\n\n    Return a copy of the array.\n\n    Parameters\n    ----------\n    order : {'C', 'F', 'A', 'K'}, optional\n        Controls the memory layout of the copy. 'C' means C-order,\n        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n        'C' otherwise. 'K' means match the layout of `a` as closely\n        as possible. (Note that this function and :func:`numpy.copy` are very\n        similar, but have different default values for their order=\n        arguments.)\n\n    See also\n    --------\n    numpy.copy\n    numpy.copyto\n\n    Examples\n    --------\n    >>> x = np.array([[1,2,3],[4,5,6]], order='F')\n\n    >>> y = x.copy()\n\n    >>> x.fill(0)\n\n    >>> x\n    array([[0, 0, 0],\n           [0, 0, 0]])\n\n    >>> y\n    array([[1, 2, 3],\n           [4, 5, 6]])\n\n    >>> y.flags['C_CONTIGUOUS']\n    True\n\n    ")
             1068  CALL_FUNCTION_3       3  ''
             1070  POP_TOP          

 L.2861      1072  LOAD_NAME                add_newdoc
             1074  LOAD_STR                 'numpy.core.multiarray'
             1076  LOAD_STR                 'ndarray'
             1078  LOAD_CONST               ('cumprod', '\n    a.cumprod(axis=None, dtype=None, out=None)\n\n    Return the cumulative product of the elements along the given axis.\n\n    Refer to `numpy.cumprod` for full documentation.\n\n    See Also\n    --------\n    numpy.cumprod : equivalent function\n\n    ')
             1080  CALL_FUNCTION_3       3  ''
             1082  POP_TOP          

 L.2876      1084  LOAD_NAME                add_newdoc
             1086  LOAD_STR                 'numpy.core.multiarray'
             1088  LOAD_STR                 'ndarray'
             1090  LOAD_CONST               ('cumsum', '\n    a.cumsum(axis=None, dtype=None, out=None)\n\n    Return the cumulative sum of the elements along the given axis.\n\n    Refer to `numpy.cumsum` for full documentation.\n\n    See Also\n    --------\n    numpy.cumsum : equivalent function\n\n    ')
             1092  CALL_FUNCTION_3       3  ''
             1094  POP_TOP          

 L.2891      1096  LOAD_NAME                add_newdoc
             1098  LOAD_STR                 'numpy.core.multiarray'
             1100  LOAD_STR                 'ndarray'
             1102  LOAD_CONST               ('diagonal', '\n    a.diagonal(offset=0, axis1=0, axis2=1)\n\n    Return specified diagonals. In NumPy 1.9 the returned array is a\n    read-only view instead of a copy as in previous NumPy versions.  In\n    a future version the read-only restriction will be removed.\n\n    Refer to :func:`numpy.diagonal` for full documentation.\n\n    See Also\n    --------\n    numpy.diagonal : equivalent function\n\n    ')
             1104  CALL_FUNCTION_3       3  ''
             1106  POP_TOP          

 L.2908      1108  LOAD_NAME                add_newdoc
             1110  LOAD_STR                 'numpy.core.multiarray'
             1112  LOAD_STR                 'ndarray'
             1114  LOAD_CONST               ('dot', '\n    a.dot(b, out=None)\n\n    Dot product of two arrays.\n\n    Refer to `numpy.dot` for full documentation.\n\n    See Also\n    --------\n    numpy.dot : equivalent function\n\n    Examples\n    --------\n    >>> a = np.eye(2)\n    >>> b = np.ones((2, 2)) * 2\n    >>> a.dot(b)\n    array([[2.,  2.],\n           [2.,  2.]])\n\n    This array method can be conveniently chained:\n\n    >>> a.dot(b).dot(b)\n    array([[8.,  8.],\n           [8.,  8.]])\n\n    ')
             1116  CALL_FUNCTION_3       3  ''
             1118  POP_TOP          

 L.2937      1120  LOAD_NAME                add_newdoc
             1122  LOAD_STR                 'numpy.core.multiarray'
             1124  LOAD_STR                 'ndarray'
             1126  LOAD_CONST               ('dump', 'a.dump(file)\n\n    Dump a pickle of the array to the specified file.\n    The array can be read back with pickle.load or numpy.load.\n\n    Parameters\n    ----------\n    file : str or Path\n        A string naming the dump file.\n\n        .. versionchanged:: 1.17.0\n            `pathlib.Path` objects are now accepted.\n\n    ')
             1128  CALL_FUNCTION_3       3  ''
             1130  POP_TOP          

 L.2954      1132  LOAD_NAME                add_newdoc
             1134  LOAD_STR                 'numpy.core.multiarray'
             1136  LOAD_STR                 'ndarray'
             1138  LOAD_CONST               ('dumps', '\n    a.dumps()\n\n    Returns the pickle of the array as a string.\n    pickle.loads or numpy.loads will convert the string back to an array.\n\n    Parameters\n    ----------\n    None\n\n    ')
             1140  CALL_FUNCTION_3       3  ''
             1142  POP_TOP          

 L.2968      1144  LOAD_NAME                add_newdoc
             1146  LOAD_STR                 'numpy.core.multiarray'
             1148  LOAD_STR                 'ndarray'
             1150  LOAD_CONST               ('fill', '\n    a.fill(value)\n\n    Fill the array with a scalar value.\n\n    Parameters\n    ----------\n    value : scalar\n        All elements of `a` will be assigned this value.\n\n    Examples\n    --------\n    >>> a = np.array([1, 2])\n    >>> a.fill(0)\n    >>> a\n    array([0, 0])\n    >>> a = np.empty(2)\n    >>> a.fill(1)\n    >>> a\n    array([1.,  1.])\n\n    ')
             1152  CALL_FUNCTION_3       3  ''
             1154  POP_TOP          

 L.2993      1156  LOAD_NAME                add_newdoc
             1158  LOAD_STR                 'numpy.core.multiarray'
             1160  LOAD_STR                 'ndarray'
             1162  LOAD_CONST               ('flatten', "\n    a.flatten(order='C')\n\n    Return a copy of the array collapsed into one dimension.\n\n    Parameters\n    ----------\n    order : {'C', 'F', 'A', 'K'}, optional\n        'C' means to flatten in row-major (C-style) order.\n        'F' means to flatten in column-major (Fortran-\n        style) order. 'A' means to flatten in column-major\n        order if `a` is Fortran *contiguous* in memory,\n        row-major order otherwise. 'K' means to flatten\n        `a` in the order the elements occur in memory.\n        The default is 'C'.\n\n    Returns\n    -------\n    y : ndarray\n        A copy of the input array, flattened to one dimension.\n\n    See Also\n    --------\n    ravel : Return a flattened array.\n    flat : A 1-D flat iterator over the array.\n\n    Examples\n    --------\n    >>> a = np.array([[1,2], [3,4]])\n    >>> a.flatten()\n    array([1, 2, 3, 4])\n    >>> a.flatten('F')\n    array([1, 3, 2, 4])\n\n    ")
             1164  CALL_FUNCTION_3       3  ''
             1166  POP_TOP          

 L.3031      1168  LOAD_NAME                add_newdoc
             1170  LOAD_STR                 'numpy.core.multiarray'
             1172  LOAD_STR                 'ndarray'
             1174  LOAD_CONST               ('getfield', '\n    a.getfield(dtype, offset=0)\n\n    Returns a field of the given array as a certain type.\n\n    A field is a view of the array data with a given data-type. The values in\n    the view are determined by the given type and the offset into the current\n    array in bytes. The offset needs to be such that the view dtype fits in the\n    array dtype; for example an array of dtype complex128 has 16-byte elements.\n    If taking a view with a 32-bit integer (4 bytes), the offset needs to be\n    between 0 and 12 bytes.\n\n    Parameters\n    ----------\n    dtype : str or dtype\n        The data type of the view. The dtype size of the view can not be larger\n        than that of the array itself.\n    offset : int\n        Number of bytes to skip before beginning the element view.\n\n    Examples\n    --------\n    >>> x = np.diag([1.+1.j]*2)\n    >>> x[1, 1] = 2 + 4.j\n    >>> x\n    array([[1.+1.j,  0.+0.j],\n           [0.+0.j,  2.+4.j]])\n    >>> x.getfield(np.float64)\n    array([[1.,  0.],\n           [0.,  2.]])\n\n    By choosing an offset of 8 bytes we can select the complex part of the\n    array for our view:\n\n    >>> x.getfield(np.float64, offset=8)\n    array([[1.,  0.],\n           [0.,  4.]])\n\n    ')
             1176  CALL_FUNCTION_3       3  ''
             1178  POP_TOP          

 L.3073      1180  LOAD_NAME                add_newdoc
             1182  LOAD_STR                 'numpy.core.multiarray'
             1184  LOAD_STR                 'ndarray'
             1186  LOAD_CONST               ('item', "\n    a.item(*args)\n\n    Copy an element of an array to a standard Python scalar and return it.\n\n    Parameters\n    ----------\n    \\*args : Arguments (variable number and type)\n\n        * none: in this case, the method only works for arrays\n          with one element (`a.size == 1`), which element is\n          copied into a standard Python scalar object and returned.\n\n        * int_type: this argument is interpreted as a flat index into\n          the array, specifying which element to copy and return.\n\n        * tuple of int_types: functions as does a single int_type argument,\n          except that the argument is interpreted as an nd-index into the\n          array.\n\n    Returns\n    -------\n    z : Standard Python scalar object\n        A copy of the specified element of the array as a suitable\n        Python scalar\n\n    Notes\n    -----\n    When the data type of `a` is longdouble or clongdouble, item() returns\n    a scalar array object because there is no available Python scalar that\n    would not lose information. Void arrays return a buffer object for item(),\n    unless fields are defined, in which case a tuple is returned.\n\n    `item` is very similar to a[args], except, instead of an array scalar,\n    a standard Python scalar is returned. This can be useful for speeding up\n    access to elements of the array and doing arithmetic on elements of the\n    array using Python's optimized math.\n\n    Examples\n    --------\n    >>> np.random.seed(123)\n    >>> x = np.random.randint(9, size=(3, 3))\n    >>> x\n    array([[2, 2, 6],\n           [1, 3, 6],\n           [1, 0, 1]])\n    >>> x.item(3)\n    1\n    >>> x.item(7)\n    0\n    >>> x.item((0, 1))\n    2\n    >>> x.item((2, 2))\n    1\n\n    ")
             1188  CALL_FUNCTION_3       3  ''
             1190  POP_TOP          

 L.3132      1192  LOAD_NAME                add_newdoc
             1194  LOAD_STR                 'numpy.core.multiarray'
             1196  LOAD_STR                 'ndarray'
             1198  LOAD_CONST               ('itemset', "\n    a.itemset(*args)\n\n    Insert scalar into an array (scalar is cast to array's dtype, if possible)\n\n    There must be at least 1 argument, and define the last argument\n    as *item*.  Then, ``a.itemset(*args)`` is equivalent to but faster\n    than ``a[args] = item``.  The item should be a scalar value and `args`\n    must select a single item in the array `a`.\n\n    Parameters\n    ----------\n    \\*args : Arguments\n        If one argument: a scalar, only used in case `a` is of size 1.\n        If two arguments: the last argument is the value to be set\n        and must be a scalar, the first argument specifies a single array\n        element location. It is either an int or a tuple.\n\n    Notes\n    -----\n    Compared to indexing syntax, `itemset` provides some speed increase\n    for placing a scalar into a particular location in an `ndarray`,\n    if you must do this.  However, generally this is discouraged:\n    among other problems, it complicates the appearance of the code.\n    Also, when using `itemset` (and `item`) inside a loop, be sure\n    to assign the methods to a local variable to avoid the attribute\n    look-up at each loop iteration.\n\n    Examples\n    --------\n    >>> np.random.seed(123)\n    >>> x = np.random.randint(9, size=(3, 3))\n    >>> x\n    array([[2, 2, 6],\n           [1, 3, 6],\n           [1, 0, 1]])\n    >>> x.itemset(4, 0)\n    >>> x.itemset((2, 2), 9)\n    >>> x\n    array([[2, 2, 6],\n           [1, 0, 6],\n           [1, 0, 9]])\n\n    ")
             1200  CALL_FUNCTION_3       3  ''
             1202  POP_TOP          

 L.3179      1204  LOAD_NAME                add_newdoc
             1206  LOAD_STR                 'numpy.core.multiarray'
             1208  LOAD_STR                 'ndarray'
             1210  LOAD_CONST               ('max', '\n    a.max(axis=None, out=None, keepdims=False, initial=<no value>, where=True)\n\n    Return the maximum along a given axis.\n\n    Refer to `numpy.amax` for full documentation.\n\n    See Also\n    --------\n    numpy.amax : equivalent function\n\n    ')
             1212  CALL_FUNCTION_3       3  ''
             1214  POP_TOP          

 L.3194      1216  LOAD_NAME                add_newdoc
             1218  LOAD_STR                 'numpy.core.multiarray'
             1220  LOAD_STR                 'ndarray'
             1222  LOAD_CONST               ('mean', '\n    a.mean(axis=None, dtype=None, out=None, keepdims=False)\n\n    Returns the average of the array elements along given axis.\n\n    Refer to `numpy.mean` for full documentation.\n\n    See Also\n    --------\n    numpy.mean : equivalent function\n\n    ')
             1224  CALL_FUNCTION_3       3  ''
             1226  POP_TOP          

 L.3209      1228  LOAD_NAME                add_newdoc
             1230  LOAD_STR                 'numpy.core.multiarray'
             1232  LOAD_STR                 'ndarray'
             1234  LOAD_CONST               ('min', '\n    a.min(axis=None, out=None, keepdims=False, initial=<no value>, where=True)\n\n    Return the minimum along a given axis.\n\n    Refer to `numpy.amin` for full documentation.\n\n    See Also\n    --------\n    numpy.amin : equivalent function\n\n    ')
             1236  CALL_FUNCTION_3       3  ''
             1238  POP_TOP          

 L.3224      1240  LOAD_NAME                add_newdoc
             1242  LOAD_STR                 'numpy.core.multiarray'
             1244  LOAD_STR                 'ndarray'
             1246  LOAD_CONST               ('newbyteorder', "\n    arr.newbyteorder(new_order='S')\n\n    Return the array with the same data viewed with a different byte order.\n\n    Equivalent to::\n\n        arr.view(arr.dtype.newbytorder(new_order))\n\n    Changes are also made in all fields and sub-arrays of the array data\n    type.\n\n\n\n    Parameters\n    ----------\n    new_order : string, optional\n        Byte order to force; a value from the byte order specifications\n        below. `new_order` codes can be any of:\n\n        * 'S' - swap dtype from current to opposite endian\n        * {'<', 'L'} - little endian\n        * {'>', 'B'} - big endian\n        * {'=', 'N'} - native order\n        * {'|', 'I'} - ignore (no change to byte order)\n\n        The default value ('S') results in swapping the current\n        byte order. The code does a case-insensitive check on the first\n        letter of `new_order` for the alternatives above.  For example,\n        any of 'B' or 'b' or 'biggish' are valid to specify big-endian.\n\n\n    Returns\n    -------\n    new_arr : array\n        New array object with the dtype reflecting given change to the\n        byte order.\n\n    ")
             1248  CALL_FUNCTION_3       3  ''
             1250  POP_TOP          

 L.3266      1252  LOAD_NAME                add_newdoc
             1254  LOAD_STR                 'numpy.core.multiarray'
             1256  LOAD_STR                 'ndarray'
             1258  LOAD_CONST               ('nonzero', '\n    a.nonzero()\n\n    Return the indices of the elements that are non-zero.\n\n    Refer to `numpy.nonzero` for full documentation.\n\n    See Also\n    --------\n    numpy.nonzero : equivalent function\n\n    ')
             1260  CALL_FUNCTION_3       3  ''
             1262  POP_TOP          

 L.3281      1264  LOAD_NAME                add_newdoc
             1266  LOAD_STR                 'numpy.core.multiarray'
             1268  LOAD_STR                 'ndarray'
             1270  LOAD_CONST               ('prod', '\n    a.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True)\n\n    Return the product of the array elements over the given axis\n\n    Refer to `numpy.prod` for full documentation.\n\n    See Also\n    --------\n    numpy.prod : equivalent function\n\n    ')
             1272  CALL_FUNCTION_3       3  ''
             1274  POP_TOP          

 L.3296      1276  LOAD_NAME                add_newdoc
             1278  LOAD_STR                 'numpy.core.multiarray'
             1280  LOAD_STR                 'ndarray'
             1282  LOAD_CONST               ('ptp', '\n    a.ptp(axis=None, out=None, keepdims=False)\n\n    Peak to peak (maximum - minimum) value along a given axis.\n\n    Refer to `numpy.ptp` for full documentation.\n\n    See Also\n    --------\n    numpy.ptp : equivalent function\n\n    ')
             1284  CALL_FUNCTION_3       3  ''
             1286  POP_TOP          

 L.3311      1288  LOAD_NAME                add_newdoc
             1290  LOAD_STR                 'numpy.core.multiarray'
             1292  LOAD_STR                 'ndarray'
             1294  LOAD_CONST               ('put', "\n    a.put(indices, values, mode='raise')\n\n    Set ``a.flat[n] = values[n]`` for all `n` in indices.\n\n    Refer to `numpy.put` for full documentation.\n\n    See Also\n    --------\n    numpy.put : equivalent function\n\n    ")
             1296  CALL_FUNCTION_3       3  ''
             1298  POP_TOP          

 L.3326      1300  LOAD_NAME                add_newdoc
             1302  LOAD_STR                 'numpy.core.multiarray'
             1304  LOAD_STR                 'ndarray'
             1306  LOAD_CONST               ('ravel', '\n    a.ravel([order])\n\n    Return a flattened array.\n\n    Refer to `numpy.ravel` for full documentation.\n\n    See Also\n    --------\n    numpy.ravel : equivalent function\n\n    ndarray.flat : a flat iterator on the array.\n\n    ')
             1308  CALL_FUNCTION_3       3  ''
             1310  POP_TOP          

 L.3343      1312  LOAD_NAME                add_newdoc
             1314  LOAD_STR                 'numpy.core.multiarray'
             1316  LOAD_STR                 'ndarray'
             1318  LOAD_CONST               ('repeat', '\n    a.repeat(repeats, axis=None)\n\n    Repeat elements of an array.\n\n    Refer to `numpy.repeat` for full documentation.\n\n    See Also\n    --------\n    numpy.repeat : equivalent function\n\n    ')
             1320  CALL_FUNCTION_3       3  ''
             1322  POP_TOP          

 L.3358      1324  LOAD_NAME                add_newdoc
             1326  LOAD_STR                 'numpy.core.multiarray'
             1328  LOAD_STR                 'ndarray'
             1330  LOAD_CONST               ('reshape', "\n    a.reshape(shape, order='C')\n\n    Returns an array containing the same data with a new shape.\n\n    Refer to `numpy.reshape` for full documentation.\n\n    See Also\n    --------\n    numpy.reshape : equivalent function\n\n    Notes\n    -----\n    Unlike the free function `numpy.reshape`, this method on `ndarray` allows\n    the elements of the shape parameter to be passed in as separate arguments.\n    For example, ``a.reshape(10, 11)`` is equivalent to\n    ``a.reshape((10, 11))``.\n\n    ")
             1332  CALL_FUNCTION_3       3  ''
             1334  POP_TOP          

 L.3380      1336  LOAD_NAME                add_newdoc
             1338  LOAD_STR                 'numpy.core.multiarray'
             1340  LOAD_STR                 'ndarray'
             1342  LOAD_CONST               ('resize', "\n    a.resize(new_shape, refcheck=True)\n\n    Change shape and size of array in-place.\n\n    Parameters\n    ----------\n    new_shape : tuple of ints, or `n` ints\n        Shape of resized array.\n    refcheck : bool, optional\n        If False, reference count will not be checked. Default is True.\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    ValueError\n        If `a` does not own its own data or references or views to it exist,\n        and the data memory must be changed.\n        PyPy only: will always raise if the data memory must be changed, since\n        there is no reliable way to determine if references or views to it\n        exist.\n\n    SystemError\n        If the `order` keyword argument is specified. This behaviour is a\n        bug in NumPy.\n\n    See Also\n    --------\n    resize : Return a new array with the specified shape.\n\n    Notes\n    -----\n    This reallocates space for the data area if necessary.\n\n    Only contiguous arrays (data elements consecutive in memory) can be\n    resized.\n\n    The purpose of the reference count check is to make sure you\n    do not use this array as a buffer for another Python object and then\n    reallocate the memory. However, reference counts can increase in\n    other ways so if you are sure that you have not shared the memory\n    for this array with another Python object, then you may safely set\n    `refcheck` to False.\n\n    Examples\n    --------\n    Shrinking an array: array is flattened (in the order that the data are\n    stored in memory), resized, and reshaped:\n\n    >>> a = np.array([[0, 1], [2, 3]], order='C')\n    >>> a.resize((2, 1))\n    >>> a\n    array([[0],\n           [1]])\n\n    >>> a = np.array([[0, 1], [2, 3]], order='F')\n    >>> a.resize((2, 1))\n    >>> a\n    array([[0],\n           [2]])\n\n    Enlarging an array: as above, but missing entries are filled with zeros:\n\n    >>> b = np.array([[0, 1], [2, 3]])\n    >>> b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n    >>> b\n    array([[0, 1, 2],\n           [3, 0, 0]])\n\n    Referencing an array prevents resizing...\n\n    >>> c = a\n    >>> a.resize((1, 1))\n    Traceback (most recent call last):\n    ...\n    ValueError: cannot resize an array that references or is referenced ...\n\n    Unless `refcheck` is False:\n\n    >>> a.resize((1, 1), refcheck=False)\n    >>> a\n    array([[0]])\n    >>> c\n    array([[0]])\n\n    ")
             1344  CALL_FUNCTION_3       3  ''
             1346  POP_TOP          

 L.3472      1348  LOAD_NAME                add_newdoc
             1350  LOAD_STR                 'numpy.core.multiarray'
             1352  LOAD_STR                 'ndarray'
             1354  LOAD_CONST               ('round', '\n    a.round(decimals=0, out=None)\n\n    Return `a` with each element rounded to the given number of decimals.\n\n    Refer to `numpy.around` for full documentation.\n\n    See Also\n    --------\n    numpy.around : equivalent function\n\n    ')
             1356  CALL_FUNCTION_3       3  ''
             1358  POP_TOP          

 L.3487      1360  LOAD_NAME                add_newdoc
             1362  LOAD_STR                 'numpy.core.multiarray'
             1364  LOAD_STR                 'ndarray'
             1366  LOAD_CONST               ('searchsorted', "\n    a.searchsorted(v, side='left', sorter=None)\n\n    Find indices where elements of v should be inserted in a to maintain order.\n\n    For full documentation, see `numpy.searchsorted`\n\n    See Also\n    --------\n    numpy.searchsorted : equivalent function\n\n    ")
             1368  CALL_FUNCTION_3       3  ''
             1370  POP_TOP          

 L.3502      1372  LOAD_NAME                add_newdoc
             1374  LOAD_STR                 'numpy.core.multiarray'
             1376  LOAD_STR                 'ndarray'
             1378  LOAD_CONST               ('setfield', "\n    a.setfield(val, dtype, offset=0)\n\n    Put a value into a specified place in a field defined by a data-type.\n\n    Place `val` into `a`'s field defined by `dtype` and beginning `offset`\n    bytes into the field.\n\n    Parameters\n    ----------\n    val : object\n        Value to be placed in field.\n    dtype : dtype object\n        Data-type of the field in which to place `val`.\n    offset : int, optional\n        The number of bytes into the field at which to place `val`.\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    getfield\n\n    Examples\n    --------\n    >>> x = np.eye(3)\n    >>> x.getfield(np.float64)\n    array([[1.,  0.,  0.],\n           [0.,  1.,  0.],\n           [0.,  0.,  1.]])\n    >>> x.setfield(3, np.int32)\n    >>> x.getfield(np.int32)\n    array([[3, 3, 3],\n           [3, 3, 3],\n           [3, 3, 3]], dtype=int32)\n    >>> x\n    array([[1.0e+000, 1.5e-323, 1.5e-323],\n           [1.5e-323, 1.0e+000, 1.5e-323],\n           [1.5e-323, 1.5e-323, 1.0e+000]])\n    >>> x.setfield(np.eye(3), np.int32)\n    >>> x\n    array([[1.,  0.,  0.],\n           [0.,  1.,  0.],\n           [0.,  0.,  1.]])\n\n    ")
             1380  CALL_FUNCTION_3       3  ''
             1382  POP_TOP          

 L.3553      1384  LOAD_NAME                add_newdoc
             1386  LOAD_STR                 'numpy.core.multiarray'
             1388  LOAD_STR                 'ndarray'
             1390  LOAD_CONST               ('setflags', '\n    a.setflags(write=None, align=None, uic=None)\n\n    Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),\n    respectively.\n\n    These Boolean-valued flags affect how numpy interprets the memory\n    area used by `a` (see Notes below). The ALIGNED flag can only\n    be set to True if the data is actually aligned according to the type.\n    The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set\n    to True. The flag WRITEABLE can only be set to True if the array owns its\n    own memory, or the ultimate owner of the memory exposes a writeable buffer\n    interface, or is a string. (The exception for string is made so that\n    unpickling can be done without copying memory.)\n\n    Parameters\n    ----------\n    write : bool, optional\n        Describes whether or not `a` can be written to.\n    align : bool, optional\n        Describes whether or not `a` is aligned properly for its type.\n    uic : bool, optional\n        Describes whether or not `a` is a copy of another "base" array.\n\n    Notes\n    -----\n    Array flags provide information about how the memory area used\n    for the array is to be interpreted. There are 7 Boolean flags\n    in use, only four of which can be changed by the user:\n    WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.\n\n    WRITEABLE (W) the data area can be written to;\n\n    ALIGNED (A) the data and strides are aligned appropriately for the hardware\n    (as determined by the compiler);\n\n    UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;\n\n    WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced\n    by .base). When the C-API function PyArray_ResolveWritebackIfCopy is\n    called, the base array will be updated with the contents of this array.\n\n    All flags can be accessed using the single (upper case) letter as well\n    as the full name.\n\n    Examples\n    --------\n    >>> y = np.array([[3, 1, 7],\n    ...               [2, 0, 0],\n    ...               [8, 5, 9]])\n    >>> y\n    array([[3, 1, 7],\n           [2, 0, 0],\n           [8, 5, 9]])\n    >>> y.flags\n      C_CONTIGUOUS : True\n      F_CONTIGUOUS : False\n      OWNDATA : True\n      WRITEABLE : True\n      ALIGNED : True\n      WRITEBACKIFCOPY : False\n      UPDATEIFCOPY : False\n    >>> y.setflags(write=0, align=0)\n    >>> y.flags\n      C_CONTIGUOUS : True\n      F_CONTIGUOUS : False\n      OWNDATA : True\n      WRITEABLE : False\n      ALIGNED : False\n      WRITEBACKIFCOPY : False\n      UPDATEIFCOPY : False\n    >>> y.setflags(uic=1)\n    Traceback (most recent call last):\n      File "<stdin>", line 1, in <module>\n    ValueError: cannot set WRITEBACKIFCOPY flag to True\n\n    ')
             1392  CALL_FUNCTION_3       3  ''
             1394  POP_TOP          

 L.3633      1396  LOAD_NAME                add_newdoc
             1398  LOAD_STR                 'numpy.core.multiarray'
             1400  LOAD_STR                 'ndarray'
             1402  LOAD_CONST               ('sort', "\n    a.sort(axis=-1, kind=None, order=None)\n\n    Sort an array in-place. Refer to `numpy.sort` for full documentation.\n\n    Parameters\n    ----------\n    axis : int, optional\n        Axis along which to sort. Default is -1, which means sort along the\n        last axis.\n    kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional\n        Sorting algorithm. The default is 'quicksort'. Note that both 'stable'\n        and 'mergesort' use timsort under the covers and, in general, the\n        actual implementation will vary with datatype. The 'mergesort' option\n        is retained for backwards compatibility.\n\n        .. versionchanged:: 1.15.0.\n           The 'stable' option was added.\n\n    order : str or list of str, optional\n        When `a` is an array with fields defined, this argument specifies\n        which fields to compare first, second, etc.  A single field can\n        be specified as a string, and not all fields need be specified,\n        but unspecified fields will still be used, in the order in which\n        they come up in the dtype, to break ties.\n\n    See Also\n    --------\n    numpy.sort : Return a sorted copy of an array.\n    numpy.argsort : Indirect sort.\n    numpy.lexsort : Indirect stable sort on multiple keys.\n    numpy.searchsorted : Find elements in sorted array.\n    numpy.partition: Partial sort.\n\n    Notes\n    -----\n    See `numpy.sort` for notes on the different sorting algorithms.\n\n    Examples\n    --------\n    >>> a = np.array([[1,4], [3,1]])\n    >>> a.sort(axis=1)\n    >>> a\n    array([[1, 4],\n           [1, 3]])\n    >>> a.sort(axis=0)\n    >>> a\n    array([[1, 3],\n           [1, 4]])\n\n    Use the `order` keyword to specify a field to use when sorting a\n    structured array:\n\n    >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n    >>> a.sort(order='y')\n    >>> a\n    array([(b'c', 1), (b'a', 2)],\n          dtype=[('x', 'S1'), ('y', '<i8')])\n\n    ")
             1404  CALL_FUNCTION_3       3  ''
             1406  POP_TOP          

 L.3696      1408  LOAD_NAME                add_newdoc
             1410  LOAD_STR                 'numpy.core.multiarray'
             1412  LOAD_STR                 'ndarray'
             1414  LOAD_CONST               ('partition', "\n    a.partition(kth, axis=-1, kind='introselect', order=None)\n\n    Rearranges the elements in the array in such a way that the value of the\n    element in kth position is in the position it would be in a sorted array.\n    All elements smaller than the kth element are moved before this element and\n    all equal or greater are moved behind it. The ordering of the elements in\n    the two partitions is undefined.\n\n    .. versionadded:: 1.8.0\n\n    Parameters\n    ----------\n    kth : int or sequence of ints\n        Element index to partition by. The kth element value will be in its\n        final sorted position and all smaller elements will be moved before it\n        and all equal or greater elements behind it.\n        The order of all elements in the partitions is undefined.\n        If provided with a sequence of kth it will partition all elements\n        indexed by kth of them into their sorted position at once.\n    axis : int, optional\n        Axis along which to sort. Default is -1, which means sort along the\n        last axis.\n    kind : {'introselect'}, optional\n        Selection algorithm. Default is 'introselect'.\n    order : str or list of str, optional\n        When `a` is an array with fields defined, this argument specifies\n        which fields to compare first, second, etc. A single field can\n        be specified as a string, and not all fields need to be specified,\n        but unspecified fields will still be used, in the order in which\n        they come up in the dtype, to break ties.\n\n    See Also\n    --------\n    numpy.partition : Return a parititioned copy of an array.\n    argpartition : Indirect partition.\n    sort : Full sort.\n\n    Notes\n    -----\n    See ``np.partition`` for notes on the different algorithms.\n\n    Examples\n    --------\n    >>> a = np.array([3, 4, 2, 1])\n    >>> a.partition(3)\n    >>> a\n    array([2, 1, 3, 4])\n\n    >>> a.partition((1, 3))\n    >>> a\n    array([1, 2, 3, 4])\n    ")
             1416  CALL_FUNCTION_3       3  ''
             1418  POP_TOP          

 L.3752      1420  LOAD_NAME                add_newdoc
             1422  LOAD_STR                 'numpy.core.multiarray'
             1424  LOAD_STR                 'ndarray'
             1426  LOAD_CONST               ('squeeze', '\n    a.squeeze(axis=None)\n\n    Remove single-dimensional entries from the shape of `a`.\n\n    Refer to `numpy.squeeze` for full documentation.\n\n    See Also\n    --------\n    numpy.squeeze : equivalent function\n\n    ')
             1428  CALL_FUNCTION_3       3  ''
             1430  POP_TOP          

 L.3767      1432  LOAD_NAME                add_newdoc
             1434  LOAD_STR                 'numpy.core.multiarray'
             1436  LOAD_STR                 'ndarray'
             1438  LOAD_CONST               ('std', '\n    a.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)\n\n    Returns the standard deviation of the array elements along given axis.\n\n    Refer to `numpy.std` for full documentation.\n\n    See Also\n    --------\n    numpy.std : equivalent function\n\n    ')
             1440  CALL_FUNCTION_3       3  ''
             1442  POP_TOP          

 L.3782      1444  LOAD_NAME                add_newdoc
             1446  LOAD_STR                 'numpy.core.multiarray'
             1448  LOAD_STR                 'ndarray'
             1450  LOAD_CONST               ('sum', '\n    a.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True)\n\n    Return the sum of the array elements over the given axis.\n\n    Refer to `numpy.sum` for full documentation.\n\n    See Also\n    --------\n    numpy.sum : equivalent function\n\n    ')
             1452  CALL_FUNCTION_3       3  ''
             1454  POP_TOP          

 L.3797      1456  LOAD_NAME                add_newdoc
             1458  LOAD_STR                 'numpy.core.multiarray'
             1460  LOAD_STR                 'ndarray'
             1462  LOAD_CONST               ('swapaxes', '\n    a.swapaxes(axis1, axis2)\n\n    Return a view of the array with `axis1` and `axis2` interchanged.\n\n    Refer to `numpy.swapaxes` for full documentation.\n\n    See Also\n    --------\n    numpy.swapaxes : equivalent function\n\n    ')
             1464  CALL_FUNCTION_3       3  ''
             1466  POP_TOP          

 L.3812      1468  LOAD_NAME                add_newdoc
             1470  LOAD_STR                 'numpy.core.multiarray'
             1472  LOAD_STR                 'ndarray'
             1474  LOAD_CONST               ('take', "\n    a.take(indices, axis=None, out=None, mode='raise')\n\n    Return an array formed from the elements of `a` at the given indices.\n\n    Refer to `numpy.take` for full documentation.\n\n    See Also\n    --------\n    numpy.take : equivalent function\n\n    ")
             1476  CALL_FUNCTION_3       3  ''
             1478  POP_TOP          

 L.3827      1480  LOAD_NAME                add_newdoc
             1482  LOAD_STR                 'numpy.core.multiarray'
             1484  LOAD_STR                 'ndarray'
             1486  LOAD_CONST               ('tofile', '\n    a.tofile(fid, sep="", format="%s")\n\n    Write array to a file as text or binary (default).\n\n    Data is always written in \'C\' order, independent of the order of `a`.\n    The data produced by this method can be recovered using the function\n    fromfile().\n\n    Parameters\n    ----------\n    fid : file or str or Path\n        An open file object, or a string containing a filename.\n\n        .. versionchanged:: 1.17.0\n            `pathlib.Path` objects are now accepted.\n\n    sep : str\n        Separator between array items for text output.\n        If "" (empty), a binary file is written, equivalent to\n        ``file.write(a.tobytes())``.\n    format : str\n        Format string for text file output.\n        Each entry in the array is formatted to text by first converting\n        it to the closest Python type, and then using "format" % item.\n\n    Notes\n    -----\n    This is a convenience function for quick storage of array data.\n    Information on endianness and precision is lost, so this method is not a\n    good choice for files intended to archive data or transport data between\n    machines with different endianness. Some of these problems can be overcome\n    by outputting the data as text files, at the expense of speed and file\n    size.\n\n    When fid is a file object, array contents are directly written to the\n    file, bypassing the file object\'s ``write`` method. As a result, tofile\n    cannot be used with files objects supporting compression (e.g., GzipFile)\n    or file-like objects that do not support ``fileno()`` (e.g., BytesIO).\n\n    ')
             1488  CALL_FUNCTION_3       3  ''
             1490  POP_TOP          

 L.3871      1492  LOAD_NAME                add_newdoc
             1494  LOAD_STR                 'numpy.core.multiarray'
             1496  LOAD_STR                 'ndarray'
             1498  LOAD_CONST               ('tolist', "\n    a.tolist()\n\n    Return the array as an ``a.ndim``-levels deep nested list of Python scalars.\n\n    Return a copy of the array data as a (nested) Python list.\n    Data items are converted to the nearest compatible builtin Python type, via\n    the `~numpy.ndarray.item` function.\n\n    If ``a.ndim`` is 0, then since the depth of the nested list is 0, it will\n    not be a list at all, but a simple Python scalar.\n\n    Parameters\n    ----------\n    none\n\n    Returns\n    -------\n    y : object, or list of object, or list of list of object, or ...\n        The possibly nested list of array elements.\n\n    Notes\n    -----\n    The array may be recreated via ``a = np.array(a.tolist())``, although this\n    may sometimes lose precision.\n\n    Examples\n    --------\n    For a 1D array, ``a.tolist()`` is almost the same as ``list(a)``,\n    except that ``tolist`` changes numpy scalars to Python scalars:\n\n    >>> a = np.uint32([1, 2])\n    >>> a_list = list(a)\n    >>> a_list\n    [1, 2]\n    >>> type(a_list[0])\n    <class 'numpy.uint32'>\n    >>> a_tolist = a.tolist()\n    >>> a_tolist\n    [1, 2]\n    >>> type(a_tolist[0])\n    <class 'int'>\n\n    Additionally, for a 2D array, ``tolist`` applies recursively:\n\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> list(a)\n    [array([1, 2]), array([3, 4])]\n    >>> a.tolist()\n    [[1, 2], [3, 4]]\n\n    The base case for this recursion is a 0D array:\n\n    >>> a = np.array(1)\n    >>> list(a)\n    Traceback (most recent call last):\n      ...\n    TypeError: iteration over a 0-d array\n    >>> a.tolist()\n    1\n    ")
             1500  CALL_FUNCTION_3       3  ''
             1502  POP_TOP          

 L.3935      1504  LOAD_NAME                add_newdoc
             1506  LOAD_STR                 'numpy.core.multiarray'
             1508  LOAD_STR                 'ndarray'
             1510  LOAD_CONST               ('tobytes', "\n    a.tobytes(order='C')\n\n    Construct Python bytes containing the raw data bytes in the array.\n\n    Constructs Python bytes showing a copy of the raw contents of\n    data memory. The bytes object can be produced in either 'C' or 'Fortran',\n    or 'Any' order (the default is 'C'-order). 'Any' order means C-order\n    unless the F_CONTIGUOUS flag in the array is set, in which case it\n    means 'Fortran' order.\n\n    .. versionadded:: 1.9.0\n\n    Parameters\n    ----------\n    order : {'C', 'F', None}, optional\n        Order of the data for multidimensional arrays:\n        C, Fortran, or the same as for the original array.\n\n    Returns\n    -------\n    s : bytes\n        Python bytes exhibiting a copy of `a`'s raw data.\n\n    Examples\n    --------\n    >>> x = np.array([[0, 1], [2, 3]], dtype='<u2')\n    >>> x.tobytes()\n    b'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n    >>> x.tobytes('C') == x.tobytes()\n    True\n    >>> x.tobytes('F')\n    b'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n    ")
             1512  CALL_FUNCTION_3       3  ''
             1514  POP_TOP          

 L.3972      1516  LOAD_NAME                add_newdoc
             1518  LOAD_STR                 'numpy.core.multiarray'
             1520  LOAD_STR                 'ndarray'
             1522  LOAD_CONST               ('tostring', "\n    a.tostring(order='C')\n\n    A compatibility alias for `tobytes`, with exactly the same behavior.\n\n    Despite its name, it returns `bytes` not `str`\\ s.\n\n    .. deprecated:: 1.19.0\n    ")
             1524  CALL_FUNCTION_3       3  ''
             1526  POP_TOP          

 L.3983      1528  LOAD_NAME                add_newdoc
             1530  LOAD_STR                 'numpy.core.multiarray'
             1532  LOAD_STR                 'ndarray'
             1534  LOAD_CONST               ('trace', '\n    a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\n\n    Return the sum along diagonals of the array.\n\n    Refer to `numpy.trace` for full documentation.\n\n    See Also\n    --------\n    numpy.trace : equivalent function\n\n    ')
             1536  CALL_FUNCTION_3       3  ''
             1538  POP_TOP          

 L.3998      1540  LOAD_NAME                add_newdoc
             1542  LOAD_STR                 'numpy.core.multiarray'
             1544  LOAD_STR                 'ndarray'
             1546  LOAD_CONST               ('transpose', '\n    a.transpose(*axes)\n\n    Returns a view of the array with axes transposed.\n\n    For a 1-D array this has no effect, as a transposed vector is simply the\n    same vector. To convert a 1-D array into a 2D column vector, an additional\n    dimension must be added. `np.atleast2d(a).T` achieves this, as does\n    `a[:, np.newaxis]`.\n    For a 2-D array, this is a standard matrix transpose.\n    For an n-D array, if axes are given, their order indicates how the\n    axes are permuted (see Examples). If axes are not provided and\n    ``a.shape = (i[0], i[1], ... i[n-2], i[n-1])``, then\n    ``a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])``.\n\n    Parameters\n    ----------\n    axes : None, tuple of ints, or `n` ints\n\n     * None or no argument: reverses the order of the axes.\n\n     * tuple of ints: `i` in the `j`-th place in the tuple means `a`\'s\n       `i`-th axis becomes `a.transpose()`\'s `j`-th axis.\n\n     * `n` ints: same as an n-tuple of the same ints (this form is\n       intended simply as a "convenience" alternative to the tuple form)\n\n    Returns\n    -------\n    out : ndarray\n        View of `a`, with axes suitably permuted.\n\n    See Also\n    --------\n    ndarray.T : Array property returning the array transposed.\n    ndarray.reshape : Give a new shape to an array without changing its data.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> a\n    array([[1, 2],\n           [3, 4]])\n    >>> a.transpose()\n    array([[1, 3],\n           [2, 4]])\n    >>> a.transpose((1, 0))\n    array([[1, 3],\n           [2, 4]])\n    >>> a.transpose(1, 0)\n    array([[1, 3],\n           [2, 4]])\n\n    ')
             1548  CALL_FUNCTION_3       3  ''
             1550  POP_TOP          

 L.4055      1552  LOAD_NAME                add_newdoc
             1554  LOAD_STR                 'numpy.core.multiarray'
             1556  LOAD_STR                 'ndarray'
             1558  LOAD_CONST               ('var', '\n    a.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)\n\n    Returns the variance of the array elements, along given axis.\n\n    Refer to `numpy.var` for full documentation.\n\n    See Also\n    --------\n    numpy.var : equivalent function\n\n    ')
             1560  CALL_FUNCTION_3       3  ''
             1562  POP_TOP          

 L.4070      1564  LOAD_NAME                add_newdoc
             1566  LOAD_STR                 'numpy.core.multiarray'
             1568  LOAD_STR                 'ndarray'
             1570  LOAD_CONST               ('view', "\n    a.view([dtype][, type])\n\n    New view of array with the same data.\n\n    .. note::\n        Passing None for ``dtype`` is different from omitting the parameter,\n        since the former invokes ``dtype(None)`` which is an alias for\n        ``dtype('float_')``.\n\n    Parameters\n    ----------\n    dtype : data-type or ndarray sub-class, optional\n        Data-type descriptor of the returned view, e.g., float32 or int16.\n        Omitting it results in the view having the same data-type as `a`.\n        This argument can also be specified as an ndarray sub-class, which\n        then specifies the type of the returned object (this is equivalent to\n        setting the ``type`` parameter).\n    type : Python type, optional\n        Type of the returned view, e.g., ndarray or matrix.  Again, omission\n        of the parameter results in type preservation.\n\n    Notes\n    -----\n    ``a.view()`` is used two different ways:\n\n    ``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view\n    of the array's memory with a different data-type.  This can cause a\n    reinterpretation of the bytes of memory.\n\n    ``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just\n    returns an instance of `ndarray_subclass` that looks at the same array\n    (same shape, dtype, etc.)  This does not cause a reinterpretation of the\n    memory.\n\n    For ``a.view(some_dtype)``, if ``some_dtype`` has a different number of\n    bytes per entry than the previous dtype (for example, converting a\n    regular array to a structured array), then the behavior of the view\n    cannot be predicted just from the superficial appearance of ``a`` (shown\n    by ``print(a)``). It also depends on exactly how ``a`` is stored in\n    memory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus\n    defined as a slice or transpose, etc., the view may give different\n    results.\n\n\n    Examples\n    --------\n    >>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n    Viewing array data using a different type and dtype:\n\n    >>> y = x.view(dtype=np.int16, type=np.matrix)\n    >>> y\n    matrix([[513]], dtype=int16)\n    >>> print(type(y))\n    <class 'numpy.matrix'>\n\n    Creating a view on a structured array so it can be used in calculations\n\n    >>> x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n    >>> xv = x.view(dtype=np.int8).reshape(-1,2)\n    >>> xv\n    array([[1, 2],\n           [3, 4]], dtype=int8)\n    >>> xv.mean(0)\n    array([2.,  3.])\n\n    Making changes to the view changes the underlying array\n\n    >>> xv[0,1] = 20\n    >>> x\n    array([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n\n    Using a view to convert an array to a recarray:\n\n    >>> z = x.view(np.recarray)\n    >>> z.a\n    array([1, 3], dtype=int8)\n\n    Views share data:\n\n    >>> x[0] = (9, 10)\n    >>> z[0]\n    (9, 10)\n\n    Views that change the dtype size (bytes per entry) should normally be\n    avoided on arrays defined by slices, transposes, fortran-ordering, etc.:\n\n    >>> x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n    >>> y = x[:, 0:2]\n    >>> y\n    array([[1, 2],\n           [4, 5]], dtype=int16)\n    >>> y.view(dtype=[('width', np.int16), ('length', np.int16)])\n    Traceback (most recent call last):\n        ...\n    ValueError: To change to a dtype of a different size, the array must be C-contiguous\n    >>> z = y.copy()\n    >>> z.view(dtype=[('width', np.int16), ('length', np.int16)])\n    array([[(1, 2)],\n           [(4, 5)]], dtype=[('width', '<i2'), ('length', '<i2')])\n    ")
             1572  CALL_FUNCTION_3       3  ''
             1574  POP_TOP          

 L.4181      1576  LOAD_NAME                add_newdoc
             1578  LOAD_STR                 'numpy.core.umath'
             1580  LOAD_STR                 'frompyfunc'

 L.4182      1582  LOAD_STR                 "\n    frompyfunc(func, nin, nout, *[, identity])\n\n    Takes an arbitrary Python function and returns a NumPy ufunc.\n\n    Can be used, for example, to add broadcasting to a built-in Python\n    function (see Examples section).\n\n    Parameters\n    ----------\n    func : Python function object\n        An arbitrary Python function.\n    nin : int\n        The number of input arguments.\n    nout : int\n        The number of objects returned by `func`.\n    identity : object, optional\n        The value to use for the `~numpy.ufunc.identity` attribute of the resulting\n        object. If specified, this is equivalent to setting the underlying\n        C ``identity`` field to ``PyUFunc_IdentityValue``.\n        If omitted, the identity is set to ``PyUFunc_None``. Note that this is\n        _not_ equivalent to setting the identity to ``None``, which implies the\n        operation is reorderable.\n\n    Returns\n    -------\n    out : ufunc\n        Returns a NumPy universal function (``ufunc``) object.\n\n    See Also\n    --------\n    vectorize : Evaluates pyfunc over input arrays using broadcasting rules of numpy.\n\n    Notes\n    -----\n    The returned ufunc always returns PyObject arrays.\n\n    Examples\n    --------\n    Use frompyfunc to add broadcasting to the Python function ``oct``:\n\n    >>> oct_array = np.frompyfunc(oct, 1, 1)\n    >>> oct_array(np.array((10, 30, 100)))\n    array(['0o12', '0o36', '0o144'], dtype=object)\n    >>> np.array((oct(10), oct(30), oct(100))) # for comparison\n    array(['0o12', '0o36', '0o144'], dtype='<U5')\n\n    "

 L.4181      1584  CALL_FUNCTION_3       3  ''
             1586  POP_TOP          

 L.4231      1588  LOAD_NAME                add_newdoc
             1590  LOAD_STR                 'numpy.core.umath'
             1592  LOAD_STR                 'geterrobj'

 L.4232      1594  LOAD_STR                 '\n    geterrobj()\n\n    Return the current object that defines floating-point error handling.\n\n    The error object contains all information that defines the error handling\n    behavior in NumPy. `geterrobj` is used internally by the other\n    functions that get and set error handling behavior (`geterr`, `seterr`,\n    `geterrcall`, `seterrcall`).\n\n    Returns\n    -------\n    errobj : list\n        The error object, a list containing three elements:\n        [internal numpy buffer size, error mask, error callback function].\n\n        The error mask is a single integer that holds the treatment information\n        on all four floating point errors. The information for each error type\n        is contained in three bits of the integer. If we print it in base 8, we\n        can see what treatment is set for "invalid", "under", "over", and\n        "divide" (in that order). The printed string can be interpreted with\n\n        * 0 : \'ignore\'\n        * 1 : \'warn\'\n        * 2 : \'raise\'\n        * 3 : \'call\'\n        * 4 : \'print\'\n        * 5 : \'log\'\n\n    See Also\n    --------\n    seterrobj, seterr, geterr, seterrcall, geterrcall\n    getbufsize, setbufsize\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> np.geterrobj()  # first get the defaults\n    [8192, 521, None]\n\n    >>> def err_handler(type, flag):\n    ...     print("Floating point error (%s), with flag %s" % (type, flag))\n    ...\n    >>> old_bufsize = np.setbufsize(20000)\n    >>> old_err = np.seterr(divide=\'raise\')\n    >>> old_handler = np.seterrcall(err_handler)\n    >>> np.geterrobj()\n    [8192, 521, <function err_handler at 0x91dcaac>]\n\n    >>> old_err = np.seterr(all=\'ignore\')\n    >>> np.base_repr(np.geterrobj()[1], 8)\n    \'0\'\n    >>> old_err = np.seterr(divide=\'warn\', over=\'log\', under=\'call\',\n    ...                     invalid=\'print\')\n    >>> np.base_repr(np.geterrobj()[1], 8)\n    \'4351\'\n\n    '

 L.4231      1596  CALL_FUNCTION_3       3  ''
             1598  POP_TOP          

 L.4295      1600  LOAD_NAME                add_newdoc
             1602  LOAD_STR                 'numpy.core.umath'
             1604  LOAD_STR                 'seterrobj'

 L.4296      1606  LOAD_STR                 '\n    seterrobj(errobj)\n\n    Set the object that defines floating-point error handling.\n\n    The error object contains all information that defines the error handling\n    behavior in NumPy. `seterrobj` is used internally by the other\n    functions that set error handling behavior (`seterr`, `seterrcall`).\n\n    Parameters\n    ----------\n    errobj : list\n        The error object, a list containing three elements:\n        [internal numpy buffer size, error mask, error callback function].\n\n        The error mask is a single integer that holds the treatment information\n        on all four floating point errors. The information for each error type\n        is contained in three bits of the integer. If we print it in base 8, we\n        can see what treatment is set for "invalid", "under", "over", and\n        "divide" (in that order). The printed string can be interpreted with\n\n        * 0 : \'ignore\'\n        * 1 : \'warn\'\n        * 2 : \'raise\'\n        * 3 : \'call\'\n        * 4 : \'print\'\n        * 5 : \'log\'\n\n    See Also\n    --------\n    geterrobj, seterr, geterr, seterrcall, geterrcall\n    getbufsize, setbufsize\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> old_errobj = np.geterrobj()  # first get the defaults\n    >>> old_errobj\n    [8192, 521, None]\n\n    >>> def err_handler(type, flag):\n    ...     print("Floating point error (%s), with flag %s" % (type, flag))\n    ...\n    >>> new_errobj = [20000, 12, err_handler]\n    >>> np.seterrobj(new_errobj)\n    >>> np.base_repr(12, 8)  # int for divide=4 (\'print\') and over=1 (\'warn\')\n    \'14\'\n    >>> np.geterr()\n    {\'over\': \'warn\', \'divide\': \'print\', \'invalid\': \'ignore\', \'under\': \'ignore\'}\n    >>> np.geterrcall() is err_handler\n    True\n\n    '

 L.4295      1608  CALL_FUNCTION_3       3  ''
             1610  POP_TOP          

 L.4361      1612  LOAD_NAME                add_newdoc
             1614  LOAD_STR                 'numpy.core.multiarray'
             1616  LOAD_STR                 'add_docstring'

 L.4362      1618  LOAD_STR                 '\n    add_docstring(obj, docstring)\n\n    Add a docstring to a built-in obj if possible.\n    If the obj already has a docstring raise a RuntimeError\n    If this routine does not know how to add a docstring to the object\n    raise a TypeError\n    '

 L.4361      1620  CALL_FUNCTION_3       3  ''
             1622  POP_TOP          

 L.4371      1624  LOAD_NAME                add_newdoc
             1626  LOAD_STR                 'numpy.core.umath'
             1628  LOAD_STR                 '_add_newdoc_ufunc'

 L.4372      1630  LOAD_STR                 '\n    add_ufunc_docstring(ufunc, new_docstring)\n\n    Replace the docstring for a ufunc with new_docstring.\n    This method will only work if the current docstring for\n    the ufunc is NULL. (At the C level, i.e. when ufunc->doc is NULL.)\n\n    Parameters\n    ----------\n    ufunc : numpy.ufunc\n        A ufunc whose current doc is NULL.\n    new_docstring : string\n        The new docstring for the ufunc.\n\n    Notes\n    -----\n    This method allocates memory for new_docstring on\n    the heap. Technically this creates a mempory leak, since this\n    memory will not be reclaimed until the end of the program\n    even if the ufunc itself is removed. However this will only\n    be a problem if the user is repeatedly creating ufuncs with\n    no documentation, adding documentation via add_newdoc_ufunc,\n    and then throwing away the ufunc.\n    '

 L.4371      1632  CALL_FUNCTION_3       3  ''
             1634  POP_TOP          

 L.4397      1636  LOAD_NAME                add_newdoc
             1638  LOAD_STR                 'numpy.core.multiarray'
             1640  LOAD_STR                 '_set_madvise_hugepage'

 L.4398      1642  LOAD_STR                 '\n    _set_madvise_hugepage(enabled: bool) -> bool\n\n    Set  or unset use of ``madvise (2)`` MADV_HUGEPAGE support when\n    allocating the array data. Returns the previously set value.\n    See `global_state` for more information.\n    '

 L.4397      1644  CALL_FUNCTION_3       3  ''
             1646  POP_TOP          

 L.4406      1648  LOAD_NAME                add_newdoc
             1650  LOAD_STR                 'numpy.core._multiarray_tests'
             1652  LOAD_STR                 'format_float_OSprintf_g'

 L.4407      1654  LOAD_STR                 '\n    format_float_OSprintf_g(val, precision)\n\n    Print a floating point scalar using the system\'s printf function,\n    equivalent to:\n\n        printf("%.*g", precision, val);\n\n    for half/float/double, or replacing \'g\' by \'Lg\' for longdouble. This\n    method is designed to help cross-validate the format_float_* methods.\n\n    Parameters\n    ----------\n    val : python float or numpy floating scalar\n        Value to format.\n\n    precision : non-negative integer, optional\n        Precision given to printf.\n\n    Returns\n    -------\n    rep : string\n        The string representation of the floating point value\n\n    See Also\n    --------\n    format_float_scientific\n    format_float_positional\n    '

 L.4406      1656  CALL_FUNCTION_3       3  ''
             1658  POP_TOP          

 L.4451      1660  LOAD_NAME                add_newdoc
             1662  LOAD_STR                 'numpy.core'
             1664  LOAD_STR                 'ufunc'

 L.4452      1666  LOAD_STR                 "\n    Functions that operate element by element on whole arrays.\n\n    To see the documentation for a specific ufunc, use `info`.  For\n    example, ``np.info(np.sin)``.  Because ufuncs are written in C\n    (for speed) and linked into Python with NumPy's ufunc facility,\n    Python's help() function finds this page whenever help() is called\n    on a ufunc.\n\n    A detailed explanation of ufuncs can be found in the docs for :ref:`ufuncs`.\n\n    Calling ufuncs:\n    ===============\n\n    op(*x[, out], where=True, **kwargs)\n    Apply `op` to the arguments `*x` elementwise, broadcasting the arguments.\n\n    The broadcasting rules are:\n\n    * Dimensions of length 1 may be prepended to either array.\n    * Arrays may be repeated along dimensions of length 1.\n\n    Parameters\n    ----------\n    *x : array_like\n        Input arrays.\n    out : ndarray, None, or tuple of ndarray and None, optional\n        Alternate array object(s) in which to put the result; if provided, it\n        must have a shape that the inputs broadcast to. A tuple of arrays\n        (possible only as a keyword argument) must have length equal to the\n        number of outputs; use None for uninitialized outputs to be\n        allocated by the ufunc.\n    where : array_like, optional\n        This condition is broadcast over the input. At locations where the\n        condition is True, the `out` array will be set to the ufunc result.\n        Elsewhere, the `out` array will retain its original value.\n        Note that if an uninitialized `out` array is created via the default\n        ``out=None``, locations within it where the condition is False will\n        remain uninitialized.\n    **kwargs\n        For other keyword-only arguments, see the :ref:`ufunc docs <ufuncs.kwargs>`.\n\n    Returns\n    -------\n    r : ndarray or tuple of ndarray\n        `r` will have the shape that the arrays in `x` broadcast to; if `out` is\n        provided, it will be returned. If not, `r` will be allocated and\n        may contain uninitialized values. If the function has more than one\n        output, then the result will be a tuple of arrays.\n\n    "

 L.4451      1668  CALL_FUNCTION_3       3  ''
             1670  POP_TOP          

 L.4511      1672  LOAD_NAME                add_newdoc
             1674  LOAD_STR                 'numpy.core'
             1676  LOAD_STR                 'ufunc'
             1678  LOAD_CONST               ('identity', '\n    The identity value.\n\n    Data attribute containing the identity element for the ufunc, if it has one.\n    If it does not, the attribute value is None.\n\n    Examples\n    --------\n    >>> np.add.identity\n    0\n    >>> np.multiply.identity\n    1\n    >>> np.power.identity\n    1\n    >>> print(np.exp.identity)\n    None\n    ')
             1680  CALL_FUNCTION_3       3  ''
             1682  POP_TOP          

 L.4530      1684  LOAD_NAME                add_newdoc
             1686  LOAD_STR                 'numpy.core'
             1688  LOAD_STR                 'ufunc'
             1690  LOAD_CONST               ('nargs', '\n    The number of arguments.\n\n    Data attribute containing the number of arguments the ufunc takes, including\n    optional ones.\n\n    Notes\n    -----\n    Typically this value will be one more than what you might expect because all\n    ufuncs take  the optional "out" argument.\n\n    Examples\n    --------\n    >>> np.add.nargs\n    3\n    >>> np.multiply.nargs\n    3\n    >>> np.power.nargs\n    3\n    >>> np.exp.nargs\n    2\n    ')
             1692  CALL_FUNCTION_3       3  ''
             1694  POP_TOP          

 L.4554      1696  LOAD_NAME                add_newdoc
             1698  LOAD_STR                 'numpy.core'
             1700  LOAD_STR                 'ufunc'
             1702  LOAD_CONST               ('nin', '\n    The number of inputs.\n\n    Data attribute containing the number of arguments the ufunc treats as input.\n\n    Examples\n    --------\n    >>> np.add.nin\n    2\n    >>> np.multiply.nin\n    2\n    >>> np.power.nin\n    2\n    >>> np.exp.nin\n    1\n    ')
             1704  CALL_FUNCTION_3       3  ''
             1706  POP_TOP          

 L.4572      1708  LOAD_NAME                add_newdoc
             1710  LOAD_STR                 'numpy.core'
             1712  LOAD_STR                 'ufunc'
             1714  LOAD_CONST               ('nout', '\n    The number of outputs.\n\n    Data attribute containing the number of arguments the ufunc treats as output.\n\n    Notes\n    -----\n    Since all ufuncs can take output arguments, this will always be (at least) 1.\n\n    Examples\n    --------\n    >>> np.add.nout\n    1\n    >>> np.multiply.nout\n    1\n    >>> np.power.nout\n    1\n    >>> np.exp.nout\n    1\n\n    ')
             1716  CALL_FUNCTION_3       3  ''
             1718  POP_TOP          

 L.4595      1720  LOAD_NAME                add_newdoc
             1722  LOAD_STR                 'numpy.core'
             1724  LOAD_STR                 'ufunc'
             1726  LOAD_CONST               ('ntypes', '\n    The number of types.\n\n    The number of numerical NumPy types - of which there are 18 total - on which\n    the ufunc can operate.\n\n    See Also\n    --------\n    numpy.ufunc.types\n\n    Examples\n    --------\n    >>> np.add.ntypes\n    18\n    >>> np.multiply.ntypes\n    18\n    >>> np.power.ntypes\n    17\n    >>> np.exp.ntypes\n    7\n    >>> np.remainder.ntypes\n    14\n\n    ')
             1728  CALL_FUNCTION_3       3  ''
             1730  POP_TOP          

 L.4621      1732  LOAD_NAME                add_newdoc
             1734  LOAD_STR                 'numpy.core'
             1736  LOAD_STR                 'ufunc'
             1738  LOAD_CONST               ('types', '\n    Returns a list with types grouped input->output.\n\n    Data attribute listing the data-type "Domain-Range" groupings the ufunc can\n    deliver. The data-types are given using the character codes.\n\n    See Also\n    --------\n    numpy.ufunc.ntypes\n\n    Examples\n    --------\n    >>> np.add.types\n    [\'??->?\', \'bb->b\', \'BB->B\', \'hh->h\', \'HH->H\', \'ii->i\', \'II->I\', \'ll->l\',\n    \'LL->L\', \'qq->q\', \'QQ->Q\', \'ff->f\', \'dd->d\', \'gg->g\', \'FF->F\', \'DD->D\',\n    \'GG->G\', \'OO->O\']\n\n    >>> np.multiply.types\n    [\'??->?\', \'bb->b\', \'BB->B\', \'hh->h\', \'HH->H\', \'ii->i\', \'II->I\', \'ll->l\',\n    \'LL->L\', \'qq->q\', \'QQ->Q\', \'ff->f\', \'dd->d\', \'gg->g\', \'FF->F\', \'DD->D\',\n    \'GG->G\', \'OO->O\']\n\n    >>> np.power.types\n    [\'bb->b\', \'BB->B\', \'hh->h\', \'HH->H\', \'ii->i\', \'II->I\', \'ll->l\', \'LL->L\',\n    \'qq->q\', \'QQ->Q\', \'ff->f\', \'dd->d\', \'gg->g\', \'FF->F\', \'DD->D\', \'GG->G\',\n    \'OO->O\']\n\n    >>> np.exp.types\n    [\'f->f\', \'d->d\', \'g->g\', \'F->F\', \'D->D\', \'G->G\', \'O->O\']\n\n    >>> np.remainder.types\n    [\'bb->b\', \'BB->B\', \'hh->h\', \'HH->H\', \'ii->i\', \'II->I\', \'ll->l\', \'LL->L\',\n    \'qq->q\', \'QQ->Q\', \'ff->f\', \'dd->d\', \'gg->g\', \'OO->O\']\n\n    ')
             1740  CALL_FUNCTION_3       3  ''
             1742  POP_TOP          

 L.4658      1744  LOAD_NAME                add_newdoc
             1746  LOAD_STR                 'numpy.core'
             1748  LOAD_STR                 'ufunc'
             1750  LOAD_CONST               ('signature', "\n    Definition of the core elements a generalized ufunc operates on.\n\n    The signature determines how the dimensions of each input/output array\n    are split into core and loop dimensions:\n\n    1. Each dimension in the signature is matched to a dimension of the\n       corresponding passed-in array, starting from the end of the shape tuple.\n    2. Core dimensions assigned to the same label in the signature must have\n       exactly matching sizes, no broadcasting is performed.\n    3. The core dimensions are removed from all inputs and the remaining\n       dimensions are broadcast together, defining the loop dimensions.\n\n    Notes\n    -----\n    Generalized ufuncs are used internally in many linalg functions, and in\n    the testing suite; the examples below are taken from these.\n    For ufuncs that operate on scalars, the signature is None, which is\n    equivalent to '()' for every argument.\n\n    Examples\n    --------\n    >>> np.core.umath_tests.matrix_multiply.signature\n    '(m,n),(n,p)->(m,p)'\n    >>> np.linalg._umath_linalg.det.signature\n    '(m,m)->()'\n    >>> np.add.signature is None\n    True  # equivalent to '(),()->()'\n    ")
             1752  CALL_FUNCTION_3       3  ''
             1754  POP_TOP          

 L.4695      1756  LOAD_NAME                add_newdoc
             1758  LOAD_STR                 'numpy.core'
             1760  LOAD_STR                 'ufunc'
             1762  LOAD_CONST               ('reduce', "\n    reduce(a, axis=0, dtype=None, out=None, keepdims=False, initial=<no value>, where=True)\n\n    Reduces `a`'s dimension by one, by applying ufunc along one axis.\n\n    Let :math:`a.shape = (N_0, ..., N_i, ..., N_{M-1})`.  Then\n    :math:`ufunc.reduce(a, axis=i)[k_0, ..,k_{i-1}, k_{i+1}, .., k_{M-1}]` =\n    the result of iterating `j` over :math:`range(N_i)`, cumulatively applying\n    ufunc to each :math:`a[k_0, ..,k_{i-1}, j, k_{i+1}, .., k_{M-1}]`.\n    For a one-dimensional array, reduce produces results equivalent to:\n    ::\n\n     r = op.identity # op = ufunc\n     for i in range(len(A)):\n       r = op(r, A[i])\n     return r\n\n    For example, add.reduce() is equivalent to sum().\n\n    Parameters\n    ----------\n    a : array_like\n        The array to act on.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which a reduction is performed.\n        The default (`axis` = 0) is perform a reduction over the first\n        dimension of the input array. `axis` may be negative, in\n        which case it counts from the last to the first axis.\n\n        .. versionadded:: 1.7.0\n\n        If this is None, a reduction is performed over all the axes.\n        If this is a tuple of ints, a reduction is performed on multiple\n        axes, instead of a single axis or all the axes as before.\n\n        For operations which are either not commutative or not associative,\n        doing a reduction over multiple axes is not well-defined. The\n        ufuncs do not currently raise an exception in this case, but will\n        likely do so in the future.\n    dtype : data-type code, optional\n        The type used to represent the intermediate results. Defaults\n        to the data-type of the output array if this is provided, or\n        the data-type of the input array if no output array is provided.\n    out : ndarray, None, or tuple of ndarray and None, optional\n        A location into which the result is stored. If not provided or None,\n        a freshly-allocated array is returned. For consistency with\n        ``ufunc.__call__``, if given as a keyword, this may be wrapped in a\n        1-element tuple.\n\n        .. versionchanged:: 1.13.0\n           Tuples are allowed for keyword argument.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `arr`.\n\n        .. versionadded:: 1.7.0\n    initial : scalar, optional\n        The value with which to start the reduction.\n        If the ufunc has no identity or the dtype is object, this defaults\n        to None - otherwise it defaults to ufunc.identity.\n        If ``None`` is given, the first element of the reduction is used,\n        and an error is thrown if the reduction is empty.\n\n        .. versionadded:: 1.15.0\n\n    where : array_like of bool, optional\n        A boolean array which is broadcasted to match the dimensions\n        of `a`, and selects elements to include in the reduction. Note\n        that for ufuncs like ``minimum`` that do not have an identity\n        defined, one has to pass in also ``initial``.\n\n        .. versionadded:: 1.17.0\n\n    Returns\n    -------\n    r : ndarray\n        The reduced array. If `out` was supplied, `r` is a reference to it.\n\n    Examples\n    --------\n    >>> np.multiply.reduce([2,3,5])\n    30\n\n    A multi-dimensional array example:\n\n    >>> X = np.arange(8).reshape((2,2,2))\n    >>> X\n    array([[[0, 1],\n            [2, 3]],\n           [[4, 5],\n            [6, 7]]])\n    >>> np.add.reduce(X, 0)\n    array([[ 4,  6],\n           [ 8, 10]])\n    >>> np.add.reduce(X) # confirm: default axis value is 0\n    array([[ 4,  6],\n           [ 8, 10]])\n    >>> np.add.reduce(X, 1)\n    array([[ 2,  4],\n           [10, 12]])\n    >>> np.add.reduce(X, 2)\n    array([[ 1,  5],\n           [ 9, 13]])\n\n    You can use the ``initial`` keyword argument to initialize the reduction\n    with a different value, and ``where`` to select specific elements to include:\n\n    >>> np.add.reduce([10], initial=5)\n    15\n    >>> np.add.reduce(np.ones((2, 2, 2)), axis=(0, 2), initial=10)\n    array([14., 14.])\n    >>> a = np.array([10., np.nan, 10])\n    >>> np.add.reduce(a, where=~np.isnan(a))\n    20.0\n\n    Allows reductions of empty arrays where they would normally fail, i.e.\n    for ufuncs without an identity.\n\n    >>> np.minimum.reduce([], initial=np.inf)\n    inf\n    >>> np.minimum.reduce([[1., 2.], [3., 4.]], initial=10., where=[True, False])\n    array([ 1., 10.])\n    >>> np.minimum.reduce([])\n    Traceback (most recent call last):\n        ...\n    ValueError: zero-size array to reduction operation minimum which has no identity\n    ")
             1764  CALL_FUNCTION_3       3  ''
             1766  POP_TOP          

 L.4825      1768  LOAD_NAME                add_newdoc
             1770  LOAD_STR                 'numpy.core'
             1772  LOAD_STR                 'ufunc'
             1774  LOAD_CONST               ('accumulate', "\n    accumulate(array, axis=0, dtype=None, out=None)\n\n    Accumulate the result of applying the operator to all elements.\n\n    For a one-dimensional array, accumulate produces results equivalent to::\n\n      r = np.empty(len(A))\n      t = op.identity        # op = the ufunc being applied to A's  elements\n      for i in range(len(A)):\n          t = op(t, A[i])\n          r[i] = t\n      return r\n\n    For example, add.accumulate() is equivalent to np.cumsum().\n\n    For a multi-dimensional array, accumulate is applied along only one\n    axis (axis zero by default; see Examples below) so repeated use is\n    necessary if one wants to accumulate over multiple axes.\n\n    Parameters\n    ----------\n    array : array_like\n        The array to act on.\n    axis : int, optional\n        The axis along which to apply the accumulation; default is zero.\n    dtype : data-type code, optional\n        The data-type used to represent the intermediate results. Defaults\n        to the data-type of the output array if such is provided, or the\n        the data-type of the input array if no output array is provided.\n    out : ndarray, None, or tuple of ndarray and None, optional\n        A location into which the result is stored. If not provided or None,\n        a freshly-allocated array is returned. For consistency with\n        ``ufunc.__call__``, if given as a keyword, this may be wrapped in a\n        1-element tuple.\n\n        .. versionchanged:: 1.13.0\n           Tuples are allowed for keyword argument.\n\n    Returns\n    -------\n    r : ndarray\n        The accumulated values. If `out` was supplied, `r` is a reference to\n        `out`.\n\n    Examples\n    --------\n    1-D array examples:\n\n    >>> np.add.accumulate([2, 3, 5])\n    array([ 2,  5, 10])\n    >>> np.multiply.accumulate([2, 3, 5])\n    array([ 2,  6, 30])\n\n    2-D array examples:\n\n    >>> I = np.eye(2)\n    >>> I\n    array([[1.,  0.],\n           [0.,  1.]])\n\n    Accumulate along axis 0 (rows), down columns:\n\n    >>> np.add.accumulate(I, 0)\n    array([[1.,  0.],\n           [1.,  1.]])\n    >>> np.add.accumulate(I) # no axis specified = axis zero\n    array([[1.,  0.],\n           [1.,  1.]])\n\n    Accumulate along axis 1 (columns), through rows:\n\n    >>> np.add.accumulate(I, 1)\n    array([[1.,  1.],\n           [0.,  1.]])\n\n    ")
             1776  CALL_FUNCTION_3       3  ''
             1778  POP_TOP          

 L.4904      1780  LOAD_NAME                add_newdoc
             1782  LOAD_STR                 'numpy.core'
             1784  LOAD_STR                 'ufunc'
             1786  LOAD_CONST               ('reduceat', '\n    reduceat(a, indices, axis=0, dtype=None, out=None)\n\n    Performs a (local) reduce with specified slices over a single axis.\n\n    For i in ``range(len(indices))``, `reduceat` computes\n    ``ufunc.reduce(a[indices[i]:indices[i+1]])``, which becomes the i-th\n    generalized "row" parallel to `axis` in the final result (i.e., in a\n    2-D array, for example, if `axis = 0`, it becomes the i-th row, but if\n    `axis = 1`, it becomes the i-th column).  There are three exceptions to this:\n\n    * when ``i = len(indices) - 1`` (so for the last index),\n      ``indices[i+1] = a.shape[axis]``.\n    * if ``indices[i] >= indices[i + 1]``, the i-th generalized "row" is\n      simply ``a[indices[i]]``.\n    * if ``indices[i] >= len(a)`` or ``indices[i] < 0``, an error is raised.\n\n    The shape of the output depends on the size of `indices`, and may be\n    larger than `a` (this happens if ``len(indices) > a.shape[axis]``).\n\n    Parameters\n    ----------\n    a : array_like\n        The array to act on.\n    indices : array_like\n        Paired indices, comma separated (not colon), specifying slices to\n        reduce.\n    axis : int, optional\n        The axis along which to apply the reduceat.\n    dtype : data-type code, optional\n        The type used to represent the intermediate results. Defaults\n        to the data type of the output array if this is provided, or\n        the data type of the input array if no output array is provided.\n    out : ndarray, None, or tuple of ndarray and None, optional\n        A location into which the result is stored. If not provided or None,\n        a freshly-allocated array is returned. For consistency with\n        ``ufunc.__call__``, if given as a keyword, this may be wrapped in a\n        1-element tuple.\n\n        .. versionchanged:: 1.13.0\n           Tuples are allowed for keyword argument.\n\n    Returns\n    -------\n    r : ndarray\n        The reduced values. If `out` was supplied, `r` is a reference to\n        `out`.\n\n    Notes\n    -----\n    A descriptive example:\n\n    If `a` is 1-D, the function `ufunc.accumulate(a)` is the same as\n    ``ufunc.reduceat(a, indices)[::2]`` where `indices` is\n    ``range(len(array) - 1)`` with a zero placed\n    in every other element:\n    ``indices = zeros(2 * len(a) - 1)``, ``indices[1::2] = range(1, len(a))``.\n\n    Don\'t be fooled by this attribute\'s name: `reduceat(a)` is not\n    necessarily smaller than `a`.\n\n    Examples\n    --------\n    To take the running sum of four successive values:\n\n    >>> np.add.reduceat(np.arange(8),[0,4, 1,5, 2,6, 3,7])[::2]\n    array([ 6, 10, 14, 18])\n\n    A 2-D example:\n\n    >>> x = np.linspace(0, 15, 16).reshape(4,4)\n    >>> x\n    array([[ 0.,   1.,   2.,   3.],\n           [ 4.,   5.,   6.,   7.],\n           [ 8.,   9.,  10.,  11.],\n           [12.,  13.,  14.,  15.]])\n\n    ::\n\n     # reduce such that the result has the following five rows:\n     # [row1 + row2 + row3]\n     # [row4]\n     # [row2]\n     # [row3]\n     # [row1 + row2 + row3 + row4]\n\n    >>> np.add.reduceat(x, [0, 3, 1, 2, 0])\n    array([[12.,  15.,  18.,  21.],\n           [12.,  13.,  14.,  15.],\n           [ 4.,   5.,   6.,   7.],\n           [ 8.,   9.,  10.,  11.],\n           [24.,  28.,  32.,  36.]])\n\n    ::\n\n     # reduce such that result has the following two columns:\n     # [col1 * col2 * col3, col4]\n\n    >>> np.multiply.reduceat(x, [0, 3], 1)\n    array([[   0.,     3.],\n           [ 120.,     7.],\n           [ 720.,    11.],\n           [2184.,    15.]])\n\n    ')
             1788  CALL_FUNCTION_3       3  ''
             1790  POP_TOP          

 L.5011      1792  LOAD_NAME                add_newdoc
             1794  LOAD_STR                 'numpy.core'
             1796  LOAD_STR                 'ufunc'
             1798  LOAD_CONST               ('outer', '\n    outer(A, B, **kwargs)\n\n    Apply the ufunc `op` to all pairs (a, b) with a in `A` and b in `B`.\n\n    Let ``M = A.ndim``, ``N = B.ndim``. Then the result, `C`, of\n    ``op.outer(A, B)`` is an array of dimension M + N such that:\n\n    .. math:: C[i_0, ..., i_{M-1}, j_0, ..., j_{N-1}] =\n       op(A[i_0, ..., i_{M-1}], B[j_0, ..., j_{N-1}])\n\n    For `A` and `B` one-dimensional, this is equivalent to::\n\n      r = empty(len(A),len(B))\n      for i in range(len(A)):\n          for j in range(len(B)):\n              r[i,j] = op(A[i], B[j]) # op = ufunc in question\n\n    Parameters\n    ----------\n    A : array_like\n        First array\n    B : array_like\n        Second array\n    kwargs : any\n        Arguments to pass on to the ufunc. Typically `dtype` or `out`.\n\n    Returns\n    -------\n    r : ndarray\n        Output array\n\n    See Also\n    --------\n    numpy.outer : A less powerful version of ``np.multiply.outer``\n                  that `ravel`\\ s all inputs to 1D. This exists\n                  primarily for compatibility with old code.\n\n    tensordot : ``np.tensordot(a, b, axes=((), ()))`` and\n                ``np.multiply.outer(a, b)`` behave same for all\n                dimensions of a and b.\n\n    Examples\n    --------\n    >>> np.multiply.outer([1, 2, 3], [4, 5, 6])\n    array([[ 4,  5,  6],\n           [ 8, 10, 12],\n           [12, 15, 18]])\n\n    A multi-dimensional example:\n\n    >>> A = np.array([[1, 2, 3], [4, 5, 6]])\n    >>> A.shape\n    (2, 3)\n    >>> B = np.array([[1, 2, 3, 4]])\n    >>> B.shape\n    (1, 4)\n    >>> C = np.multiply.outer(A, B)\n    >>> C.shape; C\n    (2, 3, 1, 4)\n    array([[[[ 1,  2,  3,  4]],\n            [[ 2,  4,  6,  8]],\n            [[ 3,  6,  9, 12]]],\n           [[[ 4,  8, 12, 16]],\n            [[ 5, 10, 15, 20]],\n            [[ 6, 12, 18, 24]]]])\n\n    ')
             1800  CALL_FUNCTION_3       3  ''
             1802  POP_TOP          

 L.5081      1804  LOAD_NAME                add_newdoc
             1806  LOAD_STR                 'numpy.core'
             1808  LOAD_STR                 'ufunc'
             1810  LOAD_CONST               ('at', "\n    at(a, indices, b=None)\n\n    Performs unbuffered in place operation on operand 'a' for elements\n    specified by 'indices'. For addition ufunc, this method is equivalent to\n    ``a[indices] += b``, except that results are accumulated for elements that\n    are indexed more than once. For example, ``a[[0,0]] += 1`` will only\n    increment the first element once because of buffering, whereas\n    ``add.at(a, [0,0], 1)`` will increment the first element twice.\n\n    .. versionadded:: 1.8.0\n\n    Parameters\n    ----------\n    a : array_like\n        The array to perform in place operation on.\n    indices : array_like or tuple\n        Array like index object or slice object for indexing into first\n        operand. If first operand has multiple dimensions, indices can be a\n        tuple of array like index objects or slice objects.\n    b : array_like\n        Second operand for ufuncs requiring two operands. Operand must be\n        broadcastable over first operand after indexing or slicing.\n\n    Examples\n    --------\n    Set items 0 and 1 to their negative values:\n\n    >>> a = np.array([1, 2, 3, 4])\n    >>> np.negative.at(a, [0, 1])\n    >>> a\n    array([-1, -2,  3,  4])\n\n    Increment items 0 and 1, and increment item 2 twice:\n\n    >>> a = np.array([1, 2, 3, 4])\n    >>> np.add.at(a, [0, 1, 2, 2], 1)\n    >>> a\n    array([2, 3, 5, 4])\n\n    Add items 0 and 1 in first array to second array,\n    and store results in first array:\n\n    >>> a = np.array([1, 2, 3, 4])\n    >>> b = np.array([1, 2])\n    >>> np.add.at(a, [0, 1], b)\n    >>> a\n    array([2, 4, 3, 4])\n\n    ")
             1812  CALL_FUNCTION_3       3  ''
             1814  POP_TOP          

 L.5145      1816  LOAD_NAME                add_newdoc
             1818  LOAD_STR                 'numpy.core.multiarray'
             1820  LOAD_STR                 'dtype'

 L.5146      1822  LOAD_STR                 '\n    dtype(obj, align=False, copy=False)\n\n    Create a data type object.\n\n    A numpy array is homogeneous, and contains elements described by a\n    dtype object. A dtype object can be constructed from different\n    combinations of fundamental numeric types.\n\n    Parameters\n    ----------\n    obj\n        Object to be converted to a data type object.\n    align : bool, optional\n        Add padding to the fields to match what a C compiler would output\n        for a similar C-struct. Can be ``True`` only if `obj` is a dictionary\n        or a comma-separated string. If a struct dtype is being created,\n        this also sets a sticky alignment flag ``isalignedstruct``.\n    copy : bool, optional\n        Make a new copy of the data-type object. If ``False``, the result\n        may just be a reference to a built-in data-type object.\n\n    See also\n    --------\n    result_type\n\n    Examples\n    --------\n    Using array-scalar type:\n\n    >>> np.dtype(np.int16)\n    dtype(\'int16\')\n\n    Structured type, one field name \'f1\', containing int16:\n\n    >>> np.dtype([(\'f1\', np.int16)])\n    dtype([(\'f1\', \'<i2\')])\n\n    Structured type, one field named \'f1\', in itself containing a structured\n    type with one field:\n\n    >>> np.dtype([(\'f1\', [(\'f1\', np.int16)])])\n    dtype([(\'f1\', [(\'f1\', \'<i2\')])])\n\n    Structured type, two fields: the first field contains an unsigned int, the\n    second an int32:\n\n    >>> np.dtype([(\'f1\', np.uint64), (\'f2\', np.int32)])\n    dtype([(\'f1\', \'<u8\'), (\'f2\', \'<i4\')])\n\n    Using array-protocol type strings:\n\n    >>> np.dtype([(\'a\',\'f8\'),(\'b\',\'S10\')])\n    dtype([(\'a\', \'<f8\'), (\'b\', \'S10\')])\n\n    Using comma-separated field formats.  The shape is (2,3):\n\n    >>> np.dtype("i4, (2,3)f8")\n    dtype([(\'f0\', \'<i4\'), (\'f1\', \'<f8\', (2, 3))])\n\n    Using tuples.  ``int`` is a fixed type, 3 the field\'s shape.  ``void``\n    is a flexible type, here of size 10:\n\n    >>> np.dtype([(\'hello\',(np.int64,3)),(\'world\',np.void,10)])\n    dtype([(\'hello\', \'<i8\', (3,)), (\'world\', \'V10\')])\n\n    Subdivide ``int16`` into 2 ``int8``\'s, called x and y.  0 and 1 are\n    the offsets in bytes:\n\n    >>> np.dtype((np.int16, {\'x\':(np.int8,0), \'y\':(np.int8,1)}))\n    dtype((numpy.int16, [(\'x\', \'i1\'), (\'y\', \'i1\')]))\n\n    Using dictionaries.  Two fields named \'gender\' and \'age\':\n\n    >>> np.dtype({\'names\':[\'gender\',\'age\'], \'formats\':[\'S1\',np.uint8]})\n    dtype([(\'gender\', \'S1\'), (\'age\', \'u1\')])\n\n    Offsets in bytes, here 0 and 25:\n\n    >>> np.dtype({\'surname\':(\'S25\',0),\'age\':(np.uint8,25)})\n    dtype([(\'surname\', \'S25\'), (\'age\', \'u1\')])\n\n    '

 L.5145      1824  CALL_FUNCTION_3       3  ''
             1826  POP_TOP          

 L.5236      1828  LOAD_NAME                add_newdoc
             1830  LOAD_STR                 'numpy.core.multiarray'
             1832  LOAD_STR                 'dtype'
             1834  LOAD_CONST               ('alignment', "\n    The required alignment (bytes) of this data-type according to the compiler.\n\n    More information is available in the C-API section of the manual.\n\n    Examples\n    --------\n\n    >>> x = np.dtype('i4')\n    >>> x.alignment\n    4\n\n    >>> x = np.dtype(float)\n    >>> x.alignment\n    8\n\n    ")
             1836  CALL_FUNCTION_3       3  ''
             1838  POP_TOP          

 L.5255      1840  LOAD_NAME                add_newdoc
             1842  LOAD_STR                 'numpy.core.multiarray'
             1844  LOAD_STR                 'dtype'
             1846  LOAD_CONST               ('byteorder', "\n    A character indicating the byte-order of this data-type object.\n\n    One of:\n\n    ===  ==============\n    '='  native\n    '<'  little-endian\n    '>'  big-endian\n    '|'  not applicable\n    ===  ==============\n\n    All built-in data-type objects have byteorder either '=' or '|'.\n\n    Examples\n    --------\n\n    >>> dt = np.dtype('i2')\n    >>> dt.byteorder\n    '='\n    >>> # endian is not relevant for 8 bit numbers\n    >>> np.dtype('i1').byteorder\n    '|'\n    >>> # or ASCII strings\n    >>> np.dtype('S2').byteorder\n    '|'\n    >>> # Even if specific code is given, and it is native\n    >>> # '=' is the byteorder\n    >>> import sys\n    >>> sys_is_le = sys.byteorder == 'little'\n    >>> native_code = sys_is_le and '<' or '>'\n    >>> swapped_code = sys_is_le and '>' or '<'\n    >>> dt = np.dtype(native_code + 'i2')\n    >>> dt.byteorder\n    '='\n    >>> # Swapped code shows up as itself\n    >>> dt = np.dtype(swapped_code + 'i2')\n    >>> dt.byteorder == swapped_code\n    True\n\n    ")
             1848  CALL_FUNCTION_3       3  ''
             1850  POP_TOP          

 L.5298      1852  LOAD_NAME                add_newdoc
             1854  LOAD_STR                 'numpy.core.multiarray'
             1856  LOAD_STR                 'dtype'
             1858  LOAD_CONST               ('char', "A unique character code for each of the 21 different built-in types.\n\n    Examples\n    --------\n\n    >>> x = np.dtype(float)\n    >>> x.char\n    'd'\n\n    ")
             1860  CALL_FUNCTION_3       3  ''
             1862  POP_TOP          

 L.5310      1864  LOAD_NAME                add_newdoc
             1866  LOAD_STR                 'numpy.core.multiarray'
             1868  LOAD_STR                 'dtype'
             1870  LOAD_CONST               ('descr', "\n    `__array_interface__` description of the data-type.\n\n    The format is that required by the 'descr' key in the\n    `__array_interface__` attribute.\n\n    Warning: This attribute exists specifically for `__array_interface__`,\n    and passing it directly to `np.dtype` will not accurately reconstruct\n    some dtypes (e.g., scalar and subarray dtypes).\n\n    Examples\n    --------\n\n    >>> x = np.dtype(float)\n    >>> x.descr\n    [('', '<f8')]\n\n    >>> dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n    >>> dt.descr\n    [('name', '<U16'), ('grades', '<f8', (2,))]\n\n    ")
             1872  CALL_FUNCTION_3       3  ''
             1874  POP_TOP          

 L.5334      1876  LOAD_NAME                add_newdoc
             1878  LOAD_STR                 'numpy.core.multiarray'
             1880  LOAD_STR                 'dtype'
             1882  LOAD_CONST               ('fields', "\n    Dictionary of named fields defined for this data type, or ``None``.\n\n    The dictionary is indexed by keys that are the names of the fields.\n    Each entry in the dictionary is a tuple fully describing the field::\n\n      (dtype, offset[, title])\n\n    Offset is limited to C int, which is signed and usually 32 bits.\n    If present, the optional title can be any object (if it is a string\n    or unicode then it will also be a key in the fields dictionary,\n    otherwise it's meta-data). Notice also that the first two elements\n    of the tuple can be passed directly as arguments to the ``ndarray.getfield``\n    and ``ndarray.setfield`` methods.\n\n    See Also\n    --------\n    ndarray.getfield, ndarray.setfield\n\n    Examples\n    --------\n    >>> dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n    >>> print(dt.fields)\n    {'grades': (dtype(('float64',(2,))), 16), 'name': (dtype('|S16'), 0)}\n\n    ")
             1884  CALL_FUNCTION_3       3  ''
             1886  POP_TOP          

 L.5362      1888  LOAD_NAME                add_newdoc
             1890  LOAD_STR                 'numpy.core.multiarray'
             1892  LOAD_STR                 'dtype'
             1894  LOAD_CONST               ('flags', "\n    Bit-flags describing how this data type is to be interpreted.\n\n    Bit-masks are in `numpy.core.multiarray` as the constants\n    `ITEM_HASOBJECT`, `LIST_PICKLE`, `ITEM_IS_POINTER`, `NEEDS_INIT`,\n    `NEEDS_PYAPI`, `USE_GETITEM`, `USE_SETITEM`. A full explanation\n    of these flags is in C-API documentation; they are largely useful\n    for user-defined data-types.\n\n    The following example demonstrates that operations on this particular\n    dtype requires Python C-API.\n\n    Examples\n    --------\n\n    >>> x = np.dtype([('a', np.int32, 8), ('b', np.float64, 6)])\n    >>> x.flags\n    16\n    >>> np.core.multiarray.NEEDS_PYAPI\n    16\n\n    ")
             1896  CALL_FUNCTION_3       3  ''
             1898  POP_TOP          

 L.5386      1900  LOAD_NAME                add_newdoc
             1902  LOAD_STR                 'numpy.core.multiarray'
             1904  LOAD_STR                 'dtype'
             1906  LOAD_CONST               ('hasobject', "\n    Boolean indicating whether this dtype contains any reference-counted\n    objects in any fields or sub-dtypes.\n\n    Recall that what is actually in the ndarray memory representing\n    the Python object is the memory address of that object (a pointer).\n    Special handling may be required, and this attribute is useful for\n    distinguishing data types that may contain arbitrary Python objects\n    and data-types that won't.\n\n    ")
             1908  CALL_FUNCTION_3       3  ''
             1910  POP_TOP          

 L.5399      1912  LOAD_NAME                add_newdoc
             1914  LOAD_STR                 'numpy.core.multiarray'
             1916  LOAD_STR                 'dtype'
             1918  LOAD_CONST               ('isbuiltin', "\n    Integer indicating how this dtype relates to the built-in dtypes.\n\n    Read-only.\n\n    =  ========================================================================\n    0  if this is a structured array type, with fields\n    1  if this is a dtype compiled into numpy (such as ints, floats etc)\n    2  if the dtype is for a user-defined numpy type\n       A user-defined type uses the numpy C-API machinery to extend\n       numpy to handle a new array type. See\n       :ref:`user.user-defined-data-types` in the NumPy manual.\n    =  ========================================================================\n\n    Examples\n    --------\n    >>> dt = np.dtype('i2')\n    >>> dt.isbuiltin\n    1\n    >>> dt = np.dtype('f8')\n    >>> dt.isbuiltin\n    1\n    >>> dt = np.dtype([('field1', 'f8')])\n    >>> dt.isbuiltin\n    0\n\n    ")
             1920  CALL_FUNCTION_3       3  ''
             1922  POP_TOP          

 L.5428      1924  LOAD_NAME                add_newdoc
             1926  LOAD_STR                 'numpy.core.multiarray'
             1928  LOAD_STR                 'dtype'
             1930  LOAD_CONST               ('isnative', '\n    Boolean indicating whether the byte order of this dtype is native\n    to the platform.\n\n    ')
             1932  CALL_FUNCTION_3       3  ''
             1934  POP_TOP          

 L.5435      1936  LOAD_NAME                add_newdoc
             1938  LOAD_STR                 'numpy.core.multiarray'
             1940  LOAD_STR                 'dtype'
             1942  LOAD_CONST               ('isalignedstruct', '\n    Boolean indicating whether the dtype is a struct which maintains\n    field alignment. This flag is sticky, so when combining multiple\n    structs together, it is preserved and produces new dtypes which\n    are also aligned.\n\n    ')
             1944  CALL_FUNCTION_3       3  ''
             1946  POP_TOP          

 L.5444      1948  LOAD_NAME                add_newdoc
             1950  LOAD_STR                 'numpy.core.multiarray'
             1952  LOAD_STR                 'dtype'
             1954  LOAD_CONST               ('itemsize', "\n    The element size of this data-type object.\n\n    For 18 of the 21 types this number is fixed by the data-type.\n    For the flexible data-types, this number can be anything.\n\n    Examples\n    --------\n\n    >>> arr = np.array([[1, 2], [3, 4]])\n    >>> arr.dtype\n    dtype('int64')\n    >>> arr.itemsize\n    8\n\n    >>> dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n    >>> dt.itemsize\n    80\n\n    ")
             1956  CALL_FUNCTION_3       3  ''
             1958  POP_TOP          

 L.5466      1960  LOAD_NAME                add_newdoc
             1962  LOAD_STR                 'numpy.core.multiarray'
             1964  LOAD_STR                 'dtype'
             1966  LOAD_CONST               ('kind', "\n    A character code (one of 'biufcmMOSUV') identifying the general kind of data.\n\n    =  ======================\n    b  boolean\n    i  signed integer\n    u  unsigned integer\n    f  floating-point\n    c  complex floating-point\n    m  timedelta\n    M  datetime\n    O  object\n    S  (byte-)string\n    U  Unicode\n    V  void\n    =  ======================\n\n    Examples\n    --------\n\n    >>> dt = np.dtype('i4')\n    >>> dt.kind\n    'i'\n    >>> dt = np.dtype('f8')\n    >>> dt.kind\n    'f'\n    >>> dt = np.dtype([('field1', 'f8')])\n    >>> dt.kind\n    'V'\n\n    ")
             1968  CALL_FUNCTION_3       3  ''
             1970  POP_TOP          

 L.5499      1972  LOAD_NAME                add_newdoc
             1974  LOAD_STR                 'numpy.core.multiarray'
             1976  LOAD_STR                 'dtype'
             1978  LOAD_CONST               ('name', "\n    A bit-width name for this data-type.\n\n    Un-sized flexible data-type objects do not have this attribute.\n\n    Examples\n    --------\n\n    >>> x = np.dtype(float)\n    >>> x.name\n    'float64'\n    >>> x = np.dtype([('a', np.int32, 8), ('b', np.float64, 6)])\n    >>> x.name\n    'void640'\n\n    ")
             1980  CALL_FUNCTION_3       3  ''
             1982  POP_TOP          

 L.5517      1984  LOAD_NAME                add_newdoc
             1986  LOAD_STR                 'numpy.core.multiarray'
             1988  LOAD_STR                 'dtype'
             1990  LOAD_CONST               ('names', "\n    Ordered list of field names, or ``None`` if there are no fields.\n\n    The names are ordered according to increasing byte offset. This can be\n    used, for example, to walk through all of the named fields in offset order.\n\n    Examples\n    --------\n    >>> dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n    >>> dt.names\n    ('name', 'grades')\n\n    ")
             1992  CALL_FUNCTION_3       3  ''
             1994  POP_TOP          

 L.5532      1996  LOAD_NAME                add_newdoc
             1998  LOAD_STR                 'numpy.core.multiarray'
             2000  LOAD_STR                 'dtype'
             2002  LOAD_CONST               ('num', '\n    A unique number for each of the 21 different built-in types.\n\n    These are roughly ordered from least-to-most precision.\n\n    Examples\n    --------\n\n    >>> dt = np.dtype(str)\n    >>> dt.num\n    19\n\n    >>> dt = np.dtype(float)\n    >>> dt.num\n    12\n\n    ')
             2004  CALL_FUNCTION_3       3  ''
             2006  POP_TOP          

 L.5551      2008  LOAD_NAME                add_newdoc
             2010  LOAD_STR                 'numpy.core.multiarray'
             2012  LOAD_STR                 'dtype'
             2014  LOAD_CONST               ('shape', "\n    Shape tuple of the sub-array if this data type describes a sub-array,\n    and ``()`` otherwise.\n\n    Examples\n    --------\n\n    >>> dt = np.dtype(('i4', 4))\n    >>> dt.shape\n    (4,)\n\n    >>> dt = np.dtype(('i4', (2, 3)))\n    >>> dt.shape\n    (2, 3)\n\n    ")
             2016  CALL_FUNCTION_3       3  ''
             2018  POP_TOP          

 L.5569      2020  LOAD_NAME                add_newdoc
             2022  LOAD_STR                 'numpy.core.multiarray'
             2024  LOAD_STR                 'dtype'
             2026  LOAD_CONST               ('ndim', "\n    Number of dimensions of the sub-array if this data type describes a\n    sub-array, and ``0`` otherwise.\n\n    .. versionadded:: 1.13.0\n\n    Examples\n    --------\n    >>> x = np.dtype(float)\n    >>> x.ndim\n    0\n\n    >>> x = np.dtype((float, 8))\n    >>> x.ndim\n    1\n\n    >>> x = np.dtype(('i4', (3, 4)))\n    >>> x.ndim\n    2\n\n    ")
             2028  CALL_FUNCTION_3       3  ''
             2030  POP_TOP          

 L.5592      2032  LOAD_NAME                add_newdoc
             2034  LOAD_STR                 'numpy.core.multiarray'
             2036  LOAD_STR                 'dtype'
             2038  LOAD_CONST               ('str', 'The array-protocol typestring of this data-type object.')
             2040  CALL_FUNCTION_3       3  ''
             2042  POP_TOP          

 L.5595      2044  LOAD_NAME                add_newdoc
             2046  LOAD_STR                 'numpy.core.multiarray'
             2048  LOAD_STR                 'dtype'
             2050  LOAD_CONST               ('subdtype', "\n    Tuple ``(item_dtype, shape)`` if this `dtype` describes a sub-array, and\n    None otherwise.\n\n    The *shape* is the fixed shape of the sub-array described by this\n    data type, and *item_dtype* the data type of the array.\n\n    If a field whose dtype object has this attribute is retrieved,\n    then the extra dimensions implied by *shape* are tacked on to\n    the end of the retrieved array.\n\n    See Also\n    --------\n    dtype.base\n\n    Examples\n    --------\n    >>> x = numpy.dtype('8f')\n    >>> x.subdtype\n    (dtype('float32'), (8,))\n\n    >>> x =  numpy.dtype('i2')\n    >>> x.subdtype\n    >>>\n\n    ")
             2052  CALL_FUNCTION_3       3  ''
             2054  POP_TOP          

 L.5623      2056  LOAD_NAME                add_newdoc
             2058  LOAD_STR                 'numpy.core.multiarray'
             2060  LOAD_STR                 'dtype'
             2062  LOAD_CONST               ('base', "\n    Returns dtype for the base element of the subarrays,\n    regardless of their dimension or shape.\n\n    See Also\n    --------\n    dtype.subdtype\n\n    Examples\n    --------\n    >>> x = numpy.dtype('8f')\n    >>> x.base\n    dtype('float32')\n\n    >>> x =  numpy.dtype('i2')\n    >>> x.base\n    dtype('int16')\n\n    ")
             2064  CALL_FUNCTION_3       3  ''
             2066  POP_TOP          

 L.5644      2068  LOAD_NAME                add_newdoc
             2070  LOAD_STR                 'numpy.core.multiarray'
             2072  LOAD_STR                 'dtype'
             2074  LOAD_CONST               ('type', 'The type object used to instantiate a scalar of this data-type.')
             2076  CALL_FUNCTION_3       3  ''
             2078  POP_TOP          

 L.5653      2080  LOAD_NAME                add_newdoc
             2082  LOAD_STR                 'numpy.core.multiarray'
             2084  LOAD_STR                 'dtype'
             2086  LOAD_CONST               ('newbyteorder', "\n    newbyteorder(new_order='S')\n\n    Return a new dtype with a different byte order.\n\n    Changes are also made in all fields and sub-arrays of the data type.\n\n    Parameters\n    ----------\n    new_order : string, optional\n        Byte order to force; a value from the byte order specifications\n        below.  The default value ('S') results in swapping the current\n        byte order.  `new_order` codes can be any of:\n\n        * 'S' - swap dtype from current to opposite endian\n        * {'<', 'L'} - little endian\n        * {'>', 'B'} - big endian\n        * {'=', 'N'} - native order\n        * {'|', 'I'} - ignore (no change to byte order)\n\n        The code does a case-insensitive check on the first letter of\n        `new_order` for these alternatives.  For example, any of '>'\n        or 'B' or 'b' or 'brian' are valid to specify big-endian.\n\n    Returns\n    -------\n    new_dtype : dtype\n        New dtype object with the given change to the byte order.\n\n    Notes\n    -----\n    Changes are also made in all fields and sub-arrays of the data type.\n\n    Examples\n    --------\n    >>> import sys\n    >>> sys_is_le = sys.byteorder == 'little'\n    >>> native_code = sys_is_le and '<' or '>'\n    >>> swapped_code = sys_is_le and '>' or '<'\n    >>> native_dt = np.dtype(native_code+'i2')\n    >>> swapped_dt = np.dtype(swapped_code+'i2')\n    >>> native_dt.newbyteorder('S') == swapped_dt\n    True\n    >>> native_dt.newbyteorder() == swapped_dt\n    True\n    >>> native_dt == swapped_dt.newbyteorder('S')\n    True\n    >>> native_dt == swapped_dt.newbyteorder('=')\n    True\n    >>> native_dt == swapped_dt.newbyteorder('N')\n    True\n    >>> native_dt == native_dt.newbyteorder('|')\n    True\n    >>> np.dtype('<i2') == native_dt.newbyteorder('<')\n    True\n    >>> np.dtype('<i2') == native_dt.newbyteorder('L')\n    True\n    >>> np.dtype('>i2') == native_dt.newbyteorder('>')\n    True\n    >>> np.dtype('>i2') == native_dt.newbyteorder('B')\n    True\n\n    ")
             2088  CALL_FUNCTION_3       3  ''
             2090  POP_TOP          

 L.5725      2092  LOAD_NAME                add_newdoc
             2094  LOAD_STR                 'numpy.core.multiarray'
             2096  LOAD_STR                 'busdaycalendar'

 L.5726      2098  LOAD_STR                 '\n    busdaycalendar(weekmask=\'1111100\', holidays=None)\n\n    A business day calendar object that efficiently stores information\n    defining valid days for the busday family of functions.\n\n    The default valid days are Monday through Friday ("business days").\n    A busdaycalendar object can be specified with any set of weekly\n    valid days, plus an optional "holiday" dates that always will be invalid.\n\n    Once a busdaycalendar object is created, the weekmask and holidays\n    cannot be modified.\n\n    .. versionadded:: 1.7.0\n\n    Parameters\n    ----------\n    weekmask : str or array_like of bool, optional\n        A seven-element array indicating which of Monday through Sunday are\n        valid days. May be specified as a length-seven list or array, like\n        [1,1,1,1,1,0,0]; a length-seven string, like \'1111100\'; or a string\n        like "Mon Tue Wed Thu Fri", made up of 3-character abbreviations for\n        weekdays, optionally separated by white space. Valid abbreviations\n        are: Mon Tue Wed Thu Fri Sat Sun\n    holidays : array_like of datetime64[D], optional\n        An array of dates to consider as invalid dates, no matter which\n        weekday they fall upon.  Holiday dates may be specified in any\n        order, and NaT (not-a-time) dates are ignored.  This list is\n        saved in a normalized form that is suited for fast calculations\n        of valid days.\n\n    Returns\n    -------\n    out : busdaycalendar\n        A business day calendar object containing the specified\n        weekmask and holidays values.\n\n    See Also\n    --------\n    is_busday : Returns a boolean array indicating valid days.\n    busday_offset : Applies an offset counted in valid days.\n    busday_count : Counts how many valid days are in a half-open date range.\n\n    Attributes\n    ----------\n    Note: once a busdaycalendar object is created, you cannot modify the\n    weekmask or holidays.  The attributes return copies of internal data.\n    weekmask : (copy) seven-element array of bool\n    holidays : (copy) sorted array of datetime64[D]\n\n    Examples\n    --------\n    >>> # Some important days in July\n    ... bdd = np.busdaycalendar(\n    ...             holidays=[\'2011-07-01\', \'2011-07-04\', \'2011-07-17\'])\n    >>> # Default is Monday to Friday weekdays\n    ... bdd.weekmask\n    array([ True,  True,  True,  True,  True, False, False])\n    >>> # Any holidays already on the weekend are removed\n    ... bdd.holidays\n    array([\'2011-07-01\', \'2011-07-04\'], dtype=\'datetime64[D]\')\n    '

 L.5725      2100  CALL_FUNCTION_3       3  ''
             2102  POP_TOP          

 L.5789      2104  LOAD_NAME                add_newdoc
             2106  LOAD_STR                 'numpy.core.multiarray'
             2108  LOAD_STR                 'busdaycalendar'
             2110  LOAD_CONST               ('weekmask', 'A copy of the seven-element boolean mask indicating valid days.')
             2112  CALL_FUNCTION_3       3  ''
             2114  POP_TOP          

 L.5792      2116  LOAD_NAME                add_newdoc
             2118  LOAD_STR                 'numpy.core.multiarray'
             2120  LOAD_STR                 'busdaycalendar'
             2122  LOAD_CONST               ('holidays', 'A copy of the holiday array indicating additional invalid days.')
             2124  CALL_FUNCTION_3       3  ''
             2126  POP_TOP          

 L.5795      2128  LOAD_NAME                add_newdoc
             2130  LOAD_STR                 'numpy.core.multiarray'
             2132  LOAD_STR                 'normalize_axis_index'

 L.5796      2134  LOAD_STR                 "\n    normalize_axis_index(axis, ndim, msg_prefix=None)\n\n    Normalizes an axis index, `axis`, such that is a valid positive index into\n    the shape of array with `ndim` dimensions. Raises an AxisError with an\n    appropriate message if this is not possible.\n\n    Used internally by all axis-checking logic.\n\n    .. versionadded:: 1.13.0\n\n    Parameters\n    ----------\n    axis : int\n        The un-normalized index of the axis. Can be negative\n    ndim : int\n        The number of dimensions of the array that `axis` should be normalized\n        against\n    msg_prefix : str\n        A prefix to put before the message, typically the name of the argument\n\n    Returns\n    -------\n    normalized_axis : int\n        The normalized axis index, such that `0 <= normalized_axis < ndim`\n\n    Raises\n    ------\n    AxisError\n        If the axis index is invalid, when `-ndim <= axis < ndim` is false.\n\n    Examples\n    --------\n    >>> normalize_axis_index(0, ndim=3)\n    0\n    >>> normalize_axis_index(1, ndim=3)\n    1\n    >>> normalize_axis_index(-1, ndim=3)\n    2\n\n    >>> normalize_axis_index(3, ndim=3)\n    Traceback (most recent call last):\n    ...\n    AxisError: axis 3 is out of bounds for array of dimension 3\n    >>> normalize_axis_index(-4, ndim=3, msg_prefix='axes_arg')\n    Traceback (most recent call last):\n    ...\n    AxisError: axes_arg: axis -4 is out of bounds for array of dimension 3\n    "

 L.5795      2136  CALL_FUNCTION_3       3  ''
             2138  POP_TOP          

 L.5846      2140  LOAD_NAME                add_newdoc
             2142  LOAD_STR                 'numpy.core.multiarray'
             2144  LOAD_STR                 'datetime_data'

 L.5847      2146  LOAD_STR                 "\n    datetime_data(dtype, /)\n\n    Get information about the step size of a date or time type.\n\n    The returned tuple can be passed as the second argument of `numpy.datetime64` and\n    `numpy.timedelta64`.\n\n    Parameters\n    ----------\n    dtype : dtype\n        The dtype object, which must be a `datetime64` or `timedelta64` type.\n\n    Returns\n    -------\n    unit : str\n        The :ref:`datetime unit <arrays.dtypes.dateunits>` on which this dtype\n        is based.\n    count : int\n        The number of base units in a step.\n\n    Examples\n    --------\n    >>> dt_25s = np.dtype('timedelta64[25s]')\n    >>> np.datetime_data(dt_25s)\n    ('s', 25)\n    >>> np.array(10, dt_25s).astype('timedelta64[s]')\n    array(250, dtype='timedelta64[s]')\n\n    The result can be used to construct a datetime that uses the same units\n    as a timedelta\n\n    >>> np.datetime64('2010', np.datetime_data(dt_25s))\n    numpy.datetime64('2010-01-01T00:00:00','25s')\n    "

 L.5846      2148  CALL_FUNCTION_3       3  ''
             2150  POP_TOP          

 L.5890      2152  LOAD_NAME                add_newdoc
             2154  LOAD_STR                 'numpy.core.numerictypes'
             2156  LOAD_STR                 'generic'

 L.5891      2158  LOAD_STR                 '\n    Base class for numpy scalar types.\n\n    Class from which most (all?) numpy scalar types are derived.  For\n    consistency, exposes the same API as `ndarray`, despite many\n    consequent attributes being either "get-only," or completely irrelevant.\n    This is the class from which it is strongly suggested users should derive\n    custom scalar types.\n\n    '

 L.5890      2160  CALL_FUNCTION_3       3  ''
             2162  POP_TOP          

 L.5904      2164  LOAD_NAME                add_newdoc
             2166  LOAD_STR                 'numpy.core.numerictypes'
             2168  LOAD_STR                 'generic'
             2170  LOAD_CONST               ('T', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class so as to\n    provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2172  CALL_FUNCTION_3       3  ''
             2174  POP_TOP          

 L.5916      2176  LOAD_NAME                add_newdoc
             2178  LOAD_STR                 'numpy.core.numerictypes'
             2180  LOAD_STR                 'generic'
             2182  LOAD_CONST               ('base', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class so as to\n    a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2184  CALL_FUNCTION_3       3  ''
             2186  POP_TOP          

 L.5928      2188  LOAD_NAME                add_newdoc
             2190  LOAD_STR                 'numpy.core.numerictypes'
             2192  LOAD_STR                 'generic'
             2194  LOAD_CONST               ('data', 'Pointer to start of data.')
             2196  CALL_FUNCTION_3       3  ''
             2198  POP_TOP          

 L.5931      2200  LOAD_NAME                add_newdoc
             2202  LOAD_STR                 'numpy.core.numerictypes'
             2204  LOAD_STR                 'generic'
             2206  LOAD_CONST               ('dtype', 'Get array data-descriptor.')
             2208  CALL_FUNCTION_3       3  ''
             2210  POP_TOP          

 L.5934      2212  LOAD_NAME                add_newdoc
             2214  LOAD_STR                 'numpy.core.numerictypes'
             2216  LOAD_STR                 'generic'
             2218  LOAD_CONST               ('flags', 'The integer value of flags.')
             2220  CALL_FUNCTION_3       3  ''
             2222  POP_TOP          

 L.5937      2224  LOAD_NAME                add_newdoc
             2226  LOAD_STR                 'numpy.core.numerictypes'
             2228  LOAD_STR                 'generic'
             2230  LOAD_CONST               ('flat', 'A 1-D view of the scalar.')
             2232  CALL_FUNCTION_3       3  ''
             2234  POP_TOP          

 L.5940      2236  LOAD_NAME                add_newdoc
             2238  LOAD_STR                 'numpy.core.numerictypes'
             2240  LOAD_STR                 'generic'
             2242  LOAD_CONST               ('imag', 'The imaginary part of the scalar.')
             2244  CALL_FUNCTION_3       3  ''
             2246  POP_TOP          

 L.5943      2248  LOAD_NAME                add_newdoc
             2250  LOAD_STR                 'numpy.core.numerictypes'
             2252  LOAD_STR                 'generic'
             2254  LOAD_CONST               ('itemsize', 'The length of one element in bytes.')
             2256  CALL_FUNCTION_3       3  ''
             2258  POP_TOP          

 L.5946      2260  LOAD_NAME                add_newdoc
             2262  LOAD_STR                 'numpy.core.numerictypes'
             2264  LOAD_STR                 'generic'
             2266  LOAD_CONST               ('nbytes', 'The length of the scalar in bytes.')
             2268  CALL_FUNCTION_3       3  ''
             2270  POP_TOP          

 L.5949      2272  LOAD_NAME                add_newdoc
             2274  LOAD_STR                 'numpy.core.numerictypes'
             2276  LOAD_STR                 'generic'
             2278  LOAD_CONST               ('ndim', 'The number of array dimensions.')
             2280  CALL_FUNCTION_3       3  ''
             2282  POP_TOP          

 L.5952      2284  LOAD_NAME                add_newdoc
             2286  LOAD_STR                 'numpy.core.numerictypes'
             2288  LOAD_STR                 'generic'
             2290  LOAD_CONST               ('real', 'The real part of the scalar.')
             2292  CALL_FUNCTION_3       3  ''
             2294  POP_TOP          

 L.5955      2296  LOAD_NAME                add_newdoc
             2298  LOAD_STR                 'numpy.core.numerictypes'
             2300  LOAD_STR                 'generic'
             2302  LOAD_CONST               ('shape', 'Tuple of array dimensions.')
             2304  CALL_FUNCTION_3       3  ''
             2306  POP_TOP          

 L.5958      2308  LOAD_NAME                add_newdoc
             2310  LOAD_STR                 'numpy.core.numerictypes'
             2312  LOAD_STR                 'generic'
             2314  LOAD_CONST               ('size', 'The number of elements in the gentype.')
             2316  CALL_FUNCTION_3       3  ''
             2318  POP_TOP          

 L.5961      2320  LOAD_NAME                add_newdoc
             2322  LOAD_STR                 'numpy.core.numerictypes'
             2324  LOAD_STR                 'generic'
             2326  LOAD_CONST               ('strides', 'Tuple of bytes steps in each dimension.')
             2328  CALL_FUNCTION_3       3  ''
             2330  POP_TOP          

 L.5966      2332  LOAD_NAME                add_newdoc
             2334  LOAD_STR                 'numpy.core.numerictypes'
             2336  LOAD_STR                 'generic'
             2338  LOAD_CONST               ('all', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2340  CALL_FUNCTION_3       3  ''
             2342  POP_TOP          

 L.5978      2344  LOAD_NAME                add_newdoc
             2346  LOAD_STR                 'numpy.core.numerictypes'
             2348  LOAD_STR                 'generic'
             2350  LOAD_CONST               ('any', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2352  CALL_FUNCTION_3       3  ''
             2354  POP_TOP          

 L.5990      2356  LOAD_NAME                add_newdoc
             2358  LOAD_STR                 'numpy.core.numerictypes'
             2360  LOAD_STR                 'generic'
             2362  LOAD_CONST               ('argmax', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2364  CALL_FUNCTION_3       3  ''
             2366  POP_TOP          

 L.6002      2368  LOAD_NAME                add_newdoc
             2370  LOAD_STR                 'numpy.core.numerictypes'
             2372  LOAD_STR                 'generic'
             2374  LOAD_CONST               ('argmin', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2376  CALL_FUNCTION_3       3  ''
             2378  POP_TOP          

 L.6014      2380  LOAD_NAME                add_newdoc
             2382  LOAD_STR                 'numpy.core.numerictypes'
             2384  LOAD_STR                 'generic'
             2386  LOAD_CONST               ('argsort', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2388  CALL_FUNCTION_3       3  ''
             2390  POP_TOP          

 L.6026      2392  LOAD_NAME                add_newdoc
             2394  LOAD_STR                 'numpy.core.numerictypes'
             2396  LOAD_STR                 'generic'
             2398  LOAD_CONST               ('astype', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2400  CALL_FUNCTION_3       3  ''
             2402  POP_TOP          

 L.6038      2404  LOAD_NAME                add_newdoc
             2406  LOAD_STR                 'numpy.core.numerictypes'
             2408  LOAD_STR                 'generic'
             2410  LOAD_CONST               ('byteswap', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class so as to\n    provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2412  CALL_FUNCTION_3       3  ''
             2414  POP_TOP          

 L.6050      2416  LOAD_NAME                add_newdoc
             2418  LOAD_STR                 'numpy.core.numerictypes'
             2420  LOAD_STR                 'generic'
             2422  LOAD_CONST               ('choose', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2424  CALL_FUNCTION_3       3  ''
             2426  POP_TOP          

 L.6062      2428  LOAD_NAME                add_newdoc
             2430  LOAD_STR                 'numpy.core.numerictypes'
             2432  LOAD_STR                 'generic'
             2434  LOAD_CONST               ('clip', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2436  CALL_FUNCTION_3       3  ''
             2438  POP_TOP          

 L.6074      2440  LOAD_NAME                add_newdoc
             2442  LOAD_STR                 'numpy.core.numerictypes'
             2444  LOAD_STR                 'generic'
             2446  LOAD_CONST               ('compress', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2448  CALL_FUNCTION_3       3  ''
             2450  POP_TOP          

 L.6086      2452  LOAD_NAME                add_newdoc
             2454  LOAD_STR                 'numpy.core.numerictypes'
             2456  LOAD_STR                 'generic'
             2458  LOAD_CONST               ('conjugate', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2460  CALL_FUNCTION_3       3  ''
             2462  POP_TOP          

 L.6098      2464  LOAD_NAME                add_newdoc
             2466  LOAD_STR                 'numpy.core.numerictypes'
             2468  LOAD_STR                 'generic'
             2470  LOAD_CONST               ('copy', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2472  CALL_FUNCTION_3       3  ''
             2474  POP_TOP          

 L.6110      2476  LOAD_NAME                add_newdoc
             2478  LOAD_STR                 'numpy.core.numerictypes'
             2480  LOAD_STR                 'generic'
             2482  LOAD_CONST               ('cumprod', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2484  CALL_FUNCTION_3       3  ''
             2486  POP_TOP          

 L.6122      2488  LOAD_NAME                add_newdoc
             2490  LOAD_STR                 'numpy.core.numerictypes'
             2492  LOAD_STR                 'generic'
             2494  LOAD_CONST               ('cumsum', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2496  CALL_FUNCTION_3       3  ''
             2498  POP_TOP          

 L.6134      2500  LOAD_NAME                add_newdoc
             2502  LOAD_STR                 'numpy.core.numerictypes'
             2504  LOAD_STR                 'generic'
             2506  LOAD_CONST               ('diagonal', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2508  CALL_FUNCTION_3       3  ''
             2510  POP_TOP          

 L.6146      2512  LOAD_NAME                add_newdoc
             2514  LOAD_STR                 'numpy.core.numerictypes'
             2516  LOAD_STR                 'generic'
             2518  LOAD_CONST               ('dump', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2520  CALL_FUNCTION_3       3  ''
             2522  POP_TOP          

 L.6158      2524  LOAD_NAME                add_newdoc
             2526  LOAD_STR                 'numpy.core.numerictypes'
             2528  LOAD_STR                 'generic'
             2530  LOAD_CONST               ('dumps', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2532  CALL_FUNCTION_3       3  ''
             2534  POP_TOP          

 L.6170      2536  LOAD_NAME                add_newdoc
             2538  LOAD_STR                 'numpy.core.numerictypes'
             2540  LOAD_STR                 'generic'
             2542  LOAD_CONST               ('fill', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2544  CALL_FUNCTION_3       3  ''
             2546  POP_TOP          

 L.6182      2548  LOAD_NAME                add_newdoc
             2550  LOAD_STR                 'numpy.core.numerictypes'
             2552  LOAD_STR                 'generic'
         2554_2556  LOAD_CONST               ('flatten', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2558  CALL_FUNCTION_3       3  ''
             2560  POP_TOP          

 L.6194      2562  LOAD_NAME                add_newdoc
             2564  LOAD_STR                 'numpy.core.numerictypes'
             2566  LOAD_STR                 'generic'
         2568_2570  LOAD_CONST               ('getfield', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2572  CALL_FUNCTION_3       3  ''
             2574  POP_TOP          

 L.6206      2576  LOAD_NAME                add_newdoc
             2578  LOAD_STR                 'numpy.core.numerictypes'
             2580  LOAD_STR                 'generic'
         2582_2584  LOAD_CONST               ('item', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2586  CALL_FUNCTION_3       3  ''
             2588  POP_TOP          

 L.6218      2590  LOAD_NAME                add_newdoc
             2592  LOAD_STR                 'numpy.core.numerictypes'
             2594  LOAD_STR                 'generic'
         2596_2598  LOAD_CONST               ('itemset', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2600  CALL_FUNCTION_3       3  ''
             2602  POP_TOP          

 L.6230      2604  LOAD_NAME                add_newdoc
             2606  LOAD_STR                 'numpy.core.numerictypes'
             2608  LOAD_STR                 'generic'
         2610_2612  LOAD_CONST               ('max', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2614  CALL_FUNCTION_3       3  ''
             2616  POP_TOP          

 L.6242      2618  LOAD_NAME                add_newdoc
             2620  LOAD_STR                 'numpy.core.numerictypes'
             2622  LOAD_STR                 'generic'
         2624_2626  LOAD_CONST               ('mean', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2628  CALL_FUNCTION_3       3  ''
             2630  POP_TOP          

 L.6254      2632  LOAD_NAME                add_newdoc
             2634  LOAD_STR                 'numpy.core.numerictypes'
             2636  LOAD_STR                 'generic'
         2638_2640  LOAD_CONST               ('min', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2642  CALL_FUNCTION_3       3  ''
             2644  POP_TOP          

 L.6266      2646  LOAD_NAME                add_newdoc
             2648  LOAD_STR                 'numpy.core.numerictypes'
             2650  LOAD_STR                 'generic'
         2652_2654  LOAD_CONST               ('newbyteorder', "\n    newbyteorder(new_order='S')\n\n    Return a new `dtype` with a different byte order.\n\n    Changes are also made in all fields and sub-arrays of the data type.\n\n    The `new_order` code can be any from the following:\n\n    * 'S' - swap dtype from current to opposite endian\n    * {'<', 'L'} - little endian\n    * {'>', 'B'} - big endian\n    * {'=', 'N'} - native order\n    * {'|', 'I'} - ignore (no change to byte order)\n\n    Parameters\n    ----------\n    new_order : str, optional\n        Byte order to force; a value from the byte order specifications\n        above.  The default value ('S') results in swapping the current\n        byte order. The code does a case-insensitive check on the first\n        letter of `new_order` for the alternatives above.  For example,\n        any of 'B' or 'b' or 'biggish' are valid to specify big-endian.\n\n\n    Returns\n    -------\n    new_dtype : dtype\n        New `dtype` object with the given change to the byte order.\n\n    ")
             2656  CALL_FUNCTION_3       3  ''
             2658  POP_TOP          

 L.6299      2660  LOAD_NAME                add_newdoc
             2662  LOAD_STR                 'numpy.core.numerictypes'
             2664  LOAD_STR                 'generic'
         2666_2668  LOAD_CONST               ('nonzero', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2670  CALL_FUNCTION_3       3  ''
             2672  POP_TOP          

 L.6311      2674  LOAD_NAME                add_newdoc
             2676  LOAD_STR                 'numpy.core.numerictypes'
             2678  LOAD_STR                 'generic'
         2680_2682  LOAD_CONST               ('prod', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2684  CALL_FUNCTION_3       3  ''
             2686  POP_TOP          

 L.6323      2688  LOAD_NAME                add_newdoc
             2690  LOAD_STR                 'numpy.core.numerictypes'
             2692  LOAD_STR                 'generic'
         2694_2696  LOAD_CONST               ('ptp', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2698  CALL_FUNCTION_3       3  ''
             2700  POP_TOP          

 L.6335      2702  LOAD_NAME                add_newdoc
             2704  LOAD_STR                 'numpy.core.numerictypes'
             2706  LOAD_STR                 'generic'
         2708_2710  LOAD_CONST               ('put', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2712  CALL_FUNCTION_3       3  ''
             2714  POP_TOP          

 L.6347      2716  LOAD_NAME                add_newdoc
             2718  LOAD_STR                 'numpy.core.numerictypes'
             2720  LOAD_STR                 'generic'
         2722_2724  LOAD_CONST               ('ravel', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2726  CALL_FUNCTION_3       3  ''
             2728  POP_TOP          

 L.6359      2730  LOAD_NAME                add_newdoc
             2732  LOAD_STR                 'numpy.core.numerictypes'
             2734  LOAD_STR                 'generic'
         2736_2738  LOAD_CONST               ('repeat', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2740  CALL_FUNCTION_3       3  ''
             2742  POP_TOP          

 L.6371      2744  LOAD_NAME                add_newdoc
             2746  LOAD_STR                 'numpy.core.numerictypes'
             2748  LOAD_STR                 'generic'
         2750_2752  LOAD_CONST               ('reshape', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2754  CALL_FUNCTION_3       3  ''
             2756  POP_TOP          

 L.6383      2758  LOAD_NAME                add_newdoc
             2760  LOAD_STR                 'numpy.core.numerictypes'
             2762  LOAD_STR                 'generic'
         2764_2766  LOAD_CONST               ('resize', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2768  CALL_FUNCTION_3       3  ''
             2770  POP_TOP          

 L.6395      2772  LOAD_NAME                add_newdoc
             2774  LOAD_STR                 'numpy.core.numerictypes'
             2776  LOAD_STR                 'generic'
         2778_2780  LOAD_CONST               ('round', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2782  CALL_FUNCTION_3       3  ''
             2784  POP_TOP          

 L.6407      2786  LOAD_NAME                add_newdoc
             2788  LOAD_STR                 'numpy.core.numerictypes'
             2790  LOAD_STR                 'generic'
         2792_2794  LOAD_CONST               ('searchsorted', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2796  CALL_FUNCTION_3       3  ''
             2798  POP_TOP          

 L.6419      2800  LOAD_NAME                add_newdoc
             2802  LOAD_STR                 'numpy.core.numerictypes'
             2804  LOAD_STR                 'generic'
         2806_2808  LOAD_CONST               ('setfield', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2810  CALL_FUNCTION_3       3  ''
             2812  POP_TOP          

 L.6431      2814  LOAD_NAME                add_newdoc
             2816  LOAD_STR                 'numpy.core.numerictypes'
             2818  LOAD_STR                 'generic'
         2820_2822  LOAD_CONST               ('setflags', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class so as to\n    provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2824  CALL_FUNCTION_3       3  ''
             2826  POP_TOP          

 L.6443      2828  LOAD_NAME                add_newdoc
             2830  LOAD_STR                 'numpy.core.numerictypes'
             2832  LOAD_STR                 'generic'
         2834_2836  LOAD_CONST               ('sort', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2838  CALL_FUNCTION_3       3  ''
             2840  POP_TOP          

 L.6455      2842  LOAD_NAME                add_newdoc
             2844  LOAD_STR                 'numpy.core.numerictypes'
             2846  LOAD_STR                 'generic'
         2848_2850  LOAD_CONST               ('squeeze', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2852  CALL_FUNCTION_3       3  ''
             2854  POP_TOP          

 L.6467      2856  LOAD_NAME                add_newdoc
             2858  LOAD_STR                 'numpy.core.numerictypes'
             2860  LOAD_STR                 'generic'
         2862_2864  LOAD_CONST               ('std', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2866  CALL_FUNCTION_3       3  ''
             2868  POP_TOP          

 L.6479      2870  LOAD_NAME                add_newdoc
             2872  LOAD_STR                 'numpy.core.numerictypes'
             2874  LOAD_STR                 'generic'
         2876_2878  LOAD_CONST               ('sum', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2880  CALL_FUNCTION_3       3  ''
             2882  POP_TOP          

 L.6491      2884  LOAD_NAME                add_newdoc
             2886  LOAD_STR                 'numpy.core.numerictypes'
             2888  LOAD_STR                 'generic'
         2890_2892  LOAD_CONST               ('swapaxes', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2894  CALL_FUNCTION_3       3  ''
             2896  POP_TOP          

 L.6503      2898  LOAD_NAME                add_newdoc
             2900  LOAD_STR                 'numpy.core.numerictypes'
             2902  LOAD_STR                 'generic'
         2904_2906  LOAD_CONST               ('take', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2908  CALL_FUNCTION_3       3  ''
             2910  POP_TOP          

 L.6515      2912  LOAD_NAME                add_newdoc
             2914  LOAD_STR                 'numpy.core.numerictypes'
             2916  LOAD_STR                 'generic'
         2918_2920  LOAD_CONST               ('tofile', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2922  CALL_FUNCTION_3       3  ''
             2924  POP_TOP          

 L.6527      2926  LOAD_NAME                add_newdoc
             2928  LOAD_STR                 'numpy.core.numerictypes'
             2930  LOAD_STR                 'generic'
         2932_2934  LOAD_CONST               ('tolist', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2936  CALL_FUNCTION_3       3  ''
             2938  POP_TOP          

 L.6539      2940  LOAD_NAME                add_newdoc
             2942  LOAD_STR                 'numpy.core.numerictypes'
             2944  LOAD_STR                 'generic'
         2946_2948  LOAD_CONST               ('tostring', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2950  CALL_FUNCTION_3       3  ''
             2952  POP_TOP          

 L.6551      2954  LOAD_NAME                add_newdoc
             2956  LOAD_STR                 'numpy.core.numerictypes'
             2958  LOAD_STR                 'generic'
         2960_2962  LOAD_CONST               ('trace', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2964  CALL_FUNCTION_3       3  ''
             2966  POP_TOP          

 L.6563      2968  LOAD_NAME                add_newdoc
             2970  LOAD_STR                 'numpy.core.numerictypes'
             2972  LOAD_STR                 'generic'
         2974_2976  LOAD_CONST               ('transpose', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2978  CALL_FUNCTION_3       3  ''
             2980  POP_TOP          

 L.6575      2982  LOAD_NAME                add_newdoc
             2984  LOAD_STR                 'numpy.core.numerictypes'
             2986  LOAD_STR                 'generic'
         2988_2990  LOAD_CONST               ('var', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             2992  CALL_FUNCTION_3       3  ''
             2994  POP_TOP          

 L.6587      2996  LOAD_NAME                add_newdoc
             2998  LOAD_STR                 'numpy.core.numerictypes'
             3000  LOAD_STR                 'generic'
         3002_3004  LOAD_CONST               ('view', '\n    Not implemented (virtual attribute)\n\n    Class generic exists solely to derive numpy scalars from, and possesses,\n    albeit unimplemented, all the attributes of the ndarray class\n    so as to provide a uniform API.\n\n    See also the corresponding attribute of the derived class of interest.\n\n    ')
             3006  CALL_FUNCTION_3       3  ''
             3008  POP_TOP          

 L.6607      3010  LOAD_NAME                add_newdoc
             3012  LOAD_STR                 'numpy.core.numerictypes'
         3014_3016  LOAD_STR                 'number'

 L.6608  3018_3020  LOAD_STR                 '\n    Abstract base class of all numeric scalar types.\n\n    '

 L.6607      3022  CALL_FUNCTION_3       3  ''
             3024  POP_TOP          

 L.6613      3026  LOAD_NAME                add_newdoc
             3028  LOAD_STR                 'numpy.core.numerictypes'
         3030_3032  LOAD_STR                 'integer'

 L.6614  3034_3036  LOAD_STR                 '\n    Abstract base class of all integer scalar types.\n\n    '

 L.6613      3038  CALL_FUNCTION_3       3  ''
             3040  POP_TOP          

 L.6619      3042  LOAD_NAME                add_newdoc
             3044  LOAD_STR                 'numpy.core.numerictypes'
         3046_3048  LOAD_STR                 'signedinteger'

 L.6620  3050_3052  LOAD_STR                 '\n    Abstract base class of all signed integer scalar types.\n\n    '

 L.6619      3054  CALL_FUNCTION_3       3  ''
             3056  POP_TOP          

 L.6625      3058  LOAD_NAME                add_newdoc
             3060  LOAD_STR                 'numpy.core.numerictypes'
         3062_3064  LOAD_STR                 'unsignedinteger'

 L.6626  3066_3068  LOAD_STR                 '\n    Abstract base class of all unsigned integer scalar types.\n\n    '

 L.6625      3070  CALL_FUNCTION_3       3  ''
             3072  POP_TOP          

 L.6631      3074  LOAD_NAME                add_newdoc
             3076  LOAD_STR                 'numpy.core.numerictypes'
         3078_3080  LOAD_STR                 'inexact'

 L.6632  3082_3084  LOAD_STR                 '\n    Abstract base class of all numeric scalar types with a (potentially)\n    inexact representation of the values in its range, such as\n    floating-point numbers.\n\n    '

 L.6631      3086  CALL_FUNCTION_3       3  ''
             3088  POP_TOP          

 L.6639      3090  LOAD_NAME                add_newdoc
             3092  LOAD_STR                 'numpy.core.numerictypes'
         3094_3096  LOAD_STR                 'floating'

 L.6640  3098_3100  LOAD_STR                 '\n    Abstract base class of all floating-point scalar types.\n\n    '

 L.6639      3102  CALL_FUNCTION_3       3  ''
             3104  POP_TOP          

 L.6645      3106  LOAD_NAME                add_newdoc
             3108  LOAD_STR                 'numpy.core.numerictypes'
         3110_3112  LOAD_STR                 'complexfloating'

 L.6646  3114_3116  LOAD_STR                 '\n    Abstract base class of all complex number scalar types that are made up of\n    floating-point numbers.\n\n    '

 L.6645      3118  CALL_FUNCTION_3       3  ''
             3120  POP_TOP          

 L.6652      3122  LOAD_NAME                add_newdoc
             3124  LOAD_STR                 'numpy.core.numerictypes'
         3126_3128  LOAD_STR                 'flexible'

 L.6653  3130_3132  LOAD_STR                 '\n    Abstract base class of all scalar types without predefined length.\n    The actual size of these types depends on the specific `np.dtype`\n    instantiation.\n\n    '

 L.6652      3134  CALL_FUNCTION_3       3  ''
             3136  POP_TOP          

 L.6660      3138  LOAD_NAME                add_newdoc
             3140  LOAD_STR                 'numpy.core.numerictypes'
         3142_3144  LOAD_STR                 'character'

 L.6661  3146_3148  LOAD_STR                 '\n    Abstract base class of all character string scalar types.\n\n    '

 L.6660      3150  CALL_FUNCTION_3       3  ''
             3152  POP_TOP          

 L.6673  3154_3156  LOAD_CODE                <code_object numeric_type_aliases>
         3158_3160  LOAD_STR                 'numeric_type_aliases'
             3162  MAKE_FUNCTION_0          'Neither defaults, keyword-only args, annotations, nor closures'
             3164  STORE_NAME               numeric_type_aliases

 L.6686      3166  LOAD_NAME                numeric_type_aliases
             3168  BUILD_LIST_0          0 
         3170_3172  LOAD_CONST               (('int8', '8-bit signed integer (-128 to 127)'), ('int16', '16-bit signed integer (-32768 to 32767)'), ('int32', '32-bit signed integer (-2147483648 to 2147483647)'), ('int64', '64-bit signed integer (-9223372036854775808 to 9223372036854775807)'), ('intp', 'Signed integer large enough to fit pointer, compatible with C ``intptr_t``'), ('uint8', '8-bit unsigned integer (0 to 255)'), ('uint16', '16-bit unsigned integer (0 to 65535)'), ('uint32', '32-bit unsigned integer (0 to 4294967295)'), ('uint64', '64-bit unsigned integer (0 to 18446744073709551615)'), ('uintp', 'Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``'), ('float16', '16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa'), ('float32', '32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa'), ('float64', '64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa'), ('float96', '96-bit extended-precision floating-point number type'), ('float128', '128-bit extended-precision floating-point number type'), ('complex64', 'Complex number type composed of 2 32-bit-precision floating-point numbers'), ('complex128', 'Complex number type composed of 2 64-bit-precision floating-point numbers'), ('complex192', 'Complex number type composed of 2 96-bit extended-precision floating-point numbers'), ('complex256', 'Complex number type composed of 2 128-bit extended-precision floating-point numbers'))
             3174  CALL_FINALLY       3177  'to 3177'
             3176  CALL_FUNCTION_1       1  ''
             3178  STORE_NAME               possible_aliases

 L.6709  3180_3182  LOAD_CODE                <code_object add_newdoc_for_scalar_type>
         3184_3186  LOAD_STR                 'add_newdoc_for_scalar_type'
             3188  MAKE_FUNCTION_0          'Neither defaults, keyword-only args, annotations, nor closures'
             3190  STORE_NAME               add_newdoc_for_scalar_type

 L.6728      3192  LOAD_NAME                add_newdoc_for_scalar_type
         3194_3196  LOAD_STR                 'bool_'
         3198_3200  LOAD_STR                 'bool8'
             3202  BUILD_LIST_1          1 

 L.6729  3204_3206  LOAD_STR                 '\n    Boolean type (True or False), stored as a byte.\n    '

 L.6728      3208  CALL_FUNCTION_3       3  ''
             3210  POP_TOP          

 L.6733      3212  LOAD_NAME                add_newdoc_for_scalar_type
         3214_3216  LOAD_STR                 'byte'
             3218  BUILD_LIST_0          0 

 L.6734  3220_3222  LOAD_STR                 '\n    Signed integer type, compatible with C ``char``.\n    '

 L.6733      3224  CALL_FUNCTION_3       3  ''
             3226  POP_TOP          

 L.6738      3228  LOAD_NAME                add_newdoc_for_scalar_type
         3230_3232  LOAD_STR                 'short'
             3234  BUILD_LIST_0          0 

 L.6739  3236_3238  LOAD_STR                 '\n    Signed integer type, compatible with C ``short``.\n    '

 L.6738      3240  CALL_FUNCTION_3       3  ''
             3242  POP_TOP          

 L.6743      3244  LOAD_NAME                add_newdoc_for_scalar_type
         3246_3248  LOAD_STR                 'intc'
             3250  BUILD_LIST_0          0 

 L.6744  3252_3254  LOAD_STR                 '\n    Signed integer type, compatible with C ``int``.\n    '

 L.6743      3256  CALL_FUNCTION_3       3  ''
             3258  POP_TOP          

 L.6748      3260  LOAD_NAME                add_newdoc_for_scalar_type
         3262_3264  LOAD_STR                 'int_'
             3266  BUILD_LIST_0          0 

 L.6749  3268_3270  LOAD_STR                 '\n    Signed integer type, compatible with Python `int` anc C ``long``.\n    '

 L.6748      3272  CALL_FUNCTION_3       3  ''
             3274  POP_TOP          

 L.6753      3276  LOAD_NAME                add_newdoc_for_scalar_type
         3278_3280  LOAD_STR                 'longlong'
             3282  BUILD_LIST_0          0 

 L.6754  3284_3286  LOAD_STR                 '\n    Signed integer type, compatible with C ``long long``.\n    '

 L.6753      3288  CALL_FUNCTION_3       3  ''
             3290  POP_TOP          

 L.6758      3292  LOAD_NAME                add_newdoc_for_scalar_type
         3294_3296  LOAD_STR                 'ubyte'
             3298  BUILD_LIST_0          0 

 L.6759  3300_3302  LOAD_STR                 '\n    Unsigned integer type, compatible with C ``unsigned char``.\n    '

 L.6758      3304  CALL_FUNCTION_3       3  ''
             3306  POP_TOP          

 L.6763      3308  LOAD_NAME                add_newdoc_for_scalar_type
         3310_3312  LOAD_STR                 'ushort'
             3314  BUILD_LIST_0          0 

 L.6764  3316_3318  LOAD_STR                 '\n    Unsigned integer type, compatible with C ``unsigned short``.\n    '

 L.6763      3320  CALL_FUNCTION_3       3  ''
             3322  POP_TOP          

 L.6768      3324  LOAD_NAME                add_newdoc_for_scalar_type
         3326_3328  LOAD_STR                 'uintc'
             3330  BUILD_LIST_0          0 

 L.6769  3332_3334  LOAD_STR                 '\n    Unsigned integer type, compatible with C ``unsigned int``.\n    '

 L.6768      3336  CALL_FUNCTION_3       3  ''
             3338  POP_TOP          

 L.6773      3340  LOAD_NAME                add_newdoc_for_scalar_type
         3342_3344  LOAD_STR                 'uint'
             3346  BUILD_LIST_0          0 

 L.6774  3348_3350  LOAD_STR                 '\n    Unsigned integer type, compatible with C ``unsigned long``.\n    '

 L.6773      3352  CALL_FUNCTION_3       3  ''
             3354  POP_TOP          

 L.6778      3356  LOAD_NAME                add_newdoc_for_scalar_type
         3358_3360  LOAD_STR                 'ulonglong'
             3362  BUILD_LIST_0          0 

 L.6779  3364_3366  LOAD_STR                 '\n    Signed integer type, compatible with C ``unsigned long long``.\n    '

 L.6778      3368  CALL_FUNCTION_3       3  ''
             3370  POP_TOP          

 L.6783      3372  LOAD_NAME                add_newdoc_for_scalar_type
         3374_3376  LOAD_STR                 'half'
             3378  BUILD_LIST_0          0 

 L.6784  3380_3382  LOAD_STR                 '\n    Half-precision floating-point number type.\n    '

 L.6783      3384  CALL_FUNCTION_3       3  ''
             3386  POP_TOP          

 L.6788      3388  LOAD_NAME                add_newdoc_for_scalar_type
         3390_3392  LOAD_STR                 'single'
             3394  BUILD_LIST_0          0 

 L.6789  3396_3398  LOAD_STR                 '\n    Single-precision floating-point number type, compatible with C ``float``.\n    '

 L.6788      3400  CALL_FUNCTION_3       3  ''
             3402  POP_TOP          

 L.6793      3404  LOAD_NAME                add_newdoc_for_scalar_type
         3406_3408  LOAD_STR                 'double'
         3410_3412  LOAD_STR                 'float_'
             3414  BUILD_LIST_1          1 

 L.6794  3416_3418  LOAD_STR                 '\n    Double-precision floating-point number type, compatible with Python `float`\n    and C ``double``.\n    '

 L.6793      3420  CALL_FUNCTION_3       3  ''
             3422  POP_TOP          

 L.6799      3424  LOAD_NAME                add_newdoc_for_scalar_type
         3426_3428  LOAD_STR                 'longdouble'
         3430_3432  LOAD_STR                 'longfloat'
             3434  BUILD_LIST_1          1 

 L.6800  3436_3438  LOAD_STR                 '\n    Extended-precision floating-point number type, compatible with C\n    ``long double`` but not necessarily with IEEE 754 quadruple-precision.\n    '

 L.6799      3440  CALL_FUNCTION_3       3  ''
             3442  POP_TOP          

 L.6805      3444  LOAD_NAME                add_newdoc_for_scalar_type
         3446_3448  LOAD_STR                 'csingle'
         3450_3452  LOAD_STR                 'singlecomplex'
             3454  BUILD_LIST_1          1 

 L.6806  3456_3458  LOAD_STR                 '\n    Complex number type composed of two single-precision floating-point\n    numbers.\n    '

 L.6805      3460  CALL_FUNCTION_3       3  ''
             3462  POP_TOP          

 L.6811      3464  LOAD_NAME                add_newdoc_for_scalar_type
         3466_3468  LOAD_STR                 'cdouble'
         3470_3472  LOAD_STR                 'cfloat'
         3474_3476  LOAD_STR                 'complex_'
             3478  BUILD_LIST_2          2 

 L.6812  3480_3482  LOAD_STR                 '\n    Complex number type composed of two double-precision floating-point\n    numbers, compatible with Python `complex`.\n    '

 L.6811      3484  CALL_FUNCTION_3       3  ''
             3486  POP_TOP          

 L.6817      3488  LOAD_NAME                add_newdoc_for_scalar_type
         3490_3492  LOAD_STR                 'clongdouble'
         3494_3496  LOAD_STR                 'clongfloat'
         3498_3500  LOAD_STR                 'longcomplex'
             3502  BUILD_LIST_2          2 

 L.6818  3504_3506  LOAD_STR                 '\n    Complex number type composed of two extended-precision floating-point\n    numbers.\n    '

 L.6817      3508  CALL_FUNCTION_3       3  ''
             3510  POP_TOP          

 L.6823      3512  LOAD_NAME                add_newdoc_for_scalar_type
         3514_3516  LOAD_STR                 'object_'
             3518  BUILD_LIST_0          0 

 L.6824  3520_3522  LOAD_STR                 '\n    Any Python object.\n    '

 L.6823      3524  CALL_FUNCTION_3       3  ''
             3526  POP_TOP          

 L.6829  3528_3530  LOAD_CONST               ('half', 'single', 'double', 'longdouble')
             3532  GET_ITER         
             3534  FOR_ITER           3572  'to 3572'
             3536  STORE_NAME               float_name

 L.6830      3538  LOAD_NAME                add_newdoc
             3540  LOAD_STR                 'numpy.core.numerictypes'
             3542  LOAD_NAME                float_name
         3544_3546  LOAD_STR                 'as_integer_ratio'

 L.6831  3548_3550  LOAD_STR                 '\n        {ftype}.as_integer_ratio() -> (int, int)\n\n        Return a pair of integers, whose ratio is exactly equal to the original\n        floating point number, and with a positive denominator.\n        Raise OverflowError on infinities and a ValueError on NaNs.\n\n        >>> np.{ftype}(10.0).as_integer_ratio()\n        (10, 1)\n        >>> np.{ftype}(0.0).as_integer_ratio()\n        (0, 1)\n        >>> np.{ftype}(-.25).as_integer_ratio()\n        (-1, 4)\n        '
             3552  LOAD_ATTR                format

 L.6844      3554  LOAD_NAME                float_name

 L.6831  3556_3558  LOAD_CONST               ('ftype',)
             3560  CALL_FUNCTION_KW_1     1  '1 total positional and keyword args'

 L.6830      3562  BUILD_TUPLE_2         2 
             3564  CALL_FUNCTION_3       3  ''
             3566  POP_TOP          
         3568_3570  JUMP_BACK          3534  'to 3534'

Parse error at or near `CALL_FINALLY' instruction at offset 3174

Instruction context:
   
 L.6686      3166  LOAD_NAME                numeric_type_aliases
                3168  BUILD_LIST_0          0 
            3170_3172  LOAD_CONST               (('int8', '8-bit signed integer (-128 to 127)'), ('int16', '16-bit signed integer (-32768 to 32767)'), ('int32', '32-bit signed integer (-2147483648 to 2147483647)'), ('int64', '64-bit signed integer (-9223372036854775808 to 9223372036854775807)'), ('intp', 'Signed integer large enough to fit pointer, compatible with C ``intptr_t``'), ('uint8', '8-bit unsigned integer (0 to 255)'), ('uint16', '16-bit unsigned integer (0 to 65535)'), ('uint32', '32-bit unsigned integer (0 to 4294967295)'), ('uint64', '64-bit unsigned integer (0 to 18446744073709551615)'), ('uintp', 'Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``'), ('float16', '16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa'), ('float32', '32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa'), ('float64', '64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa'), ('float96', '96-bit extended-precision floating-point number type'), ('float128', '128-bit extended-precision floating-point number type'), ('complex64', 'Complex number type composed of 2 32-bit-precision floating-point numbers'), ('complex128', 'Complex number type composed of 2 64-bit-precision floating-point numbers'), ('complex192', 'Complex number type composed of 2 96-bit extended-precision floating-point numbers'), ('complex256', 'Complex number type composed of 2 128-bit extended-precision floating-point numbers'))
->              3174  CALL_FINALLY       3177  'to 3177'
                3176  CALL_FUNCTION_1       1  ''
                3178  STORE_NAME               possible_aliases

test/1983.pyc -- 
# decompile failed
