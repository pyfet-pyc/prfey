# uncompyle6 version 3.7.4
# Python bytecode 3.8 (3413)
# Decompiled from: Python 3.6.15 (default, Sep 28 2021, 20:18:52) 
# [GCC 10.2.1 20210110]
# Embedded file name: lib2to3\pgen2\parse.py
"""Parser engine for the grammar tables generated by pgen.

The grammar table must be loaded first.

See Parser/parser.c in the Python distribution for additional info on
how this parsing engine works.

"""
from . import token

class ParseError(Exception):
    __doc__ = 'Exception to signal the parser is stuck.'

    def __init__(self, msg, type, value, context):
        Exception.__init__(self, '%s: type=%r, value=%r, context=%r' % (
         msg, type, value, context))
        self.msg = msg
        self.type = type
        self.value = value
        self.context = context

    def __reduce__(self):
        return (
         type(self), (self.msg, self.type, self.value, self.context))


class Parser(object):
    __doc__ = 'Parser engine.\n\n    The proper usage sequence is:\n\n    p = Parser(grammar, [converter])  # create instance\n    p.setup([start])                  # prepare for parsing\n    <for each input token>:\n        if p.addtoken(...):           # parse a token; may raise ParseError\n            break\n    root = p.rootnode                 # root of abstract syntax tree\n\n    A Parser instance may be reused by calling setup() repeatedly.\n\n    A Parser instance contains state pertaining to the current token\n    sequence, and should not be used concurrently by different threads\n    to parse separate token sequences.\n\n    See driver.py for how to get input tokens by tokenizing a file or\n    string.\n\n    Parsing is complete when addtoken() returns True; the root of the\n    abstract syntax tree can then be retrieved from the rootnode\n    instance variable.  When a syntax error occurs, addtoken() raises\n    the ParseError exception.  There is no error recovery; the parser\n    cannot be used after a syntax error was reported (but it can be\n    reinitialized by calling setup()).\n\n    '

    def __init__(self, grammar, convert=None):
        """Constructor.

        The grammar argument is a grammar.Grammar instance; see the
        grammar module for more information.

        The parser is not ready yet for parsing; you must call the
        setup() method to get it started.

        The optional convert argument is a function mapping concrete
        syntax tree nodes to abstract syntax tree nodes.  If not
        given, no conversion is done and the syntax tree produced is
        the concrete syntax tree.  If given, it must be a function of
        two arguments, the first being the grammar (a grammar.Grammar
        instance), and the second being the concrete syntax tree node
        to be converted.  The syntax tree is converted from the bottom
        up.

        A concrete syntax tree node is a (type, value, context, nodes)
        tuple, where type is the node type (a token or symbol number),
        value is None for symbols and a string for tokens, context is
        None or an opaque value used for error reporting (typically a
        (lineno, offset) pair), and nodes is a list of children for
        symbols, and None for tokens.

        An abstract syntax tree node may be anything; this is entirely
        up to the converter function.

        """
        self.grammar = grammar
        self.convert = convert or (lambda grammar, node: node)

    def setup(self, start=None):
        """Prepare for parsing.

        This *must* be called before starting to parse.

        The optional argument is an alternative start symbol; it
        defaults to the grammar's start symbol.

        You can use a Parser instance to parse any number of programs;
        each time you call setup() the parser is reset to an initial
        state determined by the (implicit or explicit) start symbol.

        """
        if start is None:
            start = self.grammar.start
        newnode = (
         start, None, None, [])
        stackentry = (self.grammar.dfas[start], 0, newnode)
        self.stack = [stackentry]
        self.rootnode = None
        self.used_names = set()

    def addtoken--- This code section failed: ---

 L. 119         0  LOAD_FAST                'self'
                2  LOAD_METHOD              classify
                4  LOAD_FAST                'type'
                6  LOAD_FAST                'value'
                8  LOAD_FAST                'context'
               10  CALL_METHOD_3         3  ''
               12  STORE_FAST               'ilabel'

 L. 122        14  LOAD_FAST                'self'
               16  LOAD_ATTR                stack
               18  LOAD_CONST               -1
               20  BINARY_SUBSCR    
               22  UNPACK_SEQUENCE_3     3 
               24  STORE_FAST               'dfa'
               26  STORE_FAST               'state'
               28  STORE_FAST               'node'

 L. 123        30  LOAD_FAST                'dfa'
               32  UNPACK_SEQUENCE_2     2 
               34  STORE_FAST               'states'
               36  STORE_FAST               'first'

 L. 124        38  LOAD_FAST                'states'
               40  LOAD_FAST                'state'
               42  BINARY_SUBSCR    
               44  STORE_FAST               'arcs'

 L. 126        46  LOAD_FAST                'arcs'
               48  GET_ITER         
             50_0  COME_FROM           218  '218'
             50_1  COME_FROM           190  '190'
               50  FOR_ITER            250  'to 250'
               52  UNPACK_SEQUENCE_2     2 
               54  STORE_FAST               'i'
               56  STORE_FAST               'newstate'

 L. 127        58  LOAD_FAST                'self'
               60  LOAD_ATTR                grammar
               62  LOAD_ATTR                labels
               64  LOAD_FAST                'i'
               66  BINARY_SUBSCR    
               68  UNPACK_SEQUENCE_2     2 
               70  STORE_FAST               't'
               72  STORE_FAST               'v'

 L. 128        74  LOAD_FAST                'ilabel'
               76  LOAD_FAST                'i'
               78  COMPARE_OP               ==
               80  POP_JUMP_IF_FALSE   184  'to 184'

 L. 130        82  LOAD_FAST                't'
               84  LOAD_CONST               256
               86  COMPARE_OP               <
               88  POP_JUMP_IF_TRUE     94  'to 94'
               90  LOAD_ASSERT              AssertionError
               92  RAISE_VARARGS_1       1  'exception instance'
             94_0  COME_FROM            88  '88'

 L. 132        94  LOAD_FAST                'self'
               96  LOAD_METHOD              shift
               98  LOAD_FAST                'type'
              100  LOAD_FAST                'value'
              102  LOAD_FAST                'newstate'
              104  LOAD_FAST                'context'
              106  CALL_METHOD_4         4  ''
              108  POP_TOP          

 L. 134       110  LOAD_FAST                'newstate'
              112  STORE_FAST               'state'

 L. 135       114  LOAD_FAST                'states'
              116  LOAD_FAST                'state'
              118  BINARY_SUBSCR    
              120  LOAD_CONST               0
              122  LOAD_FAST                'state'
              124  BUILD_TUPLE_2         2 
              126  BUILD_LIST_1          1 
              128  COMPARE_OP               ==
              130  POP_JUMP_IF_FALSE   178  'to 178'

 L. 136       132  LOAD_FAST                'self'
              134  LOAD_METHOD              pop
              136  CALL_METHOD_0         0  ''
              138  POP_TOP          

 L. 137       140  LOAD_FAST                'self'
              142  LOAD_ATTR                stack
              144  POP_JUMP_IF_TRUE    152  'to 152'

 L. 139       146  POP_TOP          
              148  LOAD_CONST               True
              150  RETURN_VALUE     
            152_0  COME_FROM           144  '144'

 L. 140       152  LOAD_FAST                'self'
              154  LOAD_ATTR                stack
              156  LOAD_CONST               -1
              158  BINARY_SUBSCR    
              160  UNPACK_SEQUENCE_3     3 
              162  STORE_FAST               'dfa'
              164  STORE_FAST               'state'
              166  STORE_FAST               'node'

 L. 141       168  LOAD_FAST                'dfa'
              170  UNPACK_SEQUENCE_2     2 
              172  STORE_FAST               'states'
              174  STORE_FAST               'first'
              176  JUMP_BACK           114  'to 114'
            178_0  COME_FROM           130  '130'

 L. 143       178  POP_TOP          
              180  LOAD_CONST               False
              182  RETURN_VALUE     
            184_0  COME_FROM            80  '80'

 L. 144       184  LOAD_FAST                't'
              186  LOAD_CONST               256
              188  COMPARE_OP               >=
              190  POP_JUMP_IF_FALSE    50  'to 50'

 L. 146       192  LOAD_FAST                'self'
              194  LOAD_ATTR                grammar
              196  LOAD_ATTR                dfas
              198  LOAD_FAST                't'
              200  BINARY_SUBSCR    
              202  STORE_FAST               'itsdfa'

 L. 147       204  LOAD_FAST                'itsdfa'
              206  UNPACK_SEQUENCE_2     2 
              208  STORE_FAST               'itsstates'
              210  STORE_FAST               'itsfirst'

 L. 148       212  LOAD_FAST                'ilabel'
              214  LOAD_FAST                'itsfirst'
              216  COMPARE_OP               in
              218  POP_JUMP_IF_FALSE    50  'to 50'

 L. 150       220  LOAD_FAST                'self'
              222  LOAD_METHOD              push
              224  LOAD_FAST                't'
              226  LOAD_FAST                'self'
              228  LOAD_ATTR                grammar
              230  LOAD_ATTR                dfas
              232  LOAD_FAST                't'
              234  BINARY_SUBSCR    
              236  LOAD_FAST                'newstate'
              238  LOAD_FAST                'context'
              240  CALL_METHOD_4         4  ''
              242  POP_TOP          

 L. 151       244  POP_TOP          
              246  CONTINUE             14  'to 14'
              248  JUMP_BACK            50  'to 50'

 L. 153       250  LOAD_CONST               0
              252  LOAD_FAST                'state'
              254  BUILD_TUPLE_2         2 
              256  LOAD_FAST                'arcs'
              258  COMPARE_OP               in
          260_262  POP_JUMP_IF_FALSE   296  'to 296'

 L. 155       264  LOAD_FAST                'self'
              266  LOAD_METHOD              pop
              268  CALL_METHOD_0         0  ''
              270  POP_TOP          

 L. 156       272  LOAD_FAST                'self'
              274  LOAD_ATTR                stack
          276_278  POP_JUMP_IF_TRUE    310  'to 310'

 L. 158       280  LOAD_GLOBAL              ParseError
              282  LOAD_STR                 'too much input'

 L. 159       284  LOAD_FAST                'type'

 L. 159       286  LOAD_FAST                'value'

 L. 159       288  LOAD_FAST                'context'

 L. 158       290  CALL_FUNCTION_4       4  ''
              292  RAISE_VARARGS_1       1  'exception instance'
              294  JUMP_BACK            14  'to 14'
            296_0  COME_FROM           260  '260'

 L. 162       296  LOAD_GLOBAL              ParseError
              298  LOAD_STR                 'bad input'
              300  LOAD_FAST                'type'
              302  LOAD_FAST                'value'
              304  LOAD_FAST                'context'
              306  CALL_FUNCTION_4       4  ''
              308  RAISE_VARARGS_1       1  'exception instance'
            310_0  COME_FROM           276  '276'
              310  JUMP_BACK            14  'to 14'

Parse error at or near `CONTINUE' instruction at offset 246

    def classify(self, type, value, context):
        """Turn a token into a label.  (Internal)"""
        if type == token.NAME:
            self.used_names.add(value)
            ilabel = self.grammar.keywords.get(value)
            if ilabel is not None:
                return ilabel
        ilabel = self.grammar.tokens.get(type)
        if ilabel is None:
            raise ParseError'bad token'typevaluecontext
        return ilabel

    def shift(self, type, value, newstate, context):
        """Shift a token.  (Internal)"""
        dfa, state, node = self.stack[(-1)]
        newnode = (type, value, context, None)
        newnode = self.convert(self.grammar, newnode)
        if newnode is not None:
            node[(-1)].append(newnode)
        self.stack[-1] = (
         dfa, newstate, node)

    def push(self, type, newdfa, newstate, context):
        """Push a nonterminal.  (Internal)"""
        dfa, state, node = self.stack[(-1)]
        newnode = (type, None, context, [])
        self.stack[-1] = (dfa, newstate, node)
        self.stack.append((newdfa, 0, newnode))

    def pop(self):
        """Pop a nonterminal.  (Internal)"""
        popdfa, popstate, popnode = self.stack.pop
        newnode = self.convert(self.grammar, popnode)
        if newnode is not None:
            if self.stack:
                dfa, state, node = self.stack[(-1)]
                node[(-1)].append(newnode)
            else:
                self.rootnode = newnode
                self.rootnode.used_names = self.used_names