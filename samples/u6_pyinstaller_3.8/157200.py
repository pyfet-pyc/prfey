# uncompyle6 version 3.7.4
# Python bytecode 3.8 (3413)
# Decompiled from: Python 3.6.15 (default, Sep 28 2021, 20:18:52) 
# [GCC 10.2.1 20210110]
# Embedded file name: site-packages\numpy\distutils\conv_template.py
"""
takes templated file .xxx.src and produces .xxx file  where .xxx is
.i or .c or .h, using the following template rules

/**begin repeat  -- on a line by itself marks the start of a repeated code
                    segment
/**end repeat**/ -- on a line by itself marks it's end

After the /**begin repeat and before the */, all the named templates are placed
these should all have the same number of replacements

Repeat blocks can be nested, with each nested block labeled with its depth,
i.e.
/**begin repeat1
 *....
 */
/**end repeat1**/

When using nested loops, you can optionally exclude particular
combinations of the variables using (inside the comment portion of the inner loop):

 :exclude: var1=value1, var2=value2, ...

This will exclude the pattern where var1 is value1 and var2 is value2 when
the result is being generated.

In the main body each replace will use one entry from the list of named replacements

 Note that all #..# forms in a block must have the same number of
   comma-separated entries.

Example:

    An input file containing

        /**begin repeat
         * #a = 1,2,3#
         * #b = 1,2,3#
         */

        /**begin repeat1
         * #c = ted, jim#
         */
        @a@, @b@, @c@
        /**end repeat1**/

        /**end repeat**/

    produces

        line 1 "template.c.src"

        /*
         *********************************************************************
         **       This file was autogenerated from a template  DO NOT EDIT!!**
         **       Changes should be made to the original source (.src) file **
         *********************************************************************
         */

        #line 9
        1, 1, ted

        #line 9
        1, 1, jim

        #line 9
        2, 2, ted

        #line 9
        2, 2, jim

        #line 9
        3, 3, ted

        #line 9
        3, 3, jim

"""
__all__ = [
 'process_str', 'process_file']
import os, sys, re
global_names = {}
header = '\n/*\n *****************************************************************************\n **       This file was autogenerated from a template  DO NOT EDIT!!!!      **\n **       Changes should be made to the original source (.src) file         **\n *****************************************************************************\n */\n\n'

def parse_structure(astr, level):
    """
    The returned line number is from the beginning of the string, starting
    at zero. Returns an empty list if no loops found.

    """
    if level == 0:
        loopbeg = '/**begin repeat'
        loopend = '/**end repeat**/'
    else:
        loopbeg = '/**begin repeat%d' % level
        loopend = '/**end repeat%d**/' % level
    ind = 0
    line = 0
    spanlist = []
    while True:
        start = astr.find(loopbeg, ind)
        if start == -1:
            break
        start2 = astr.find('*/', start)
        start2 = astr.find('\n', start2)
        fini1 = astr.find(loopend, start2)
        fini2 = astr.find('\n', fini1)
        line += astr.count('\n', ind, start2 + 1)
        spanlist.append((start, start2 + 1, fini1, fini2 + 1, line))
        line += astr.count('\n', start2 + 1, fini2)
        ind = fini2

    spanlist.sort()
    return spanlist


def paren_repl(obj):
    torep = obj.group(1)
    numrep = obj.group(2)
    return ','.join([torep] * int(numrep))


parenrep = re.compile('[(]([^)]*)[)]\\*(\\d+)')
plainrep = re.compile('([^*]+)\\*(\\d+)')

def parse_values(astr):
    astr = parenrep.sub(paren_repl, astr)
    astr = ','.join([plainrep.sub(paren_repl, x.strip()) for x in astr.split(',')])
    return astr.split(',')


stripast = re.compile('\\n\\s*\\*?')
named_re = re.compile('#\\s*(\\w*)\\s*=([^#]*)#')
exclude_vars_re = re.compile('(\\w*)=(\\w*)')
exclude_re = re.compile(':exclude:')

def parse_loop_header--- This code section failed: ---

 L. 173         0  LOAD_GLOBAL              stripast
                2  LOAD_METHOD              sub
                4  LOAD_STR                 ''
                6  LOAD_FAST                'loophead'
                8  CALL_METHOD_2         2  ''
               10  STORE_FAST               'loophead'

 L. 175        12  BUILD_LIST_0          0 
               14  STORE_FAST               'names'

 L. 176        16  LOAD_GLOBAL              named_re
               18  LOAD_METHOD              findall
               20  LOAD_FAST                'loophead'
               22  CALL_METHOD_1         1  ''
               24  STORE_FAST               'reps'

 L. 177        26  LOAD_CONST               None
               28  STORE_FAST               'nsub'

 L. 178        30  LOAD_FAST                'reps'
               32  GET_ITER         
               34  FOR_ITER            128  'to 128'
               36  STORE_FAST               'rep'

 L. 179        38  LOAD_FAST                'rep'
               40  LOAD_CONST               0
               42  BINARY_SUBSCR    
               44  STORE_FAST               'name'

 L. 180        46  LOAD_GLOBAL              parse_values
               48  LOAD_FAST                'rep'
               50  LOAD_CONST               1
               52  BINARY_SUBSCR    
               54  CALL_FUNCTION_1       1  ''
               56  STORE_FAST               'vals'

 L. 181        58  LOAD_GLOBAL              len
               60  LOAD_FAST                'vals'
               62  CALL_FUNCTION_1       1  ''
               64  STORE_FAST               'size'

 L. 182        66  LOAD_FAST                'nsub'
               68  LOAD_CONST               None
               70  COMPARE_OP               is
               72  POP_JUMP_IF_FALSE    80  'to 80'

 L. 183        74  LOAD_FAST                'size'
               76  STORE_FAST               'nsub'
               78  JUMP_FORWARD        112  'to 112'
             80_0  COME_FROM            72  '72'

 L. 184        80  LOAD_FAST                'nsub'
               82  LOAD_FAST                'size'
               84  COMPARE_OP               !=
               86  POP_JUMP_IF_FALSE   112  'to 112'

 L. 185        88  LOAD_STR                 'Mismatch in number of values, %d != %d\n%s = %s'
               90  STORE_FAST               'msg'

 L. 186        92  LOAD_GLOBAL              ValueError
               94  LOAD_FAST                'msg'
               96  LOAD_FAST                'nsub'
               98  LOAD_FAST                'size'
              100  LOAD_FAST                'name'
              102  LOAD_FAST                'vals'
              104  BUILD_TUPLE_4         4 
              106  BINARY_MODULO    
              108  CALL_FUNCTION_1       1  ''
              110  RAISE_VARARGS_1       1  'exception instance'
            112_0  COME_FROM            86  '86'
            112_1  COME_FROM            78  '78'

 L. 187       112  LOAD_FAST                'names'
              114  LOAD_METHOD              append
              116  LOAD_FAST                'name'
              118  LOAD_FAST                'vals'
              120  BUILD_TUPLE_2         2 
              122  CALL_METHOD_1         1  ''
              124  POP_TOP          
              126  JUMP_BACK            34  'to 34'

 L. 191       128  BUILD_LIST_0          0 
              130  STORE_FAST               'excludes'

 L. 193       132  LOAD_GLOBAL              exclude_re
              134  LOAD_METHOD              finditer
              136  LOAD_FAST                'loophead'
              138  CALL_METHOD_1         1  ''
              140  GET_ITER         
              142  FOR_ITER            212  'to 212'
              144  STORE_FAST               'obj'

 L. 194       146  LOAD_FAST                'obj'
              148  LOAD_METHOD              span
              150  CALL_METHOD_0         0  ''
              152  STORE_FAST               'span'

 L. 196       154  LOAD_FAST                'loophead'
              156  LOAD_METHOD              find
              158  LOAD_STR                 '\n'
              160  LOAD_FAST                'span'
              162  LOAD_CONST               1
              164  BINARY_SUBSCR    
              166  CALL_METHOD_2         2  ''
              168  STORE_FAST               'endline'

 L. 197       170  LOAD_FAST                'loophead'
              172  LOAD_FAST                'span'
              174  LOAD_CONST               1
              176  BINARY_SUBSCR    
              178  LOAD_FAST                'endline'
              180  BUILD_SLICE_2         2 
              182  BINARY_SUBSCR    
              184  STORE_FAST               'substr'

 L. 198       186  LOAD_GLOBAL              exclude_vars_re
              188  LOAD_METHOD              findall
              190  LOAD_FAST                'substr'
              192  CALL_METHOD_1         1  ''
              194  STORE_FAST               'ex_names'

 L. 199       196  LOAD_FAST                'excludes'
              198  LOAD_METHOD              append
              200  LOAD_GLOBAL              dict
              202  LOAD_FAST                'ex_names'
              204  CALL_FUNCTION_1       1  ''
              206  CALL_METHOD_1         1  ''
              208  POP_TOP          
              210  JUMP_BACK           142  'to 142'

 L. 202       212  BUILD_LIST_0          0 
              214  STORE_FAST               'dlist'

 L. 203       216  LOAD_FAST                'nsub'
              218  LOAD_CONST               None
              220  COMPARE_OP               is
              222  POP_JUMP_IF_FALSE   232  'to 232'

 L. 204       224  LOAD_GLOBAL              ValueError
              226  LOAD_STR                 'No substitution variables found'
              228  CALL_FUNCTION_1       1  ''
              230  RAISE_VARARGS_1       1  'exception instance'
            232_0  COME_FROM           222  '222'

 L. 205       232  LOAD_GLOBAL              range
              234  LOAD_FAST                'nsub'
              236  CALL_FUNCTION_1       1  ''
              238  GET_ITER         
              240  FOR_ITER            274  'to 274'
              242  STORE_DEREF              'i'

 L. 206       244  LOAD_CLOSURE             'i'
              246  BUILD_TUPLE_1         1 
              248  LOAD_DICTCOMP            '<code_object <dictcomp>>'
              250  LOAD_STR                 'parse_loop_header.<locals>.<dictcomp>'
              252  MAKE_FUNCTION_8          'closure'
              254  LOAD_FAST                'names'
              256  GET_ITER         
              258  CALL_FUNCTION_1       1  ''
              260  STORE_FAST               'tmp'

 L. 207       262  LOAD_FAST                'dlist'
              264  LOAD_METHOD              append
              266  LOAD_FAST                'tmp'
              268  CALL_METHOD_1         1  ''
              270  POP_TOP          
              272  JUMP_BACK           240  'to 240'

 L. 208       274  LOAD_FAST                'dlist'
              276  RETURN_VALUE     
               -1  RETURN_LAST      

Parse error at or near `LOAD_DICTCOMP' instruction at offset 248


replace_re = re.compile('@([\\w]+)@')

def parse_string(astr, env, level, line):
    lineno = '#line %d\n' % line

    def replace(match):
        name = match.group(1)
        try:
            val = env[name]
        except KeyError:
            msg = 'line %d: no definition of key "%s"' % (line, name)
            raise ValueError(msg)
        else:
            return val

    code = [lineno]
    struct = parse_structure(astr, level)
    if struct:
        oldend = 0
        newlevel = level + 1
        for sub in struct:
            pref = astr[oldend:sub[0]]
            head = astr[sub[0]:sub[1]]
            text = astr[sub[1]:sub[2]]
            oldend = sub[3]
            newline = line + sub[4]
            code.append(replace_re.sub(replace, pref))

        try:
            envlist = parse_loop_header(head)
        except ValueError as e:
            try:
                msg = 'line %d: %s' % (newline, e)
                raise ValueError(msg)
            finally:
                e = None
                del e

        else:
            for newenv in envlist:
                newenv.update(env)
                newcode = parse_string(text, newenv, newlevel, newline)
                code.extend(newcode)
            else:
                suff = astr[oldend:]
                code.append(replace_re.sub(replace, suff))

    else:
        code.append(replace_re.sub(replace, astr))
    code.append('\n')
    return ''.join(code)


def process_str(astr):
    code = [
     header]
    code.extend(parse_string(astr, global_names, 0, 1))
    return ''.join(code)


include_src_re = re.compile('(\\n|\\A)#include\\s*[\'\\"](?P<name>[\\w\\d./\\\\]+[.]src)[\'\\"]', re.I)

def resolve_includes(source):
    d = os.path.dirname(source)
    with open(source) as (fid):
        lines = []
        for line in fid:
            m = include_src_re.match(line)
            if m:
                fn = m.group('name')
                if not os.path.isabs(fn):
                    fn = os.path.join(d, fn)
                if os.path.isfile(fn):
                    print('Including file', fn)
                    lines.extend(resolve_includes(fn))
                else:
                    lines.append(line)
            else:
                lines.append(line)

    return lines


def process_file(source):
    lines = resolve_includes(source)
    sourcefile = os.path.normcase(source).replace('\\', '\\\\')
    try:
        code = process_str(''.join(lines))
    except ValueError as e:
        try:
            raise ValueError('In "%s" loop at %s' % (sourcefile, e))
        finally:
            e = None
            del e

    else:
        return '#line 1 "%s"\n%s' % (sourcefile, code)


def unique_key(adict):
    allkeys = list(adict.keys())
    done = False
    n = 1
    while not done:
        newkey = ''.join([x[:n] for x in allkeys])
        if newkey in allkeys:
            n += 1
        else:
            done = True

    return newkey


def main():
    try:
        file = sys.argv[1]
    except IndexError:
        fid = sys.stdin
        outfile = sys.stdout
    else:
        fid = open(file, 'r')
        base, ext = os.path.splitext(file)
        newname = base
        outfile = open(newname, 'w')
    allstr = fid.read()
    try:
        writestr = process_str(allstr)
    except ValueError as e:
        try:
            raise ValueError('In %s loop at %s' % (file, e))
        finally:
            e = None
            del e

    else:
        outfile.write(writestr)


if __name__ == '__main__':
    main()