# uncompyle6 version 3.7.4
# Python bytecode 3.8 (3413)
# Decompiled from: Python 3.6.15 (default, Sep 28 2021, 20:18:52) 
# [GCC 10.2.1 20210110]
# Embedded file name: site-packages\dns\tsig.py
"""DNS TSIG support."""
import hashlib, hmac, struct, dns.exception, dns.rdataclass, dns.name
from ._compat import long, string_types, text_type

class BadTime(dns.exception.DNSException):
    __doc__ = "The current time is not within the TSIG's validity time."


class BadSignature(dns.exception.DNSException):
    __doc__ = 'The TSIG signature fails to verify.'


class PeerError(dns.exception.DNSException):
    __doc__ = 'Base class for all TSIG errors generated by the remote peer'


class PeerBadKey(PeerError):
    __doc__ = "The peer didn't know the key we used"


class PeerBadSignature(PeerError):
    __doc__ = "The peer didn't like the signature we sent"


class PeerBadTime(PeerError):
    __doc__ = "The peer didn't like the time we sent"


class PeerBadTruncation(PeerError):
    __doc__ = "The peer didn't like amount of truncation in the TSIG we sent"


HMAC_MD5 = dns.name.from_text('HMAC-MD5.SIG-ALG.REG.INT')
HMAC_SHA1 = dns.name.from_text('hmac-sha1')
HMAC_SHA224 = dns.name.from_text('hmac-sha224')
HMAC_SHA256 = dns.name.from_text('hmac-sha256')
HMAC_SHA384 = dns.name.from_text('hmac-sha384')
HMAC_SHA512 = dns.name.from_text('hmac-sha512')
_hashes = {HMAC_SHA224: hashlib.sha224, 
 HMAC_SHA256: hashlib.sha256, 
 HMAC_SHA384: hashlib.sha384, 
 HMAC_SHA512: hashlib.sha512, 
 HMAC_SHA1: hashlib.sha1, 
 HMAC_MD5: hashlib.md5}
default_algorithm = HMAC_MD5
BADSIG = 16
BADKEY = 17
BADTIME = 18
BADTRUNC = 22

def sign(wire, keyname, secret, time, fudge, original_id, error, other_data, request_mac, ctx=None, multi=False, first=True, algorithm=default_algorithm):
    """Return a (tsig_rdata, mac, ctx) tuple containing the HMAC TSIG rdata
    for the input parameters, the HMAC MAC calculated by applying the
    TSIG signature algorithm, and the TSIG digest context.
    @rtype: (string, string, hmac.HMAC object)
    @raises ValueError: I{other_data} is too long
    @raises NotImplementedError: I{algorithm} is not supported
    """
    if isinstance(other_data, text_type):
        other_data = other_data.encode()
    else:
        algorithm_name, digestmod = get_algorithm(algorithm)
        if first:
            ctx = hmac.new(secret, digestmod=digestmod)
            ml = len(request_mac)
            if ml > 0:
                ctx.update(struct.pack('!H', ml))
                ctx.update(request_mac)
            else:
                id = struct.pack('!H', original_id)
                ctx.update(id)
                ctx.update(wire[2:])
                if first:
                    ctx.update(keyname.to_digestable())
                    ctx.update(struct.pack('!H', dns.rdataclass.ANY))
                    ctx.update(struct.pack('!I', 0))
                long_time = time + long(0)
                upper_time = long_time >> 32 & long(65535)
                lower_time = long_time & long(4294967295)
                time_mac = struct.pack('!HIH', upper_time, lower_time, fudge)
                pre_mac = algorithm_name + time_mac
                ol = len(other_data)
                if ol > 65535:
                    raise ValueError('TSIG Other Data is > 65535 bytes')
                post_mac = struct.pack('!HH', error, ol) + other_data
                if first:
                    ctx.update(pre_mac)
                    ctx.update(post_mac)
                else:
                    ctx.update(time_mac)
            mac = ctx.digest()
            mpack = struct.pack('!H', len(mac))
            tsig_rdata = pre_mac + mpack + mac + id + post_mac
            if multi:
                ctx = hmac.new(secret, digestmod=digestmod)
                ml = len(mac)
                ctx.update(struct.pack('!H', ml))
                ctx.update(mac)
        else:
            ctx = None
    return (
     tsig_rdata, mac, ctx)


def hmac_md5(wire, keyname, secret, time, fudge, original_id, error, other_data, request_mac, ctx=None, multi=False, first=True, algorithm=default_algorithm):
    return sign(wire, keyname, secret, time, fudge, original_id, error, other_data, request_mac, ctx, multi, first, algorithm)


def validate(wire, keyname, secret, now, request_mac, tsig_start, tsig_rdata, tsig_rdlen, ctx=None, multi=False, first=True):
    """Validate the specified TSIG rdata against the other input parameters.

    @raises FormError: The TSIG is badly formed.
    @raises BadTime: There is too much time skew between the client and the
    server.
    @raises BadSignature: The TSIG signature did not validate
    @rtype: hmac.HMAC object"""
    adcount, = struct.unpack('!H', wire[10:12])
    if adcount == 0:
        raise dns.exception.FormError
    else:
        adcount -= 1
        new_wire = wire[0:10] + struct.pack('!H', adcount) + wire[12:tsig_start]
        current = tsig_rdata
        aname, used = dns.name.from_wire(wire, current)
        current = current + used
        upper_time, lower_time, fudge, mac_size = struct.unpack('!HIHH', wire[current:current + 10])
        time = (upper_time + long(0) << 32) + (lower_time + long(0))
        current += 10
        mac = wire[current:current + mac_size]
        current += mac_size
        original_id, error, other_size = struct.unpack('!HHH', wire[current:current + 6])
        current += 6
        other_data = wire[current:current + other_size]
        current += other_size
        if current != tsig_rdata + tsig_rdlen:
            raise dns.exception.FormError
        if error != 0:
            if error == BADSIG:
                raise PeerBadSignature
            else:
                if error == BADKEY:
                    raise PeerBadKey
                else:
                    if error == BADTIME:
                        raise PeerBadTime
                    else:
                        if error == BADTRUNC:
                            raise PeerBadTruncation
                        else:
                            raise PeerError('unknown TSIG error code %d' % error)
    time_low = time - fudge
    time_high = time + fudge
    if now < time_low or now > time_high:
        raise BadTime
    junk, our_mac, ctx = sign(new_wire, keyname, secret, time, fudge, original_id, error, other_data, request_mac, ctx, multi, first, aname)
    if our_mac != mac:
        raise BadSignature
    return ctx


def get_algorithm--- This code section failed: ---

 L. 212         0  LOAD_GLOBAL              isinstance
                2  LOAD_FAST                'algorithm'
                4  LOAD_GLOBAL              string_types
                6  CALL_FUNCTION_2       2  ''
                8  POP_JUMP_IF_FALSE    22  'to 22'

 L. 213        10  LOAD_GLOBAL              dns
               12  LOAD_ATTR                name
               14  LOAD_METHOD              from_text
               16  LOAD_FAST                'algorithm'
               18  CALL_METHOD_1         1  ''
               20  STORE_FAST               'algorithm'
             22_0  COME_FROM             8  '8'

 L. 215        22  SETUP_FINALLY        42  'to 42'

 L. 216        24  LOAD_FAST                'algorithm'
               26  LOAD_METHOD              to_digestable
               28  CALL_METHOD_0         0  ''
               30  LOAD_GLOBAL              _hashes
               32  LOAD_FAST                'algorithm'
               34  BINARY_SUBSCR    
               36  BUILD_TUPLE_2         2 
               38  POP_BLOCK        
               40  RETURN_VALUE     
             42_0  COME_FROM_FINALLY    22  '22'

 L. 217        42  DUP_TOP          
               44  LOAD_GLOBAL              KeyError
               46  COMPARE_OP               exception-match
               48  POP_JUMP_IF_FALSE    80  'to 80'
               50  POP_TOP          
               52  POP_TOP          
               54  POP_TOP          

 L. 218        56  LOAD_GLOBAL              NotImplementedError
               58  LOAD_STR                 'TSIG algorithm '
               60  LOAD_GLOBAL              str
               62  LOAD_FAST                'algorithm'
               64  CALL_FUNCTION_1       1  ''
               66  BINARY_ADD       

 L. 219        68  LOAD_STR                 ' is not supported'

 L. 218        70  BINARY_ADD       
               72  CALL_FUNCTION_1       1  ''
               74  RAISE_VARARGS_1       1  'exception instance'
               76  POP_EXCEPT       
               78  JUMP_FORWARD         82  'to 82'
             80_0  COME_FROM            48  '48'
               80  END_FINALLY      
             82_0  COME_FROM            78  '78'

Parse error at or near `POP_TOP' instruction at offset 52


def get_algorithm_and_mac(wire, tsig_rdata, tsig_rdlen):
    """Return the tsig algorithm for the specified tsig_rdata
    @raises FormError: The TSIG is badly formed.
    """
    current = tsig_rdata
    aname, used = dns.name.from_wire(wire, current)
    current = current + used
    upper_time, lower_time, fudge, mac_size = struct.unpack('!HIHH', wire[current:current + 10])
    current += 10
    mac = wire[current:current + mac_size]
    current += mac_size
    if current > tsig_rdata + tsig_rdlen:
        raise dns.exception.FormError
    return (
     aname, mac)