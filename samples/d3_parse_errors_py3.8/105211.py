# decompyle3 version 3.7.5
# Python bytecode 3.8 (3413)
# Decompiled from: Python 3.8.11 (default, Aug 17 2021, 15:56:41) 
# [GCC 10.2.1 20210110]
# Embedded file name: site-packages\pynput\_util\win32.py
"""
Utility functions and classes for the *win32* backend.
"""
import contextlib, ctypes, itertools, threading
from ctypes import windll, wintypes
from . import AbstractListener, win32_vks as VK
if not hasattr(wintypes, 'LPDWORD'):
    wintypes.LPDWORD = ctypes.POINTER(wintypes.DWORD)

class MOUSEINPUT(ctypes.Structure):
    __doc__ = 'Contains information about a simulated mouse event.\n    '
    MOVE = 1
    LEFTDOWN = 2
    LEFTUP = 4
    RIGHTDOWN = 8
    RIGHTUP = 16
    MIDDLEDOWN = 32
    MIDDLEUP = 64
    XDOWN = 128
    XUP = 256
    WHEEL = 2048
    HWHEEL = 4096
    ABSOLUTE = 32768
    XBUTTON1 = 1
    XBUTTON2 = 2
    _fields_ = [
     (
      'dx', wintypes.LONG),
     (
      'dy', wintypes.LONG),
     (
      'mouseData', wintypes.DWORD),
     (
      'dwFlags', wintypes.DWORD),
     (
      'time', wintypes.DWORD),
     (
      'dwExtraInfo', ctypes.c_void_p)]


class KEYBDINPUT(ctypes.Structure):
    __doc__ = 'Contains information about a simulated keyboard event.\n    '
    EXTENDEDKEY = 1
    KEYUP = 2
    SCANCODE = 8
    UNICODE = 4
    _fields_ = [
     (
      'wVk', wintypes.WORD),
     (
      'wScan', wintypes.WORD),
     (
      'dwFlags', wintypes.DWORD),
     (
      'time', wintypes.DWORD),
     (
      'dwExtraInfo', ctypes.c_void_p)]


class HARDWAREINPUT(ctypes.Structure):
    __doc__ = 'Contains information about a simulated message generated by an input\n    device other than a keyboard or mouse.\n    '
    _fields_ = [
     (
      'uMsg', wintypes.DWORD),
     (
      'wParamL', wintypes.WORD),
     (
      'wParamH', wintypes.WORD)]


class INPUT_union(ctypes.Union):
    __doc__ = 'Represents the union of input types in :class:`INPUT`.\n    '
    _fields_ = [
     (
      'mi', MOUSEINPUT),
     (
      'ki', KEYBDINPUT),
     (
      'hi', HARDWAREINPUT)]


class INPUT(ctypes.Structure):
    __doc__ = 'Used by :attr:`SendInput` to store information for synthesizing input\n    events such as keystrokes, mouse movement, and mouse clicks.\n    '
    MOUSE = 0
    KEYBOARD = 1
    HARDWARE = 2
    _fields_ = [
     (
      'type', wintypes.DWORD),
     (
      'value', INPUT_union)]


LPINPUT = ctypes.POINTER(INPUT)
VkKeyScan = windll.user32.VkKeyScanW
VkKeyScan.argtypes = (
 wintypes.WCHAR,)
SendInput = windll.user32.SendInput
SendInput.argtypes = (
 wintypes.UINT,
 ctypes.c_voidp,
 ctypes.c_int)
GetCurrentThreadId = windll.kernel32.GetCurrentThreadId
GetCurrentThreadId.restype = wintypes.DWORD

class MessageLoop(object):
    __doc__ = 'A class representing a message loop.\n    '
    WM_STOP = 1025
    _LPMSG = ctypes.POINTER(wintypes.MSG)
    _GetMessage = windll.user32.GetMessageW
    _GetMessage.argtypes = (
     ctypes.c_voidp,
     wintypes.HWND,
     wintypes.UINT,
     wintypes.UINT)
    _PeekMessage = windll.user32.PeekMessageW
    _PeekMessage.argtypes = (
     ctypes.c_voidp,
     wintypes.HWND,
     wintypes.UINT,
     wintypes.UINT,
     wintypes.UINT)
    _PostThreadMessage = windll.user32.PostThreadMessageW
    _PostThreadMessage.argtypes = (
     wintypes.DWORD,
     wintypes.UINT,
     wintypes.WPARAM,
     wintypes.LPARAM)
    PM_NOREMOVE = 0

    def __init__(self):
        self._threadid = None
        self._event = threading.Event()
        self.thread = None

    def __iter__(self):
        """Initialises the message loop and yields all messages until
        :meth:`stop` is called.

        :raises AssertionError: if :meth:`start` has not been called
        """
        assert self._threadid is not None
        try:
            while True:
                while True:
                    msg = wintypes.MSG()
                    lpmsg = ctypes.byref(msg)
                    r = self._GetMessage(lpmsg, None, 0, 0)
                    if not r <= 0:
                        if msg.message == self.WM_STOP:
                            pass

                yield msg

        finally:
            self._threadid = None
            self.thread = None

    def start(self):
        """Starts the message loop.

        This method must be called before iterating over messages, and it must
        be called from the same thread.
        """
        self._threadid = GetCurrentThreadId()
        self.thread = threading.current_thread()
        msg = wintypes.MSG()
        lpmsg = ctypes.byref(msg)
        self._PeekMessage(lpmsg, None, 1024, 1024, self.PM_NOREMOVE)
        self._event.set()

    def stop(self):
        """Stops the message loop.
        """
        self._event.wait()
        if self._threadid:
            self.post(self.WM_STOP, 0, 0)

    def post(self, msg, wparam, lparam):
        """Posts a message to this message loop.

        :param ctypes.wintypes.UINT msg: The message.

        :param ctypes.wintypes.WPARAM wparam: The value of ``wParam``.

        :param ctypes.wintypes.LPARAM lparam: The value of ``lParam``.
        """
        self._PostThreadMessage(self._threadid, msg, wparam, lparam)


class SystemHook(object):
    __doc__ = 'A class to handle Windows hooks.\n    '
    HC_ACTION = 0
    _HOOKPROC = ctypes.WINFUNCTYPE(wintypes.LPARAM, ctypes.c_int32, wintypes.WPARAM, wintypes.LPARAM)
    _SetWindowsHookEx = windll.user32.SetWindowsHookExW
    _SetWindowsHookEx.argtypes = (
     ctypes.c_int,
     _HOOKPROC,
     wintypes.HINSTANCE,
     wintypes.DWORD)
    _UnhookWindowsHookEx = windll.user32.UnhookWindowsHookEx
    _UnhookWindowsHookEx.argtypes = (
     wintypes.HHOOK,)
    _CallNextHookEx = windll.user32.CallNextHookEx
    _CallNextHookEx.argtypes = (
     wintypes.HHOOK,
     ctypes.c_int,
     wintypes.WPARAM,
     wintypes.LPARAM)
    _HOOKS = {}

    class SuppressException(Exception):
        __doc__ = 'An exception raised by a hook callback to suppress further\n        propagation of events.\n        '

    def __init__(self, hook_id, on_hook=lambda code, msg, lpdata: None):
        self.hook_id = hook_id
        self.on_hook = on_hook
        self._hook = None

    def __enter__(self):
        key = threading.current_thread().ident
        assert key not in self._HOOKS
        self._HOOKS[key] = self
        self._hook = self._SetWindowsHookEx(self.hook_id, self._handler, None, 0)
        return self

    def __exit__(self, exc_type, value, traceback):
        key = threading.current_thread().ident
        assert key in self._HOOKS
        if self._hook is not None:
            self._UnhookWindowsHookEx(self._hook)
            del self._HOOKS[key]

    @staticmethod
    @_HOOKPROC
    def _handler(code, msg, lpdata):
        key = threading.current_thread().ident
        self = SystemHook._HOOKS.get(key, None)
        if self:
            try:
                self.on_hook(code, msg, lpdata)
            except self.SuppressException:
                return 1
            except:
                pass
            else:
                return SystemHook._CallNextHookEx(0, code, msg, lpdata)


class ListenerMixin(object):
    __doc__ = 'A mixin for *win32* event listeners.\n\n    Subclasses should set a value for :attr:`_EVENTS` and implement\n    :meth:`_handle`.\n\n    Subclasses must also be decorated with a decorator compatible with\n    :meth:`pynput._util.NotifierMixin._receiver` or implement the method\n    ``_receive()``.\n    '
    _EVENTS = None
    _WM_PROCESS = 1040
    _WM_NOTIFICATIONS = []

    def suppress_event(self):
        """Causes the currently filtered event to be suppressed.

        This has a system wide effect and will generally result in no
        applications receiving the event.

        This method will raise an undefined exception.
        """
        raise SystemHook.SuppressException()

    def _run--- This code section failed: ---

 L. 342         0  LOAD_GLOBAL              MessageLoop
                2  CALL_FUNCTION_0       0  ''
                4  LOAD_FAST                'self'
                6  STORE_ATTR               _message_loop

 L. 343         8  LOAD_FAST                'self'
               10  LOAD_METHOD              _receive
               12  CALL_METHOD_0         0  ''
               14  SETUP_WITH          168  'to 168'
               16  POP_TOP          

 L. 344        18  LOAD_FAST                'self'
               20  LOAD_METHOD              _mark_ready
               22  CALL_METHOD_0         0  ''
               24  POP_TOP          

 L. 345        26  LOAD_FAST                'self'
               28  LOAD_ATTR                _message_loop
               30  LOAD_METHOD              start
               32  CALL_METHOD_0         0  ''
               34  POP_TOP          

 L. 348        36  SETUP_FINALLY       152  'to 152'

 L. 349        38  LOAD_GLOBAL              SystemHook
               40  LOAD_FAST                'self'
               42  LOAD_ATTR                _EVENTS
               44  LOAD_FAST                'self'
               46  LOAD_ATTR                _handler
               48  CALL_FUNCTION_2       2  ''
               50  SETUP_WITH          142  'to 142'
               52  POP_TOP          

 L. 351        54  LOAD_FAST                'self'
               56  LOAD_ATTR                _message_loop
               58  GET_ITER         
             60_0  COME_FROM           136  '136'
             60_1  COME_FROM           114  '114'
             60_2  COME_FROM           102  '102'
               60  FOR_ITER            138  'to 138'
               62  STORE_FAST               'msg'

 L. 352        64  LOAD_FAST                'self'
               66  LOAD_ATTR                running
               68  POP_JUMP_IF_TRUE     74  'to 74'

 L. 353        70  POP_TOP          
               72  BREAK_LOOP          138  'to 138'
             74_0  COME_FROM            68  '68'

 L. 354        74  LOAD_FAST                'msg'
               76  LOAD_ATTR                message
               78  LOAD_FAST                'self'
               80  LOAD_ATTR                _WM_PROCESS
               82  COMPARE_OP               ==
               84  POP_JUMP_IF_FALSE   104  'to 104'

 L. 355        86  LOAD_FAST                'self'
               88  LOAD_METHOD              _process
               90  LOAD_FAST                'msg'
               92  LOAD_ATTR                wParam
               94  LOAD_FAST                'msg'
               96  LOAD_ATTR                lParam
               98  CALL_METHOD_2         2  ''
              100  POP_TOP          
              102  JUMP_BACK            60  'to 60'
            104_0  COME_FROM            84  '84'

 L. 356       104  LOAD_FAST                'msg'
              106  LOAD_ATTR                message
              108  LOAD_FAST                'self'
              110  LOAD_ATTR                _WM_NOTIFICATIONS
              112  COMPARE_OP               in
              114  POP_JUMP_IF_FALSE_BACK    60  'to 60'

 L. 357       116  LOAD_FAST                'self'
              118  LOAD_METHOD              _on_notification

 L. 358       120  LOAD_FAST                'msg'
              122  LOAD_ATTR                message

 L. 358       124  LOAD_FAST                'msg'
              126  LOAD_ATTR                wParam

 L. 358       128  LOAD_FAST                'msg'
              130  LOAD_ATTR                lParam

 L. 357       132  CALL_METHOD_3         3  ''
              134  POP_TOP          
              136  JUMP_BACK            60  'to 60'
            138_0  COME_FROM            72  '72'
            138_1  COME_FROM            60  '60'
              138  POP_BLOCK        
              140  BEGIN_FINALLY    
            142_0  COME_FROM_WITH       50  '50'
              142  WITH_CLEANUP_START
              144  WITH_CLEANUP_FINISH
              146  END_FINALLY      
              148  POP_BLOCK        
              150  JUMP_FORWARD        164  'to 164'
            152_0  COME_FROM_FINALLY    36  '36'

 L. 359       152  POP_TOP          
              154  POP_TOP          
              156  POP_TOP          

 L. 361       158  POP_EXCEPT       
              160  JUMP_FORWARD        164  'to 164'
              162  END_FINALLY      
            164_0  COME_FROM           160  '160'
            164_1  COME_FROM           150  '150'
              164  POP_BLOCK        
              166  BEGIN_FINALLY    
            168_0  COME_FROM_WITH       14  '14'
              168  WITH_CLEANUP_START
              170  WITH_CLEANUP_FINISH
              172  END_FINALLY      

Parse error at or near `BEGIN_FINALLY' instruction at offset 140

    def _stop_platform(self):
        try:
            self._message_loop.stop()
        except AttributeError:
            pass

    @AbstractListener._emitter
    def _handler(self, code, msg, lpdata):
        """The callback registered with *Windows* for events.

        This method will post the message :attr:`_WM_HANDLE` to the message
        loop started with this listener using :meth:`MessageLoop.post`. The
        parameters are retrieved with a call to :meth:`_handle`.
        """
        try:
            converted = self._convert(code, msg, lpdata)
            if converted is not None:
                (self._message_loop.post)(self._WM_PROCESS, *converted)
        except NotImplementedError:
            self._handle(code, msg, lpdata)
        else:
            if self.suppress:
                self.suppress_event()

    def _convert(self, code, msg, lpdata):
        """The device specific callback handler.

        This method converts a low-level message and data to a
        ``WPARAM`` / ``LPARAM`` pair.
        """
        raise NotImplementedError()

    def _process(self, wparam, lparam):
        """The device specific callback handler.

        This method performs the actual dispatching of events.
        """
        raise NotImplementedError()

    def _handle(self, code, msg, lpdata):
        """The device specific callback handler.

        This method calls the appropriate callback registered when this
        listener was created based on the event.

        This method is only called if :meth:`_convert` is not implemented.
        """
        raise NotImplementedError()

    def _on_notification(self, code, wparam, lparam):
        """An additional notification handler.

        This method will be called for every message in
        :attr:`_WM_NOTIFICATIONS`.
        """
        raise NotImplementedError()


class KeyTranslator(object):
    __doc__ = 'A class to translate virtual key codes to characters.\n    '
    _GetAsyncKeyState = ctypes.windll.user32.GetAsyncKeyState
    _GetAsyncKeyState.argtypes = (
     ctypes.c_int,)
    _GetKeyboardLayout = ctypes.windll.user32.GetKeyboardLayout
    _GetKeyboardLayout.argtypes = (
     wintypes.DWORD,)
    _GetKeyboardState = ctypes.windll.user32.GetKeyboardState
    _GetKeyboardState.argtypes = (
     ctypes.c_voidp,)
    _GetKeyState = ctypes.windll.user32.GetAsyncKeyState
    _GetKeyState.argtypes = (
     ctypes.c_int,)
    _MapVirtualKeyEx = ctypes.windll.user32.MapVirtualKeyExW
    _MapVirtualKeyEx.argtypes = (
     wintypes.UINT,
     wintypes.UINT,
     wintypes.HKL)
    _ToUnicodeEx = ctypes.windll.user32.ToUnicodeEx
    _ToUnicodeEx.argtypes = (
     wintypes.UINT,
     wintypes.UINT,
     ctypes.c_voidp,
     ctypes.c_voidp,
     ctypes.c_int,
     wintypes.UINT,
     wintypes.HKL)
    _MAPVK_VK_TO_VSC = 0
    _MAPVK_VSC_TO_VK = 1
    _MAPVK_VK_TO_CHAR = 2

    def __init__(self):
        self.update_layout()

    def __call__(self, vk, is_press):
        """Converts a virtual key code to a string.

        :param int vk: The virtual key code.

        :param bool is_press: Whether this is a press.

        :return: parameters suitable for the :class:`pynput.keyboard.KeyCode`
            constructor

        :raises OSError: if a call to any *win32* function fails
        """
        layout_data = self._layout_data[self._modifier_state()]
        scan = self._to_scan(vk, self._layout)
        character, is_dead = layout_data[scan]
        return {'char':character, 
         'is_dead':is_dead, 
         'vk':vk, 
         '_scan':scan}

    def update_layout(self):
        """Updates the cached layout data.
        """
        self._layout, self._layout_data = self._generate_layout()

    def char_from_scan(self, scan):
        """Translates a scan code to a character, if possible.

        :param int scan: The scan code to translate.

        :return: maybe a character
        :rtype: str or None
        """
        return self._layout_data[(False, False, False)][scan][0]

    def _generate_layout(self):
        """Generates the keyboard layout.

        This method will call ``ToUnicodeEx``, which modifies kernel buffers,
        so it must *not* be called from the keyboard hook.

        The return value is the tuple ``(layout_handle, layout_data)``, where
        ``layout_data`` is a mapping from the tuple ``(shift, ctrl, alt)`` to
        an array indexed by scan code containing the data
        ``(character, is_dead)``, and ``layout_handle`` is the handle of the
        layout.

        :return: a composite layout
        """
        layout_data = {}
        state = (ctypes.c_ubyte * 255)()
        with self._thread_input() as active_thread:
            layout = self._GetKeyboardLayout(active_thread)
        vks = [self._to_vk(scan, layout) for scan in range(len(state))]
        for shift, ctrl, alt in itertools.product((False, True), (False, True), (False,
                                                                                 True)):
            current = [
             (None, False)] * len(state)
            layout_data[(shift, ctrl, alt)] = current
            state[VK.SHIFT] = 128 if shift else 0
            state[VK.CONTROL] = 128 if ctrl else 0
            state[VK.MENU] = 128 if alt else 0
            out = (ctypes.wintypes.WCHAR * 5)()
            for scan, vk in enumerate(vks):
                count = self._ToUnicodeEx(vk, scan, ctypes.byref(state), ctypes.byref(out), len(out), 0, layout)
                if count != 0:
                    character = out[0]
                    is_dead = count < 0
                    current[scan] = (character, is_dead)
                    if is_dead:
                        self._ToUnicodeEx(VK.DECIMAL, vks[VK.DECIMAL], ctypes.byref(state), ctypes.byref(out), len(out), 0, layout)
            else:
                return (
                 layout, layout_data)

    def _to_scan(self, vk, layout):
        """Retrieves the scan code for a virtual key code.

        :param int vk: The virtual key code.

        :param layout: The keyboard layout.

        :return: the scan code
        """
        return self._MapVirtualKeyEx(vk, self._MAPVK_VK_TO_VSC, layout)

    def _to_vk(self, scan, layout):
        """Retrieves the virtual key code for a scan code.

        :param int vscan: The scan code.

        :param layout: The keyboard layout.

        :return: the virtual key code
        """
        return self._MapVirtualKeyEx(scan, self._MAPVK_VSC_TO_VK, layout)

    def _modifier_state(self):
        """Returns a key into :attr:`_layout_data` for the current modifier
        state.

        :return: the current modifier state
        """
        shift = bool(self._GetAsyncKeyState(VK.SHIFT) & 32768)
        ctrl = bool(self._GetAsyncKeyState(VK.CONTROL) & 32768)
        alt = bool(self._GetAsyncKeyState(VK.MENU) & 32768)
        return (
         shift, ctrl, alt)

    @contextlib.contextmanager
    def _thread_input(self):
        """Yields the current thread ID.
        """
        yield GetCurrentThreadId()